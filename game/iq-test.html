<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>üé≤ Math Genius: Sequence Master (Canvas Edition)</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Quicksand:wght@500;700&display=swap');

  :root {
    --bg-color: #0f172a;
    --card-bg: #1e293b;
    --primary: #8b5cf6;
    --accent: #f472b6;
    --text: #f1f5f9;
    --success: #10b981;
    --fail: #ef4444;
    --input-bg: #334155;
  }

  [data-theme="light"] {
    --bg-color: #f0f9ff;
    --card-bg: #ffffff;
    --primary: #6366f1;
    --accent: #ec4899;
    --text: #1e293b;
    --success: #059669;
    --fail: #dc2626;
    --input-bg: #e2e8f0;
  }

  * { box-sizing: border-box; user-select: none; }
  
  body {
    margin: 0; padding: 0;
    font-family: 'Quicksand', sans-serif;
    background-color: var(--bg-color);
    color: var(--text);
    overflow: hidden; /* Canvas covers full screen usually, but we use card layout */
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    transition: background 0.3s;
  }

  .game-container {
    position: relative;
    width: 100%;
    max-width: 600px;
    height: 95vh;
    background: var(--card-bg);
    border-radius: 20px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    transition: background 0.3s;
  }

  /* Canvas Layer */
  #gameCanvas {
    width: 100%;
    flex: 1; /* Chi·∫øm ph·∫ßn l·ªõn di·ªán t√≠ch */
    cursor: crosshair;
    background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.05) 100%);
  }

  /* UI Overlay Layer */
  .ui-layer {
    padding: 15px 20px;
    background: rgba(0,0,0,0.02);
    z-index: 10;
    backdrop-filter: blur(5px);
    border-top: 1px solid rgba(255,255,255,0.1);
  }

  /* Header Controls */
  .header-controls {
    position: absolute;
    top: 0; left: 0; right: 0;
    padding: 15px;
    display: flex;
    justify-content: space-between;
    z-index: 20;
    pointer-events: none; /* Let clicks pass through to canvas if needed */
  }
  .header-controls > * { pointer-events: auto; }

  .theme-btn, .settings-btn {
    background: rgba(255,255,255,0.1);
    border: none;
    color: var(--text);
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    backdrop-filter: blur(4px);
  }

  /* Bottom Controls */
  .control-panel {
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }

  input[type="number"] {
    flex: 1;
    padding: 12px 15px;
    border-radius: 12px;
    border: 2px solid transparent;
    background: var(--input-bg);
    color: var(--text);
    font-family: 'Orbitron', sans-serif;
    font-size: 1.2rem;
    outline: none;
    transition: all 0.2s;
  }
  input[type="number"]:focus {
    border-color: var(--primary);
    box-shadow: 0 0 15px rgba(139, 92, 246, 0.3);
  }

  button {
    padding: 0 25px;
    border-radius: 12px;
    border: none;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    transition: transform 0.1s, filter 0.2s;
  }
  
  #submitBtn { background: var(--primary); color: white; }
  #hintBtn { background: var(--accent); color: white; }
  
  button:active { transform: scale(0.95); }
  button:disabled { filter: grayscale(1); opacity: 0.5; cursor: not-allowed; }

  /* Settings Modal */
  .modal {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85);
    z-index: 100;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0; pointer-events: none;
    transition: opacity 0.3s;
  }
  .modal.active { opacity: 1; pointer-events: auto; }
  
  .modal-content {
    background: var(--card-bg);
    padding: 30px;
    border-radius: 20px;
    width: 90%;
    max-width: 400px;
    text-align: center;
    border: 1px solid var(--primary);
  }

  .modal h2 { margin-top: 0; color: var(--primary); font-family: 'Orbitron', sans-serif; }

  .form-group { margin-bottom: 15px; text-align: left; }
  label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--text); }
  select, input { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #555; background: var(--input-bg); color: var(--text); }

  .btn-start {
    width: 100%; margin-top: 15px;
    background: linear-gradient(45deg, var(--primary), var(--accent));
    color: white; padding: 15px; font-size: 1.2rem;
  }
  
  /* Leaderboard in Modal */
  .leaderboard-list {
    list-style: none; padding: 0; margin: 10px 0;
    max-height: 150px; overflow-y: auto;
    text-align: left;
  }
  .leaderboard-list li {
    padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.1);
    display: flex; justify-content: space-between;
  }

  /* Utility classes */
  .hidden { display: none !important; }
</style>
</head>
<body data-theme="dark">

<div class="game-container">
  <!-- Header Overlay -->
  <div class="header-controls">
    <button class="theme-btn" id="themeBtn">üåì Theme</button>
    <div style="font-family: 'Orbitron'; font-size: 1.2rem; color: var(--primary);">MATH GENIUS</div>
    <button class="settings-btn" id="menuBtn">‚öôÔ∏è Menu</button>
  </div>

  <!-- Main Canvas Area -->
  <canvas id="gameCanvas"></canvas>

  <!-- Bottom Interactions -->
  <div class="ui-layer" id="uiLayer">
    <div style="text-align: center; margin-bottom: 10px; font-style: italic; opacity: 0.7; height: 20px;" id="hintText"></div>
    <div class="control-panel">
      <input type="number" id="answerInput" placeholder="S·ªë ti·∫øp theo?" autocomplete="off">
      <button id="submitBtn">NH·∫¨P</button>
      <button id="hintBtn">G·ª¢I √ù</button>
    </div>
  </div>

  <!-- Start/Settings Modal -->
  <div class="modal active" id="startModal">
    <div class="modal-content">
      <h2>C·∫§U H√åNH GAME</h2>
      
      <div class="form-group">
        <label>Ch·ªß ƒë·ªÅ d√£y s·ªë</label>
        <select id="topicSelect">
          <option value="all">T·∫•t c·∫£ (H·ªón h·ª£p)</option>
          <option value="csc">C·∫•p s·ªë c·ªông</option>
          <option value="csn">C·∫•p s·ªë nh√¢n</option>
          <option value="fib">Fibonacci & Bi·∫øn th·ªÉ</option>
          <option value="prime">S·ªë nguy√™n t·ªë</option>
          <option value="square">L≈©y th·ª´a</option>
        </select>
      </div>

      <div class="form-group">
        <label>ƒê·ªô kh√≥</label>
        <select id="difficultySelect">
          <option value="easy">T·∫≠p s·ª± (D·ªÖ)</option>
          <option value="medium">Chuy√™n gia (V·ª´a)</option>
          <option value="hard">Thi√™n t√†i (Kh√≥)</option>
        </select>
      </div>

      <button class="btn-start" id="startBtn">B·∫ÆT ƒê·∫¶U CH∆†I</button>
      
      <div style="margin-top: 20px; border-top: 1px solid #555; padding-top: 10px;">
        <h4 style="margin:0 0 10px 0;">B·∫£ng v√†ng</h4>
        <ul class="leaderboard-list" id="leaderboard"></ul>
      </div>
    </div>
  </div>
</div>

<script>
/**
 * MATH GENIUS - CANVAS PRO EDITION
 * Refactored by: "The 30-Year Experience Dev"
 */

// --- UTILITIES ---
const Utils = {
  randInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
  lerp: (start, end, t) => start * (1 - t) + end * t,
  easeOutBack: (x) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
  },
  // Detect if light or dark theme active for canvas colors
  getColors: () => {
    const isDark = document.body.getAttribute('data-theme') === 'dark';
    return {
      text: isDark ? '#f1f5f9' : '#1e293b',
      primary: isDark ? '#8b5cf6' : '#6366f1',
      accent: isDark ? '#f472b6' : '#ec4899',
      success: isDark ? '#10b981' : '#059669',
      fail: isDark ? '#ef4444' : '#dc2626',
      dim: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)'
    };
  }
};

// --- LOGIC ENGINE ---
class SequenceGenerator {
  static generate(type, diff) {
    const len = 5; // Lu√¥n hi·ªán 5 s·ªë, ƒëo√°n s·ªë th·ª© 6
    const limit = diff === 'easy' ? 20 : diff === 'medium' ? 50 : 100;
    
    let seq = [], ans = 0, hint = "";
    
    // Helper ƒë·ªÉ ch·ªçn ng·∫´u nhi√™n n·∫øu type = all
    if (type === 'all') {
      const types = ['csc', 'csn', 'fib', 'prime', 'square'];
      type = types[Utils.randInt(0, types.length - 1)];
    }

    switch (type) {
      case 'csc': {
        const d = Utils.randInt(2, diff === 'hard' ? 20 : 10);
        const start = Utils.randInt(1, limit);
        for(let i=0; i<len; i++) seq.push(start + i*d);
        ans = start + len*d;
        hint = `C·ªông d·∫ßn m·ªôt h·∫±ng s·ªë d = ${d}`;
        break;
      }
      case 'csn': {
        const q = Utils.randInt(2, diff === 'hard' ? 5 : 3);
        const start = Utils.randInt(1, diff === 'easy' ? 5 : 10);
        for(let i=0; i<len; i++) seq.push(start * Math.pow(q, i));
        ans = start * Math.pow(q, len);
        hint = `Nh√¢n d·∫ßn v·ªõi h·∫±ng s·ªë q = ${q}`;
        break;
      }
      case 'fib': {
        const a = Utils.randInt(1, 5);
        const b = Utils.randInt(a, a+5);
        seq = [a, b];
        for(let i=2; i<len; i++) seq.push(seq[i-1] + seq[i-2]);
        ans = seq[len-1] + seq[len-2];
        hint = `S·ªë sau b·∫±ng t·ªïng hai s·ªë li·ªÅn tr∆∞·ªõc`;
        break;
      }
      case 'square': {
        const start = Utils.randInt(1, 5);
        for(let i=0; i<len; i++) seq.push(Math.pow(start+i, 2));
        ans = Math.pow(start+len, 2);
        hint = `B√¨nh ph∆∞∆°ng c√°c s·ªë t·ª± nhi√™n li√™n ti·∫øp`;
        break;
      }
      case 'prime': {
        // D√£y s·ªë nguy√™n t·ªë ƒë∆°n gi·∫£n b·∫Øt ƒë·∫ßu t·ª´ random
        const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71];
        const startIdx = Utils.randInt(0, 5);
        seq = primes.slice(startIdx, startIdx + len);
        ans = primes[startIdx + len];
        hint = `D√£y s·ªë nguy√™n t·ªë li·ªÅn k·ªÅ`;
        break;
      }
    }
    return { seq, ans, hint, type };
  }
}

// --- PARTICLE SYSTEM ---
class Particle {
  constructor(x, y, color, type = 'confetti') {
    this.x = x; this.y = y;
    this.color = color;
    this.size = Utils.randInt(3, 8);
    this.vx = (Math.random() - 0.5) * 10;
    this.vy = (Math.random() - 0.5) * 10;
    this.life = 1.0;
    this.decay = Math.random() * 0.02 + 0.01;
    this.gravity = 0.2;
    this.type = type;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += this.gravity;
    this.life -= this.decay;
    if (this.type === 'star') this.rotation += 0.1;
  }
  draw(ctx) {
    ctx.globalAlpha = Math.max(0, this.life);
    ctx.fillStyle = this.color;
    ctx.beginPath();
    if (this.type === 'confetti') {
      ctx.fillRect(this.x, this.y, this.size, this.size);
    } else {
      ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}

// --- GAME RENDERER (CANVAS) ---
class GameRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.particles = [];
    this.width = canvas.width;
    this.height = canvas.height;
    
    // Animation state
    this.floatingOffset = 0;
    this.numbers = []; // {val, x, y, targetX, targetY, scale, alpha}
    this.feedback = { text: '', scale: 0, alpha: 0, type: 'neutral' };
    
    this.resize();
    window.addEventListener('resize', () => this.resize());
  }

  resize() {
    const parent = this.canvas.parentElement;
    this.canvas.width = parent.clientWidth;
    this.canvas.height = parent.clientHeight;
    this.width = this.canvas.width;
    this.height = this.canvas.height;
  }

  // Kh·ªüi t·∫°o c√°c s·ªë ƒë·ªÉ chu·∫©n b·ªã animate v√†o
  setupSequence(seq) {
    const spacing = Math.min(this.width / (seq.length + 1), 100);
    const startX = (this.width - spacing * (seq.length - 1)) / 2;
    
    this.numbers = seq.map((val, i) => ({
      val: val,
      x: startX + i * spacing,
      y: this.height / 2 + 100, // B·∫Øt ƒë·∫ßu t·ª´ d∆∞·ªõi
      targetX: startX + i * spacing,
      targetY: this.height / 2,
      scale: 0,
      targetScale: 1,
      alpha: 0
    }));
  }

  triggerExplosion(x, y, color) {
    for(let i=0; i<30; i++) {
      this.particles.push(new Particle(x, y, color));
    }
  }

  showFeedback(text, type) {
    this.feedback = {
      text: text,
      scale: 0,
      alpha: 1,
      type: type // success or fail
    };
  }

  clear() {
    this.ctx.clearRect(0, 0, this.width, this.height);
  }

  draw(dt, gameState) {
    const colors = Utils.getColors();
    this.clear();
    this.floatingOffset += dt * 0.002;

    // 1. Draw Background grid effect
    this.ctx.strokeStyle = colors.dim;
    this.ctx.lineWidth = 1;
    const gridSize = 40;
    const offset = (Date.now() / 50) % gridSize;
    for(let x=offset; x<this.width; x+=gridSize) {
      this.ctx.beginPath(); this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.height); this.ctx.stroke();
    }

    // 2. Draw Timer (Circular)
    const timerRadius = 40;
    const timerX = this.width - 60;
    const timerY = 60;
    
    this.ctx.beginPath();
    this.ctx.arc(timerX, timerY, timerRadius, 0, Math.PI * 2);
    this.ctx.strokeStyle = colors.dim;
    this.ctx.lineWidth = 6;
    this.ctx.stroke();

    const pct = Math.max(0, gameState.timeLeft / gameState.totalTime);
    this.ctx.beginPath();
    this.ctx.arc(timerX, timerY, timerRadius, -Math.PI/2, -Math.PI/2 + (Math.PI*2 * pct));
    this.ctx.strokeStyle = pct < 0.3 ? colors.fail : colors.primary;
    this.ctx.stroke();
    
    this.ctx.fillStyle = colors.text;
    this.ctx.font = "bold 18px Quicksand";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    this.ctx.fillText(Math.ceil(gameState.timeLeft), timerX, timerY);

    // 3. Draw Score & Combo
    this.ctx.textAlign = "left";
    this.ctx.font = "bold 24px Orbitron";
    this.ctx.fillStyle = colors.primary;
    this.ctx.fillText(`SCORE: ${gameState.score}`, 30, 60);
    
    if (gameState.combo > 1) {
      this.ctx.font = "bold 16px Quicksand";
      this.ctx.fillStyle = colors.accent;
      this.ctx.fillText(`COMBO x${gameState.combo} üî•`, 30, 85);
    }

    // 4. Draw Sequence Numbers
    this.ctx.font = "bold 40px Orbitron";
    this.numbers.forEach((num, i) => {
      // Lerp animation
      num.x = Utils.lerp(num.x, num.targetX, 0.1);
      num.y = Utils.lerp(num.y, num.targetY + Math.sin(this.floatingOffset + i)*10, 0.1);
      num.scale = Utils.lerp(num.scale, num.targetScale, 0.1);
      num.alpha = Utils.lerp(num.alpha, 1, 0.05);

      this.ctx.save();
      this.ctx.translate(num.x, num.y);
      this.ctx.scale(num.scale, num.scale);
      
      // Shadow/Glow
      this.ctx.shadowColor = colors.primary;
      this.ctx.shadowBlur = 15;
      
      this.ctx.fillStyle = colors.text;
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "middle";
      this.ctx.fillText(num.val, 0, 0);
      
      this.ctx.restore();
    });

    // Draw the "?" box
    if (this.numbers.length > 0) {
      const lastNum = this.numbers[this.numbers.length-1];
      const spacing = lastNum.targetX - this.numbers[this.numbers.length-2].targetX;
      const qX = lastNum.targetX + spacing;
      const qY = lastNum.targetY + Math.sin(this.floatingOffset + this.numbers.length)*10;
      
      this.ctx.fillStyle = colors.accent;
      this.ctx.font = "bold 40px Orbitron";
      this.ctx.fillText("?", qX, qY);
    }

    // 5. Draw Feedback (Correct/Wrong)
    if (this.feedback.alpha > 0.01) {
      this.ctx.save();
      this.ctx.globalAlpha = this.feedback.alpha;
      this.feedback.scale = Utils.lerp(this.feedback.scale, 1.5, 0.2);
      this.feedback.alpha = Utils.lerp(this.feedback.alpha, 0, 0.02); // Fade out
      
      this.ctx.translate(this.width/2, this.height/2 - 100);
      this.ctx.scale(this.feedback.scale, this.feedback.scale);
      this.ctx.font = "bold 40px Quicksand";
      this.ctx.fillStyle = this.feedback.type === 'success' ? colors.success : colors.fail;
      this.ctx.fillText(this.feedback.text, 0, 0);
      this.ctx.restore();
    }

    // 6. Update & Draw Particles
    for (let i = this.particles.length - 1; i >= 0; i--) {
      let p = this.particles[i];
      p.update();
      p.draw(this.ctx);
      if (p.life <= 0) this.particles.splice(i, 1);
    }
  }
}

// --- GAME CONTROLLER ---
class Game {
  constructor() {
    this.canvas = document.getElementById('gameCanvas');
    this.renderer = new GameRenderer(this.canvas);
    
    // UI Elements
    this.input = document.getElementById('answerInput');
    this.submitBtn = document.getElementById('submitBtn');
    this.hintBtn = document.getElementById('hintBtn');
    this.hintText = document.getElementById('hintText');
    this.modal = document.getElementById('startModal');
    this.startBtn = document.getElementById('startBtn');
    this.uiLayer = document.getElementById('uiLayer');
    
    // State
    this.state = {
      score: 0,
      combo: 0,
      timeLeft: 0,
      totalTime: 20,
      currentQ: null,
      isPlaying: false
    };

    this.timerLoop = null;
    this.lastTime = 0;

    this.bindEvents();
    this.loadLeaderboard();
  }

  bindEvents() {
    this.startBtn.addEventListener('click', () => this.startGame());
    
    this.submitBtn.addEventListener('click', () => this.checkAnswer());
    
    this.input.addEventListener('keydown', (e) => {
      if(e.key === 'Enter') this.checkAnswer();
    });

    this.hintBtn.addEventListener('click', () => {
      if(this.state.score >= 2) {
        this.state.score -= 2;
        this.hintText.textContent = this.state.currentQ.hint;
        this.hintBtn.disabled = true;
      }
    });

    document.getElementById('menuBtn').addEventListener('click', () => {
      this.stopGame();
      this.modal.classList.add('active');
    });

    document.getElementById('themeBtn').addEventListener('click', () => {
      const b = document.body;
      b.setAttribute('data-theme', b.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
    });
  }

  startGame() {
    // Get Settings
    const topic = document.getElementById('topicSelect').value;
    const diff = document.getElementById('difficultySelect').value;
    
    this.config = { topic, diff };
    this.state.score = 0;
    this.state.combo = 0;
    this.state.isPlaying = true;
    
    this.modal.classList.remove('active');
    this.uiLayer.classList.remove('hidden');
    
    // Start Game Loop
    this.lastTime = performance.now();
    requestAnimationFrame((t) => this.loop(t));
    
    this.nextQuestion();
  }

  stopGame() {
    this.state.isPlaying = false;
    this.saveScore(this.state.score);
  }

  nextQuestion() {
    if (!this.state.isPlaying) return;

    this.state.currentQ = SequenceGenerator.generate(this.config.topic, this.config.diff);
    this.renderer.setupSequence(this.state.currentQ.seq);
    
    this.input.value = "";
    this.input.focus();
    this.input.disabled = false;
    this.submitBtn.disabled = false;
    this.hintBtn.disabled = false;
    this.hintText.textContent = "";
    
    // Reset Timer
    this.state.totalTime = this.config.diff === 'easy' ? 20 : 15;
    this.state.timeLeft = this.state.totalTime;
  }

  checkAnswer() {
    if (!this.state.isPlaying) return;
    
    const val = parseFloat(this.input.value);
    const correct = this.state.currentQ.ans;
    const colors = Utils.getColors();

    if (val === correct) {
      // Correct
      this.state.score += 10 + (this.state.combo * 2);
      this.state.combo++;
      this.renderer.showFeedback("CH√çNH X√ÅC!", "success");
      this.renderer.triggerExplosion(this.renderer.width/2, this.renderer.height/2, colors.success);
      
      // Delay to next question
      this.input.disabled = true;
      setTimeout(() => this.nextQuestion(), 1000);
    } else {
      // Wrong
      this.state.combo = 0;
      this.renderer.showFeedback("SAI R·ªíI!", "fail");
      this.input.value = "";
      this.input.focus();
      // Penalty time?
      this.state.timeLeft -= 2;
    }
  }

  loop(timestamp) {
    if (!this.state.isPlaying) return;

    const dt = timestamp - this.lastTime;
    this.lastTime = timestamp;

    // Logic Timer
    this.state.timeLeft -= dt / 1000;
    if (this.state.timeLeft <= 0) {
      this.gameOver();
      return; // Stop loop
    }

    // Render
    this.renderer.draw(dt, this.state);

    requestAnimationFrame((t) => this.loop(t));
  }

  gameOver() {
    this.state.isPlaying = false;
    this.renderer.showFeedback("H·∫æT GI·ªú!", "fail");
    setTimeout(() => {
      alert(`K·∫øt th√∫c! ƒêi·ªÉm c·ªßa b·∫°n: ${this.state.score}`);
      this.stopGame();
      this.modal.classList.add('active');
      this.loadLeaderboard();
    }, 1000);
  }

  saveScore(score) {
    if (score === 0) return;
    let lb = JSON.parse(localStorage.getItem('math_lb') || '[]');
    lb.push({ score, date: new Date().toLocaleDateString() });
    lb.sort((a,b) => b.score - a.score);
    localStorage.setItem('math_lb', JSON.stringify(lb.slice(0, 5)));
  }

  loadLeaderboard() {
    const list = document.getElementById('leaderboard');
    list.innerHTML = "";
    const lb = JSON.parse(localStorage.getItem('math_lb') || '[]');
    lb.forEach(item => {
      const li = document.createElement('li');
      li.innerHTML = `<span>${item.date}</span> <strong>${item.score} pts</strong>`;
      list.appendChild(li);
    });
    if(lb.length === 0) list.innerHTML = "<li>Ch∆∞a c√≥ d·ªØ li·ªáu</li>";
  }
}

// Initialize Game
window.onload = () => {
  const game = new Game();
};

</script>
</body>
</html>