<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>üåå QUANTUM SNAKE: OPTIMIZED</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&family=Orbitron:wght@900&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --q-cyan: #00f0ff;
      --q-blue: #0051ff;
      --q-pink: #ff0055;
      --q-void: #020205;
      --q-border: rgba(0, 240, 255, 0.4);
    }
    
    * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

    body {
      background-color: var(--q-void);
      background-image: radial-gradient(circle at 50% 50%, #0f1020 0%, #000 100%);
      font-family: 'Rajdhani', sans-serif;
      margin: 0; padding: 0;
      height: 100vh; width: 100vw;
      overflow: hidden;
      color: #fff;
      display: flex; justify-content: center; align-items: center;
    }

    #main-wrapper {
      position: relative; width: 100%; height: 100%;
      display: flex; flex-direction: column; 
      justify-content: center; align-items: center;
      z-index: 10;
    }

    /* --- UI ELEMENTS --- */
    .glass-panel {
      background: rgba(10, 15, 30, 0.9);
      backdrop-filter: blur(20px);
      border: 1px solid var(--q-border);
      box-shadow: 0 0 50px rgba(0, 240, 255, 0.15), inset 0 0 30px rgba(0,0,0,0.8);
      border-radius: 16px;
      padding: 30px;
      max-width: 500px; width: 90%;
      position: relative;
      transition: opacity 0.4s, transform 0.4s;
      z-index: 100;
    }

    .glass-panel::before, .glass-panel::after {
      content: ''; position: absolute; width: 25px; height: 25px;
      border: 3px solid var(--q-cyan); transition: 0.3s;
      box-shadow: 0 0 10px var(--q-cyan);
    }
    .glass-panel::before { top: -2px; left: -2px; border-right: none; border-bottom: none; }
    .glass-panel::after { bottom: -2px; right: -2px; border-left: none; border-top: none; }

    h1 {
      margin: 0 0 5px 0;
      font-family: 'Orbitron', sans-serif;
      font-weight: 900; font-size: 2.8rem;
      color: #fff;
      text-transform: uppercase; letter-spacing: 2px;
      text-shadow: 0 0 20px var(--q-cyan), 0 0 40px var(--q-blue);
      text-align: center;
    }

    .subtitle {
      color: var(--q-cyan); font-size: 1.1rem; margin-bottom: 25px;
      text-align: center; text-transform: uppercase; letter-spacing: 4px;
      opacity: 0.9; font-weight: 700; text-shadow: 0 0 10px var(--q-cyan);
    }

    .form-group { margin-bottom: 20px; }
    .form-group label {
      display: block; font-size: 0.9rem; margin-bottom: 8px;
      color: #aab; text-transform: uppercase; letter-spacing: 1px; font-weight: 700;
    }

    select, input {
      width: 100%; padding: 14px;
      background: rgba(0, 10, 20, 0.6);
      border: 1px solid #456; border-radius: 8px;
      color: var(--q-cyan); font-family: 'Orbitron', sans-serif; font-size: 1.1rem; font-weight: 700;
      outline: none; transition: 0.3s;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
    }
    select:focus, input:focus {
      border-color: var(--q-cyan); background: rgba(0, 240, 255, 0.05);
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
    }

    .btn-start {
      width: 100%; padding: 18px; margin-top: 10px;
      background: linear-gradient(90deg, transparent 0%, rgba(0, 240, 255, 0.1) 50%, transparent 100%);
      border: 2px solid var(--q-cyan);
      color: #fff; font-weight: 900; font-size: 1.3rem;
      text-transform: uppercase; letter-spacing: 3px;
      cursor: pointer; position: relative; overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      transition: 0.3s;
      text-shadow: 0 0 10px var(--q-cyan);
    }
    .btn-start:hover {
      background: var(--q-cyan); color: #000;
      box-shadow: 0 0 40px var(--q-cyan);
      text-shadow: none;
    }

    /* --- GAME UI --- */
    #gameUI { 
      display: none; flex-direction: column; align-items: center; 
      width: 100%; height: 100%; justify-content: center; z-index: 20; 
    }

    .hud-quantum {
      display: flex; gap: 20px; margin-bottom: 20px;
      position: relative; z-index: 30;
    }
    .hud-box {
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(0, 240, 255, 0.3);
      padding: 8px 25px; border-radius: 8px;
      text-align: center;
      min-width: 120px;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.1);
      backdrop-filter: blur(5px);
    }
    .hud-label { font-size: 0.75rem; color: #889; letter-spacing: 2px; text-transform: uppercase; font-weight: 700; margin-bottom: 2px; }
    .hud-val { font-family: 'Orbitron', sans-serif; font-size: 1.8rem; color: #fff; font-weight: 900; }

    canvas {
      background: rgba(2, 2, 5, 0.85);
      border: 2px solid rgba(0, 240, 255, 0.2);
      box-shadow: 0 0 60px rgba(0, 240, 255, 0.15);
      border-radius: 12px;
      display: block;
      /* Quan tr·ªçng: GPU acceleration hint */
      transform: translateZ(0); 
    }

    .hidden { display: none !important; }
    .row { display: flex; gap: 15px; }
    .col { flex: 1; }
    
    #targetWrapper { transition: opacity 0.5s, transform 0.5s; }
    #targetWrapper.hidden-hint { opacity: 0; transform: translateY(-20px); }

    /* --- GAME OVER --- */
    #gameOverModal {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.95);
      display: flex; justify-content: center; align-items: center;
      z-index: 50; opacity: 0; pointer-events: none; transition: 0.3s;
    }
    #gameOverModal.show { opacity: 1; pointer-events: auto; }

    #flashOverlay {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: #fff; pointer-events: none; opacity: 0;
      z-index: 40; transition: opacity 0.1s; mix-blend-mode: overlay;
    }
  </style>
</head>
<body>

  <div id="flashOverlay"></div>

  <div id="main-wrapper">

    <!-- START SCREEN -->
    <div id="startScreen" class="glass-panel">
      <h1>QUANTUM SNAKE</h1>
      <div class="subtitle">Optimized Edition</div>
      
      <div class="form-group">
        <label>Ch·∫ø ƒê·ªô Ch∆°i</label>
        <select id="modeSelect" onchange="updateFormInputs()">
          <option value="geometric" selected>C·∫•p S·ªë Nh√¢n (x)</option>
          <option value="arithmetic">C·∫•p S·ªë C·ªông (+)</option>
          <option value="natural">S·ªë T·ª± Nhi√™n</option>
          <option value="even">S·ªë Ch·∫µn</option>
          <option value="odd">S·ªë L·∫ª</option>
          <option value="prime">S·ªë Nguy√™n T·ªë</option>
          <option value="fibonacci">Fibonacci</option>
          <option value="divisible">B·ªôi S·ªë C·ªßa N</option>
        </select>
      </div>

      <div class="row hidden" id="customParams">
        <div class="col" id="u1Container">
          <div class="form-group">
            <label>S·ªë ƒê·∫ßu (u‚ÇÅ)</label>
            <input type="number" id="startInput" value="1" min="0" max="100">
          </div>
        </div>
        <div class="col" id="paramContainer">
          <div class="form-group">
            <label id="paramLabel">C√¥ng B·ªôi (q)</label>
            <input type="number" id="paramInput" value="2" min="1" max="20">
          </div>
        </div>
      </div>

      <button class="btn-start" onclick="initGame()">KH·ªûI ƒê·ªòNG</button>
      <div style="text-align:center; margin-top:20px; font-size:0.85rem; color:#789;">
        SYSTEM: Ready<br>T·ªëc ƒë·ªô s·∫Ω tƒÉng d·∫ßn theo ƒëi·ªÉm s·ªë
      </div>
    </div>

    <!-- GAME UI -->
    <div id="gameUI">
      <div class="hud-quantum">
        <div class="hud-box" id="targetWrapper">
          <div class="hud-label">M·ª§C TI√äU</div>
          <div class="hud-val" id="targetBadge" style="color:var(--q-cyan); text-shadow: 0 0 15px var(--q-cyan)">?</div>
        </div>
        <div class="hud-box">
          <div class="hud-label">ƒêI·ªÇM S·ªê</div>
          <div class="hud-val" id="score">0</div>
        </div>
      </div>
      
      <canvas id="gameCanvas"></canvas>
      <div style="margin-top:15px; font-size:0.9rem; color:#567; letter-spacing:2px; font-weight:bold">
        VU·ªêT ƒê·ªÇ ƒêI·ªÄU KHI·ªÇN
      </div>
    </div>

    <!-- GAME OVER -->
    <div id="gameOverModal">
      <div class="glass-panel" style="text-align: center; border-color: #ff0055; box-shadow: 0 0 50px rgba(255, 0, 85, 0.4);">
        <h2 style="color: #ff0055; margin-bottom: 10px; font-family:'Orbitron'; font-size: 2.5rem; text-shadow: 0 0 20px #ff0055">TH·∫§T B·∫†I!</h2>
        <div style="font-size: 4rem; font-family:'Orbitron'; font-weight:900; margin:10px 0; color:#fff; text-shadow: 0 0 30px rgba(255,255,255,0.5)" id="finalScore">0</div>
        <div style="color:#aab; margin-bottom:25px; font-size:1.1rem">C·∫ßn t√¨m s·ªë: <strong id="missedTarget" style="color:#fff; font-size:1.4rem"></strong></div>
        
        <div class="row">
          <button class="btn-start" style="margin-top:0; border-color:#556; color:#889; background:transparent" onclick="backToMenu()">MENU</button>
          <button class="btn-start" style="margin-top:0; border-color:#ff0055; color:#ff0055; background: rgba(255,0,85,0.1)" onclick="restartGame()">CH∆†I L·∫†I</button>
        </div>
      </div>
    </div>

  </div>

<script>
  // --- CORE SYSTEM ---
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const box = 40; 
  let rows, cols;
  
  // UI References
  const startScreen = document.getElementById('startScreen');
  const gameUI = document.getElementById('gameUI');
  const modal = document.getElementById('gameOverModal');
  const targetWrapper = document.getElementById('targetWrapper');
  const customParams = document.getElementById('customParams');
  const flashOverlay = document.getElementById('flashOverlay');

  // Game Logic
  let requestID; // RequestAnimationFrame ID
  let snake = [];
  let dir = '', nextDir = '';
  let score = 0;
  let foods = [];
  let highscore = localStorage.getItem('highscore_quantum') || 0;
  let eatenCount = 0;
  
  // Speed & Time Logic (Decoupled Loop)
  let lastTime = 0;
  let moveTimer = 0;
  let currentSpeed = 220; // B·∫Øt ƒë·∫ßu ch·∫≠m h∆°n (ms)
  let minSpeed = 80;      // T·ªëc ƒë·ªô t·ªëi ƒëa
  let speedStep = 4;      // Gi·∫£m bao nhi√™u ms m·ªói l·∫ßn ƒÉn
  let time = 0;           // For breathing effects

  // Visual Effects State
  let particles = [];
  let shockwaves = [];
  let floatingTexts = [];
  let sparkles = [];
  let shakeIntensity = 0;
  
  // Math Settings
  let gameMode = 'geometric';
  let param1 = 2; 
  let paramStart = 1; 
  let currentVal = 1;
  let prevVal = 0; 

  // --- CLASSES FOR EFFECTS (OPTIMIZED) ---
  
  class FloatingText {
    constructor(x, y, text, color) {
      this.x = x; this.y = y;
      this.text = text; this.color = color;
      this.life = 1.0;
      this.vy = -2; // Bay ch·∫≠m h∆°n
    }
    update() {
      this.y += this.vy;
      this.life -= 0.02;
    }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = this.color;
      ctx.font = "900 24px 'Orbitron'";
      ctx.textAlign = "center";
      ctx.fillText(this.text, this.x, this.y);
      ctx.globalAlpha = 1;
    }
  }

  class Shockwave {
    constructor(x, y, color) {
      this.x = x; this.y = y;
      this.radius = 10;
      this.maxRadius = box * 4;
      this.life = 1.0;
      this.color = color;
    }
    update() {
      this.radius += 5; // Lan t·ªèa nhanh
      this.life -= 0.05;
    }
    draw(ctx) {
      if (this.life <= 0) return;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 4 * this.life;
      ctx.globalAlpha = this.life; // Fading opacity
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  }

  class Particle {
    constructor(x, y, color) {
      this.x = x; this.y = y;
      let angle = Math.random() * Math.PI * 2;
      let speed = Math.random() * 4 + 1; // Gi·∫£m t·ªëc ƒë·ªô h·∫°t ƒë·ªÉ √≠t r·ªëi
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;
      this.life = 1.0;
      this.color = color;
      this.size = Math.random() * 3 + 1; // H·∫°t nh·ªè h∆°n
    }
    update() {
      this.x += this.vx; this.y += this.vy;
      this.vx *= 0.92; this.vy *= 0.92; // Ma s√°t cao h∆°n
      this.life -= 0.03;
      this.size *= 0.9;
    }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  class Sparkle {
    constructor(x, y, color) {
      this.x = x + (Math.random() - 0.5) * box;
      this.y = y + (Math.random() - 0.5) * box;
      this.color = color;
      this.life = 1.0;
      this.size = Math.random() * 2 + 1;
      this.blinkRate = Math.random() * 0.1 + 0.05;
    }
    update() { this.life -= this.blinkRate; }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = "#fff";
      ctx.fillRect(this.x, this.y, this.size, this.size); // V·∫Ω vu√¥ng thay v√¨ tr√≤n cho nh·∫π
      ctx.globalAlpha = 1;
    }
  }

  // --- SYSTEM FUNCTIONS ---

  function resizeCanvas() {
    const maxWidth = Math.min(window.innerWidth - 20, 800);
    const maxHeight = Math.min(window.innerHeight - 150, 800);
    const newCols = Math.floor(maxWidth / box);
    const newRows = Math.floor(maxHeight / box);
    canvas.width = newCols * box;
    canvas.height = newRows * box;
    cols = newCols; rows = newRows;
  }
  window.addEventListener('resize', () => { resizeCanvas(); });
  resizeCanvas();

  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = new AudioContext();

  function playTone(freq, type, duration) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
  }

  function sfx(action) {
    if (action === 'eat') { 
      playTone(600, 'sine', 0.1); 
      setTimeout(() => playTone(1200, 'square', 0.2), 50);
    }
    else if (action === 'die') { 
      playTone(150, 'sawtooth', 0.4); 
      setTimeout(() => playTone(100, 'sawtooth', 0.4), 200);
    }
    else if (action === 'move') { playTone(250, 'triangle', 0.05); }
  }

  function triggerFlash(color = 'white') {
    flashOverlay.style.background = color;
    flashOverlay.style.opacity = 0.3; // Gi·∫£m opacity ƒë·ªÉ ƒë·ª° ch√≥i
    setTimeout(() => { flashOverlay.style.opacity = 0; }, 50);
  }

  // --- GAME LOGIC ---

  function initSeq() {
    switch(gameMode) {
      case 'natural': currentVal=1; break;
      case 'even': currentVal=2; break;
      case 'odd': currentVal=1; break;
      case 'arithmetic': currentVal=paramStart; break;
      case 'geometric': currentVal=paramStart; break;
      case 'divisible': currentVal=param1; break;
      case 'prime': currentVal=2; break;
      case 'fibonacci': prevVal=0; currentVal=1; break;
      default: currentVal=1;
    }
    updateTargetUI();
  }

  function nextSeq() {
    function isPrime(n) { if(n<=1)return false; for(let i=2; i<=Math.sqrt(n); i++)if(n%i===0)return false; return true; }
    function nextPrime(n) { let x=n+1; while(!isPrime(x)) x++; return x; }

    switch(gameMode) {
      case 'natural': return currentVal+1;
      case 'even': return currentVal+2;
      case 'odd': return currentVal+2;
      case 'arithmetic': return currentVal+param1;
      case 'geometric': return currentVal*param1;
      case 'divisible': return currentVal+param1;
      case 'prime': return nextPrime(currentVal);
      case 'fibonacci': let next=prevVal+currentVal; prevVal=currentVal; return next;
      default: return currentVal+1;
    }
  }

  function updateTargetUI() {
    document.getElementById("targetBadge").textContent = currentVal;
    if(eatenCount >= 3) targetWrapper.classList.add('hidden-hint');
    else targetWrapper.classList.remove('hidden-hint');
  }

  function getSafePos() {
    let pos, safe=false, att=0;
    while(!safe && att<100) {
      pos = { x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows) };
      safe = !snake.some(s=>s.x===pos.x && s.y===pos.y) && !foods.some(f=>f.pos && f.pos.x===pos.x && f.pos.y===pos.y);
      att++;
    }
    return pos;
  }

  function genFoods() {
    foods = [];
    // Th·ª©c ƒÉn ƒë√∫ng, th√™m spawnTime ƒë·ªÉ l√†m hi·ªáu ·ª©ng pop-in
    foods.push({ val: currentVal, pos: getSafePos(), isCorrect: true, spawnTime: time });
    
    let attempts = 0;
    while(foods.length < 4 && attempts < 100) {
      let fake;
      let range = Math.max(5, Math.floor(currentVal * 0.5));
      let diff = Math.floor(Math.random() * range * 2) - range;
      
      if (gameMode === 'geometric' && Math.random() < 0.3) {
          let wrongMult = (Math.random() > 0.5 ? 2 : 0.5);
          fake = Math.floor(currentVal * wrongMult);
          if (fake === currentVal) fake = currentVal + 1;
      } else {
          fake = currentVal + diff;
      }
      
      if (fake > 0 && fake !== currentVal && !foods.some(f=>f.val===fake)) {
        foods.push({ val: fake, pos: getSafePos(), isCorrect: false, spawnTime: time });
      }
      attempts++;
    }
    while (foods.length < 4) {
       let safeRandom = Math.floor(Math.random() * 100) + currentVal + 10;
       if (!foods.some(f=>f.val===safeRandom)) foods.push({ val: safeRandom, pos: getSafePos(), isCorrect: false, spawnTime: time });
    }
  }

  // --- MAIN LOOP ---
  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    let deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    update(deltaTime);
    draw();

    if (!modal.classList.contains('show')) {
        requestID = requestAnimationFrame(loop);
    }
  }

  function update(dt) {
    time += dt * 0.005; // Th·ªùi gian cho hi·ªáu ·ª©ng th·ªü
    moveTimer += dt;    // Th·ªùi gian t√≠ch l≈©y cho r·∫Øn di chuy·ªÉn

    // 1. Shake Decay
    if (shakeIntensity > 0) shakeIntensity *= 0.9;
    if (shakeIntensity < 0.5) shakeIntensity = 0;

    // 2. Snake Movement (Decoupled from render speed)
    if (moveTimer > currentSpeed) {
        moveTimer = 0; // Reset timer

        if(nextDir) {
          if(nextDir!==dir) sfx('move');
          dir = nextDir;
        }
        
        if(dir !== '') {
            let head = { ...snake[0] };
            if(dir==='LEFT') head.x--;
            if(dir==='RIGHT') head.x++;
            if(dir==='UP') head.y--;
            if(dir==='DOWN') head.y++;

            if(head.x<0 || head.x>=cols || head.y<0 || head.y>=rows || snake.some(s=>s.x===head.x && s.y===head.y)) {
              shakeIntensity = 25; 
              triggerFlash('red');
              gameOver();
              return;
            }

            snake.unshift(head);

            let eatenIdx = foods.findIndex(f => f.pos.x === head.x && f.pos.y === head.y);
            if(eatenIdx !== -1) {
              let food = foods[eatenIdx];
              let centerX = head.x*box + box/2;
              let centerY = head.y*box + box/2;

              if(food.isCorrect) {
                score += 10;
                eatenCount++;
                sfx('eat');
                triggerFlash('#00f0ff');
                
                // TƒÉng t·ªëc ƒë·ªô game
                if (currentSpeed > minSpeed) {
                    currentSpeed -= speedStep;
                }

                // Effects
                shakeIntensity = 8; 
                shockwaves.push(new Shockwave(centerX, centerY, '#00f0ff'));
                for(let i=0; i<15; i++) particles.push(new Particle(centerX, centerY, '#00f0ff')); // √çt h·∫°t h∆°n
                floatingTexts.push(new FloatingText(centerX, centerY - 20, "+10", "#00f0ff"));

                currentVal = nextSeq();
                updateTargetUI();
                genFoods();
              } else {
                shakeIntensity = 20; 
                triggerFlash('#ff0055');
                shockwaves.push(new Shockwave(centerX, centerY, '#ff0055'));
                for(let i=0; i<20; i++) particles.push(new Particle(centerX, centerY, '#ff0055'));
                gameOver();
                return;
              }
            } else {
              snake.pop();
            }
        }
    }
    
    // Spawn random sparkles (Gi·∫£m t·∫ßn su·∫•t)
    if (Math.random() > 0.85) {
        let f = foods[Math.floor(Math.random() * foods.length)];
        if (f) {
           let fx = f.pos.x * box + box/2;
           let fy = f.pos.y * box + box/2;
           let color = f.isCorrect ? '#00f0ff' : '#fff';
           sparkles.push(new Sparkle(fx, fy, color));
        }
    }

    document.getElementById("score").textContent = score;
  }

  function draw() {
    // --- CANVAS SETUP ---
    ctx.fillStyle = "#020205";
    ctx.fillRect(0, 0, canvas.width, canvas.height); 

    // --- GRID PULSE EFFECT (New) ---
    // V·∫Ω l∆∞·ªõi v·ªõi opacity thay ƒë·ªïi theo nh·ªãp th·ªü ƒë·ªÉ t·∫°o c·∫£m gi√°c s·ªëng ƒë·ªông nh∆∞ng kh√¥ng t·ªën k√©m
    let gridPulse = 0.05 + Math.sin(time) * 0.02;
    ctx.strokeStyle = `rgba(0, 240, 255, ${gridPulse})`;
    ctx.lineWidth = 1;
    for (let i = 0; i < cols; i++) { ctx.beginPath(); ctx.moveTo(i * box, 0); ctx.lineTo(i * box, canvas.height); ctx.stroke(); }
    for (let j = 0; j < rows; j++) { ctx.beginPath(); ctx.moveTo(0, j * box); ctx.lineTo(canvas.width, j * box); ctx.stroke(); }

    ctx.save();
    // Apply Shake
    if (shakeIntensity > 0) {
        let dx = (Math.random() - 0.5) * shakeIntensity;
        let dy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(dx, dy);
    }

    // --- DRAW EFFECTS ---
    // T·ªëi ∆∞u: Kh√¥ng d√πng shadowBlur cho particles
    for(let i=shockwaves.length-1; i>=0; i--) {
      shockwaves[i].update();
      shockwaves[i].draw(ctx);
      if(shockwaves[i].life <= 0) shockwaves.splice(i, 1);
    }
    for(let i=particles.length-1; i>=0; i--) {
      particles[i].update();
      particles[i].draw(ctx);
      if(particles[i].life <= 0) particles.splice(i, 1);
    }
    for(let i=sparkles.length-1; i>=0; i--) {
      sparkles[i].update();
      sparkles[i].draw(ctx);
      if(sparkles[i].life <= 0) sparkles.splice(i, 1);
    }

    // --- DRAW FOOD ---
    let breathScale = 1 + Math.sin(time * 3) * 0.05; // Nh·ªãp th·ªü nhanh h∆°n cho th·ª©c ƒÉn

    foods.forEach(f => {
      // Pop-in effect
      let age = time - f.spawnTime;
      let spawnScale = Math.min(1, age * 2); 

      let cx = f.pos.x * box + box/2;
      let cy = f.pos.y * box + box/2;
      let baseRadius = box/2 - 2;
      let radius = baseRadius * breathScale * spawnScale;
      
      if (radius <= 0) return;

      // Backdrop
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)"; 
      ctx.fill();
      
      // Vi·ªÅn (Fake Glow b·∫±ng c√°ch v·∫Ω vi·ªÅn m·ªù r·ªông h∆°n)
      ctx.beginPath();
      ctx.arc(cx, cy, radius + 2, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0, 240, 255, 0.3)';
      ctx.lineWidth = 4;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI*2);
      ctx.strokeStyle = '#00f0ff';
      ctx.lineWidth = 2;
      ctx.stroke();

      // S·ªë
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 4;
      let fontSize = f.val > 999 ? 14 : 18;
      ctx.font = `900 ${fontSize}px 'Rajdhani'`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.strokeText(f.val, cx, cy); 
      ctx.fillText(f.val, cx, cy);   
    });

    // --- DRAW SNAKE ---
    if (snake.length > 0) {
        let snakeWidth = (box - 12);
        let headX = snake[0].x * box + box/2;
        let headY = snake[0].y * box + box/2;
        
        let snakeGrad = ctx.createLinearGradient(headX, headY, snake[snake.length-1].x * box + box/2, snake[snake.length-1].y * box + box/2);
        snakeGrad.addColorStop(0, '#00f0ff'); 
        snakeGrad.addColorStop(1, '#0051ff'); 

        // V·∫Ω th√¢n
        ctx.beginPath();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = snakeWidth;
        ctx.strokeStyle = snakeGrad;
        
        ctx.moveTo(headX, headY);
        for (let i = 1; i < snake.length; i++) {
            ctx.lineTo(snake[i].x * box + box/2, snake[i].y * box + box/2);
        }
        
        // Fake Glow cho th√¢n (R·∫ª h∆°n shadowBlur)
        ctx.stroke();
        
        // V·∫Ω l·∫°i l·∫ßn n·ªØa v·ªõi opacity th·∫•p v√† width l·ªõn ƒë·ªÉ l√†m glow
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = snakeWidth + 10;
        ctx.strokeStyle = '#00f0ff';
        ctx.stroke();
        ctx.restore();

        // V·∫Ω ƒê·∫ßu R·∫Øn
        ctx.beginPath();
        ctx.arc(headX, headY, box/2 - 4, 0, Math.PI*2);
        ctx.fillStyle = "#fff";
        ctx.fill();
    }

    // --- DRAW FLOATING TEXT ---
    for(let i=floatingTexts.length-1; i>=0; i--) {
      floatingTexts[i].update();
      floatingTexts[i].draw(ctx);
      if(floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }

    ctx.restore();
  }

  // --- CONTROLLERS ---

  function updateFormInputs() {
    const mode = document.getElementById('modeSelect').value;
    const u1Cont = document.getElementById('u1Container');
    const pCont = document.getElementById('paramContainer');
    const pLabel = document.getElementById('paramLabel');
    const pInput = document.getElementById('paramInput');
    const sInput = document.getElementById('startInput');

    customParams.classList.add('hidden');
    u1Cont.classList.add('hidden');
    pCont.classList.add('hidden');

    if (mode === 'arithmetic') {
      customParams.classList.remove('hidden'); u1Cont.classList.remove('hidden'); pCont.classList.remove('hidden');
      pLabel.textContent = "C√¥ng Sai (d)"; pInput.value = 5; sInput.value = 0;
    } else if (mode === 'geometric') {
      customParams.classList.remove('hidden'); u1Cont.classList.remove('hidden'); pCont.classList.remove('hidden');
      pLabel.textContent = "C√¥ng B·ªôi (q)"; pInput.value = 2; sInput.value = 1;
    } else if (mode === 'divisible') {
      customParams.classList.remove('hidden'); pCont.classList.remove('hidden');
      pLabel.textContent = "S·ªë Chia (N)"; pInput.value = 3;
    }
  }

  function initGame() {
    gameMode = document.getElementById('modeSelect').value;
    param1 = parseInt(document.getElementById('paramInput').value);
    paramStart = parseInt(document.getElementById('startInput').value);
    if (isNaN(param1)) param1 = 2; if (isNaN(paramStart)) paramStart = 1;

    startScreen.style.opacity = 0;
    setTimeout(() => {
      startScreen.classList.add('hidden');
      gameUI.style.display = 'flex';
      resizeCanvas(); 
      restartGame();
    }, 400);
  }

  function backToMenu() {
    modal.classList.remove('show');
    gameUI.style.display = 'none';
    startScreen.classList.remove('hidden');
    startScreen.style.opacity = 1;
    cancelAnimationFrame(requestID); // D·ª´ng render loop
  }

  function restartGame() {
    let startX = Math.floor(cols/2);
    let startY = Math.floor(rows/2);
    snake = [{x:startX, y:startY}, {x:startX-1, y:startY}, {x:startX-2, y:startY}];
    dir = ''; nextDir = '';
    score = 0; eatenCount = 0; time = 0; moveTimer = 0;
    currentSpeed = 220; // Reset t·ªëc ƒë·ªô
    foods = []; particles = []; shockwaves = []; floatingTexts = []; sparkles = []; shakeIntensity = 0;
    
    modal.classList.remove('show');
    targetWrapper.classList.remove('hidden-hint');
    initSeq(); genFoods();

    if (requestID) cancelAnimationFrame(requestID);
    lastTime = 0;
    loop(0); // B·∫Øt ƒë·∫ßu render loop
  }

  function gameOver() {
    sfx('die');
    if(score > highscore) {
      highscore = score;
      localStorage.setItem('highscore_quantum', highscore);
    }
    document.getElementById('finalScore').textContent = score;
    document.getElementById('missedTarget').textContent = currentVal;
    modal.classList.add('show');
    // Kh√¥ng d·ª´ng loop ƒë·ªÉ h·∫°t v·∫´n bay, ch·ªâ d·ª´ng logic update r·∫Øn
  }

  document.addEventListener('keydown', e => {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    if(e.key==='ArrowUp' && dir!=='DOWN') nextDir='UP';
    if(e.key==='ArrowDown' && dir!=='UP') nextDir='DOWN';
    if(e.key==='ArrowLeft' && dir!=='RIGHT') nextDir='LEFT';
    if(e.key==='ArrowRight' && dir!=='LEFT') nextDir='RIGHT';
  });

  let tsX=0, tsY=0;
  canvas.addEventListener('touchstart', e => { tsX=e.touches[0].clientX; tsY=e.touches[0].clientY; }, {passive:false});
  canvas.addEventListener('touchend', e => {
    let dx = e.changedTouches[0].clientX - tsX;
    let dy = e.changedTouches[0].clientY - tsY;
    if (Math.abs(dx) > 10 || Math.abs(dy) > 10) { 
        if(Math.abs(dx) > Math.abs(dy)) {
          if(dx>0 && dir!=='LEFT') nextDir='RIGHT'; else if(dx<0 && dir!=='RIGHT') nextDir='LEFT';
        } else {
          if(dy>0 && dir!=='UP') nextDir='DOWN'; else if(dy<0 && dir!=='DOWN') nextDir='UP';
        }
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }
  }, {passive:false});

  updateFormInputs();
</script>
</body>
</html>
