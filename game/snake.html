<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>üåå QUANTUM SNAKE: SUPERCHARGED</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@500;700;900&family=Orbitron:wght@900&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --q-cyan: #00f0ff;
      --q-pink: #ff0055;
      --q-void: #050508;
      --q-panel-bg: rgba(10, 15, 25, 0.95);
      --q-border: rgba(0, 240, 255, 0.5);
    }
    
    * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

    body {
      background-color: var(--q-void);
      margin: 0; padding: 0;
      height: 100vh; width: 100vw;
      overflow: hidden;
      color: #fff;
      display: flex; justify-content: center; align-items: center;
      font-family: 'Exo 2', sans-serif;
    }

    #main-wrapper {
      position: relative; width: 100%; height: 100%;
      display: flex; flex-direction: column; 
      justify-content: center; align-items: center;
      z-index: 10;
    }

    /* --- ANIMATIONS --- */
    @keyframes zoomIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
    @keyframes zoomOut { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(1.2); } }
    
    .anim-enter { animation: zoomIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    .anim-exit { animation: zoomOut 0.3s ease-in forwards; }

    /* --- UI ELEMENTS --- */
    .glass-panel {
      background: var(--q-panel-bg);
      border: 2px solid var(--q-border);
      box-shadow: 0 0 40px rgba(0, 240, 255, 0.15), inset 0 0 50px rgba(0,0,0,0.8);
      border-radius: 24px;
      padding: 30px;
      max-width: 480px; width: 90%;
      position: absolute; /* Changed to absolute for stacking transitions */
      transition: opacity 0.4s, transform 0.4s;
      z-index: 100;
      display: flex; flex-direction: column; gap: 20px;
    }

    h1 {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      font-weight: 900; font-size: 2.5rem;
      background: linear-gradient(to bottom, #fff, var(--q-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase; letter-spacing: 2px;
      text-align: center;
      filter: drop-shadow(0 0 5px rgba(0, 240, 255, 0.8));
      line-height: 1.2;
    }

    .subtitle {
      color: #ccc; font-size: 1rem;
      text-align: center; text-transform: uppercase; letter-spacing: 3px;
      font-weight: 700; margin-top: -10px; opacity: 0.8;
    }

    .control-group {
      background: rgba(255,255,255,0.03);
      border-radius: 12px; padding: 15px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    .control-label {
      font-size: 0.85rem; color: var(--q-cyan); 
      text-transform: uppercase; font-weight: 700; letter-spacing: 1px;
      margin-bottom: 8px; display: block;
    }

    select, input {
      width: 100%; padding: 14px;
      background: #000; border: 1px solid #333; border-radius: 8px;
      color: #fff; font-family: 'Orbitron', sans-serif; font-size: 1.1rem; font-weight: 700;
      outline: none; transition: 0.3s; appearance: none;
    }
    
    select {
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2300f0ff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 15px top 50%;
      background-size: 12px auto;
    }

    select:focus, input:focus { border-color: var(--q-cyan); box-shadow: 0 0 15px rgba(0, 240, 255, 0.3); }

    #dynamicParams { display: flex; gap: 15px; animation: fadeIn 0.3s ease-out; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
    .param-box { flex: 1; }

    .btn-start {
      width: 100%; padding: 18px;
      background: linear-gradient(90deg, var(--q-cyan), #0051ff);
      border: none; border-radius: 12px;
      color: #fff; font-weight: 900; font-size: 1.3rem;
      text-transform: uppercase; letter-spacing: 2px;
      cursor: pointer; position: relative; overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      transition: 0.3s;
      box-shadow: 0 5px 20px rgba(0, 240, 255, 0.3);
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .btn-start:hover { transform: translateY(-2px); box-shadow: 0 10px 40px rgba(0, 240, 255, 0.5); filter: brightness(1.1); }

    /* --- GAME UI --- */
    #gameUI { 
      display: none; flex-direction: column; align-items: center; 
      width: 100%; height: 100%; justify-content: center; z-index: 20; 
      opacity: 0; /* Start hidden for animation */
    }

    .hud-bar {
      display: flex; width: 100%; max-width: 800px;
      justify-content: space-between; align-items: center;
      margin-bottom: 15px; padding: 0 15px;
    }

    .hud-item { display: flex; flex-direction: column; }
    .hud-label { font-size: 0.75rem; color: #889; font-weight: 700; letter-spacing: 1px; }
    .hud-value { font-family: 'Orbitron', sans-serif; font-size: 1.8rem; color: #fff; text-shadow: 0 0 10px var(--q-cyan); font-weight: bold;}
    
    .hud-center {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--q-cyan);
      padding: 8px 30px; border-radius: 30px;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.15);
      text-align: center;
      transition: opacity 0.3s;
    }
    .hud-center.hidden-hint { opacity: 0; }

    .canvas-container {
      position: relative; border-radius: 16px;
      filter: drop-shadow(0 0 25px rgba(0, 240, 255, 0.1)); 
      background: #000; box-shadow: 0 0 0 1px rgba(255,255,255,0.15);
    }
    canvas { display: block; border-radius: 16px; }

    /* CONTROLS */
    .controls {
      position: absolute; top: 15px; right: 15px;
      display: flex; gap: 10px; z-index: 50;
    }
    .btn-icon {
      width: 44px; height: 44px;
      background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px; color: #fff;
      display: flex; justify-content: center; align-items: center;
      cursor: pointer; transition: 0.2s;
    }
    .btn-icon:hover { background: var(--q-cyan); color:#000; border-color:var(--q-cyan); }
    .btn-icon svg { width: 22px; height: 22px; fill: currentColor; }

    /* UTILS & MODALS */
    .hidden { display: none !important; }
    .txt-accent { color: var(--q-pink); text-shadow: 0 0 15px var(--q-pink); }
    
    #pauseModal, #gameOverModal {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.9); backdrop-filter: blur(8px);
      display: flex; justify-content: center; align-items: center;
      z-index: 50; opacity: 0; pointer-events: none; transition: 0.3s;
    }
    .show { opacity: 1 !important; pointer-events: auto !important; }

    #flashOverlay {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: #fff; pointer-events: none; opacity: 0;
      z-index: 40; transition: opacity 0.1s; mix-blend-mode: overlay;
    }
  </style>
</head>
<body>

  <div id="flashOverlay"></div>

  <!-- CONTROL BUTTONS -->
  <div class="controls">
    <div class="btn-icon" onclick="toggleMute()" id="btnMute" title="B·∫≠t/T·∫Øt √Çm Thanh">
      <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
    </div>
    <div class="btn-icon" onclick="togglePause()" id="btnPause" style="display:none" title="T·∫°m D·ª´ng">
      <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
    </div>
  </div>

  <div id="main-wrapper">

    <!-- START SCREEN (MENU) -->
    <div id="startScreen" class="glass-panel anim-enter">
      <div>
        <h1>QUANTUM<br>FLUX</h1>
        <div class="subtitle">TO√ÅN H·ªåC SI√äU T·ªêC</div>
      </div>
      
      <!-- Ch·∫ø ƒë·ªô ch∆°i -->
      <div class="control-group">
        <label class="control-label">CH·∫æ ƒê·ªò CH∆†I</label>
        <select id="modeSelect" onchange="updateFormInputs()">
          <option value="geometric" selected>‚úñ C·∫•p S·ªë Nh√¢n</option>
          <option value="arithmetic">‚úö C·∫•p S·ªë C·ªông</option>
          <option value="natural">123 S·ªë T·ª± Nhi√™n</option>
          <option value="even">246 S·ªë Ch·∫µn</option>
          <option value="odd">135 S·ªë L·∫ª</option>
          <option value="prime">‚òÖ S·ªë Nguy√™n T·ªë</option>
          <option value="fibonacci">üåÄ Fibonacci</option>
          <option value="divisible">‚ûó B·ªôi S·ªë C·ªßa N</option>
        </select>
      </div>

      <!-- Tham s·ªë t√πy ch·ªânh (Hi·ªán ra khi c·∫ßn) -->
      <div id="dynamicParams" class="hidden">
        <div class="param-box" id="u1Container">
          <div class="control-group">
            <label class="control-label">S·ªê ƒê·∫¶U (u‚ÇÅ)</label>
            <input type="number" id="startInput" value="1" min="0" max="100">
          </div>
        </div>
        <div class="param-box" id="paramContainer">
          <div class="control-group">
            <label class="control-label" id="paramLabel">C√îNG B·ªòI (q)</label>
            <input type="number" id="paramInput" value="2" min="1" max="20">
          </div>
        </div>
      </div>

      <button class="btn-start" onclick="initGame()">B·∫ÆT ƒê·∫¶U NGAY</button>
    </div>

    <!-- GAME UI -->
    <div id="gameUI">
      <div class="hud-bar">
        <div class="hud-item">
          <span class="hud-label">ƒêI·ªÇM</span>
          <span class="hud-value" id="score">0</span>
        </div>
        
        <div class="hud-center" id="targetWrapper">
          <div class="hud-label" style="color:var(--q-cyan)">C·∫¶N T√åM</div>
          <div class="hud-value" id="targetBadge" style="font-size: 2.2rem;">?</div>
        </div>

        <div class="hud-item" style="align-items: flex-end;">
          <span class="hud-label">COMBO</span>
          <span class="hud-value txt-accent" id="combo">x1</span>
        </div>
      </div>
      
      <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
      </div>
      
      <div style="margin-top:20px; font-size:0.9rem; color:#678; font-weight:600; text-transform:uppercase; letter-spacing:1px">
        ƒêi·ªÅu khi·ªÉn: Vu·ªët ho·∫∑c d√πng ph√≠m m≈©i t√™n
      </div>
    </div>

    <!-- PAUSE MODAL -->
    <div id="pauseModal">
      <div class="glass-panel" style="text-align: center; width: 320px; align-items: center;">
        <h2 style="color: #fff; font-family:'Orbitron'; margin-bottom: 20px;">T·∫†M D·ª™NG</h2>
        <button class="btn-start" onclick="togglePause()">TI·∫æP T·ª§C</button>
        <button class="btn-start" style="background:transparent; border:1px solid #556; margin-top:10px" onclick="backToMenu()">THO√ÅT RA MENU</button>
      </div>
    </div>

    <!-- GAME OVER MODAL -->
    <div id="gameOverModal">
      <div class="glass-panel" style="text-align: center; border-color: var(--q-pink); align-items: center;">
        <h2 style="color: var(--q-pink); margin-bottom: 5px; font-family:'Orbitron'; font-size: 2.2rem;">GAME OVER</h2>
        <div style="font-size: 4rem; font-family:'Orbitron'; font-weight:900; color:#fff; text-shadow: 0 0 30px var(--q-pink);" id="finalScore">0</div>
        
        <div style="background: rgba(255,255,255,0.1); padding: 10px 20px; border-radius: 8px; margin-bottom: 20px; width: 100%;">
            <div style="color:#aaa; font-size: 0.9rem; margin-bottom:5px;">B·∫†N C·∫¶N T√åM S·ªê</div>
            <strong id="missedTarget" style="color:#fff; font-size:1.8rem; font-family:'Orbitron'"></strong>
        </div>
        
        <div style="display:flex; gap:15px; width:100%">
          <button class="btn-start" style="background: transparent; border: 1px solid #556;" onclick="backToMenu()">MENU</button>
          <button class="btn-start" style="background: linear-gradient(135deg, var(--q-pink), #990033);" onclick="restartGame()">CH∆†I L·∫†I</button>
        </div>
      </div>
    </div>

  </div>

<script>
  // --- CORE SYSTEM ---
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const box = 40; 
  let rows, cols;
  
  // Elements
  const startScreen = document.getElementById('startScreen');
  const gameUI = document.getElementById('gameUI');
  const modalGO = document.getElementById('gameOverModal');
  const modalPause = document.getElementById('pauseModal');
  const targetWrapper = document.getElementById('targetWrapper');
  const dynamicParams = document.getElementById('dynamicParams');
  const flashOverlay = document.getElementById('flashOverlay');
  const btnPause = document.getElementById('btnPause');

  // Game State
  let requestID;
  let isPaused = false;
  let isMuted = false;
  
  let snake = [];
  let dir = '', nextDir = '';
  let score = 0;
  let combo = 1;
  let foods = [];
  let eatenCount = 0;
  
  // Timing & Interpolation
  let lastTime = 0;
  let moveTimer = 0;
  let currentSpeed = 200; 
  let moveProgress = 0;
  
  // Visual Effects
  let particles = [];
  let floatingTexts = [];
  let stars = [];
  let sparkles = []; // Sparkle particles for food
  let shakeIntensity = 0;
  let globalTime = 0;

  // Math Logic
  let gameMode = 'geometric', param1 = 2, paramStart = 1, currentVal = 1, prevVal = 0;

  // --- CLASSES ---

  class Star {
    constructor() { this.reset(); this.y = Math.random() * canvas.height; }
    reset() {
      this.x = Math.random() * canvas.width;
      this.y = -10;
      this.z = Math.random() * 2 + 0.5;
      this.size = Math.random() * 1.5;
      this.opacity = Math.random() * 0.5 + 0.1;
    }
    update(dt) {
      this.y += this.z * (dt * 0.05);
      if (this.y > canvas.height) this.reset();
    }
    draw(ctx) {
      ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
    }
  }

  class Particle {
    constructor(x, y, color) {
      this.x = x; this.y = y;
      let angle = Math.random() * Math.PI * 2;
      let speed = Math.random() * 5 + 2;
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;
      this.life = 1.0;
      this.color = color;
      this.size = Math.random() * 3 + 1;
    }
    update() {
      this.x += this.vx; this.y += this.vy;
      this.vx *= 0.94; this.vy *= 0.94;
      this.life -= 0.03;
    }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = this.color;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // H·∫°t l·∫•p l√°nh cho th·ª©c ƒÉn
  class Sparkle {
    constructor(x, y, color) {
      this.x = x + (Math.random() - 0.5) * box;
      this.y = y + (Math.random() - 0.5) * box;
      this.color = color;
      this.life = 1.0;
      this.size = Math.random() * 2 + 1;
      this.blinkRate = Math.random() * 0.1 + 0.05;
    }
    update() { this.life -= this.blinkRate; }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = "#fff";
      ctx.shadowBlur = 5; ctx.shadowColor = this.color;
      // Draw cross shape
      ctx.fillRect(this.x - this.size, this.y, this.size * 2, 1);
      ctx.fillRect(this.x, this.y - this.size, 1, this.size * 2);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
  }

  class FloatingText {
    constructor(x, y, text, color) {
      this.x = x; this.y = y;
      this.text = text; this.color = color;
      this.life = 1.0;
      this.yOffset = 0;
    }
    update() { this.yOffset -= 1.5; this.life -= 0.02; }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = this.color;
      ctx.font = "900 20px 'Orbitron'";
      ctx.textAlign = "center";
      ctx.fillText(this.text, this.x, this.y + this.yOffset);
      ctx.globalAlpha = 1;
    }
  }

  // --- SYSTEM ---

  function resizeCanvas() {
    const maxWidth = Math.min(window.innerWidth - 20, 800);
    const maxHeight = Math.min(window.innerHeight - 150, 800);
    const newCols = Math.floor(maxWidth / box);
    const newRows = Math.floor(maxHeight / box);
    canvas.width = newCols * box;
    canvas.height = newRows * box;
    cols = newCols; rows = newRows;
    stars = [];
    for(let i=0; i<50; i++) stars.push(new Star());
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = new AudioContext();

  function playTone(freq, type, duration) {
    if (isMuted || audioCtx.state === 'suspended') {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        if(isMuted) return;
    }
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
  }

  function toggleMute() { isMuted = !isMuted; document.getElementById('btnMute').style.opacity = isMuted ? 0.5 : 1; }

  function togglePause() {
    if (gameUI.style.display === 'none') return;
    isPaused = !isPaused;
    if (isPaused) {
      modalPause.classList.add('show');
      modalPause.classList.add('anim-enter');
    } else {
      modalPause.classList.remove('show');
      modalPause.classList.remove('anim-enter');
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }
  }

  function triggerFlash(color = 'white') {
    flashOverlay.style.background = color;
    flashOverlay.style.opacity = 0.2;
    setTimeout(() => { flashOverlay.style.opacity = 0; }, 50);
  }

  // --- MENU LOGIC (UPDATED) ---
  
  function updateFormInputs() {
    const mode = document.getElementById('modeSelect').value;
    const u1 = document.getElementById('u1Container');
    const p1 = document.getElementById('paramContainer');
    const l1 = document.getElementById('paramLabel');
    const i1 = document.getElementById('paramInput');
    const s1 = document.getElementById('startInput');
    
    // M·∫∑c ƒë·ªãnh ·∫©n container params
    dynamicParams.classList.add('hidden');
    u1.classList.add('hidden'); 
    p1.classList.add('hidden');
    
    // Logic hi·ªÉn th·ªã
    if(mode==='arithmetic') { 
        dynamicParams.classList.remove('hidden'); 
        u1.classList.remove('hidden'); 
        p1.classList.remove('hidden'); 
        l1.textContent="C√¥ng Sai (d)"; i1.value=5; s1.value=0; 
    }
    else if(mode==='geometric') { 
        dynamicParams.classList.remove('hidden'); 
        u1.classList.remove('hidden'); 
        p1.classList.remove('hidden'); 
        l1.textContent="C√¥ng B·ªôi (q)"; i1.value=2; s1.value=1; 
    }
    else if(mode==='divisible') { 
        dynamicParams.classList.remove('hidden'); 
        p1.classList.remove('hidden'); 
        l1.textContent="S·ªë Chia (N)"; i1.value=3; 
    }
  }

  // --- GAME LOGIC ---

  function initSeq() {
    switch(gameMode) {
      case 'natural': currentVal=1; break;
      case 'geometric': currentVal=paramStart; break;
      case 'arithmetic': currentVal=paramStart; break;
      case 'fibonacci': prevVal=0; currentVal=1; break;
      case 'prime': currentVal=2; break;
      default: currentVal = (gameMode==='divisible'?param1: (gameMode==='even'?2:1));
    }
    if(gameMode==='divisible') currentVal = param1;
    updateTargetUI();
  }

  function nextSeq() {
    function isPrime(n) { if(n<=1)return false; for(let i=2; i<=Math.sqrt(n); i++)if(n%i===0)return false; return true; }
    function nextPrime(n) { let x=n+1; while(!isPrime(x)) x++; return x; }

    switch(gameMode) {
      case 'geometric': return currentVal*param1;
      case 'arithmetic': return currentVal+param1;
      case 'natural': return currentVal+1;
      case 'even': return currentVal+2;
      case 'odd': return currentVal+2;
      case 'prime': return nextPrime(currentVal);
      case 'fibonacci': let next=prevVal+currentVal; prevVal=currentVal; return next;
      case 'divisible': return currentVal+param1;
    }
    return currentVal+1;
  }

  function updateTargetUI() {
    document.getElementById("targetBadge").textContent = currentVal;
    if(eatenCount >= 3) targetWrapper.classList.add('hidden-hint');
    else targetWrapper.classList.remove('hidden-hint');
  }

  function getSafePos() {
    let pos, safe=false, att=0;
    while(!safe && att<100) {
      pos = { x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows) };
      safe = !snake.some(s=>s.x===pos.x && s.y===pos.y) && !foods.some(f=>f.pos && f.pos.x===pos.x && f.pos.y===pos.y);
      att++;
    }
    return pos;
  }

  function genFoods() {
    foods = [];
    // Random color for correct food
    let hue = Math.random() * 360;
    let color = `hsl(${hue}, 100%, 60%)`;
    foods.push({ val: currentVal, pos: getSafePos(), isCorrect: true, spawnTime: globalTime, color: color });
    
    let attempts = 0;
    while(foods.length < 4 && attempts < 100) {
      let fake;
      let range = Math.max(5, Math.floor(currentVal * 0.5));
      let diff = Math.floor(Math.random() * range * 2) - range;
      fake = currentVal + diff;
      
      // Random distinct color for fake food
      let fakeHue = (hue + 60 + Math.random() * 240) % 360; // Offset hue to ensure different colors
      let fakeColor = `hsl(${fakeHue}, 100%, 60%)`;

      if (fake > 0 && fake !== currentVal && !foods.some(f=>f.val===fake)) {
        foods.push({ val: fake, pos: getSafePos(), isCorrect: false, spawnTime: globalTime, color: fakeColor });
      }
      attempts++;
    }
    while (foods.length < 4) {
       let r = Math.floor(Math.random() * 50) + currentVal + 1;
       let rHue = Math.random() * 360;
       let rColor = `hsl(${rHue}, 100%, 60%)`;
       if (!foods.some(f=>f.val===r)) foods.push({ val: r, pos: getSafePos(), isCorrect: false, spawnTime: globalTime, color: rColor });
    }
  }

  function gameOver() {
    playTone(100, 'sawtooth', 0.5);
    document.getElementById('finalScore').textContent = score;
    document.getElementById('missedTarget').textContent = currentVal;
    
    modalGO.classList.add('show');
    modalGO.classList.add('anim-enter');
    isPaused = true;
  }

  // --- LOOP ---

  function loop(timestamp) {
    if (isPaused) return;

    let dt = timestamp - lastTime;
    lastTime = timestamp;
    if (dt > 100) dt = 100;

    globalTime += dt * 0.001;
    moveTimer += dt;
    
    if (moveTimer >= currentSpeed) {
      moveTimer = 0;
      
      if (nextDir) dir = nextDir;
      if (dir) {
        let head = { ...snake[0] };
        if(dir==='LEFT') head.x--;
        if(dir==='RIGHT') head.x++;
        if(dir==='UP') head.y--;
        if(dir==='DOWN') head.y++;

        if(head.x<0 || head.x>=cols || head.y<0 || head.y>=rows || snake.some(s=>s.x===head.x && s.y===head.y)) {
          shakeIntensity = 20; triggerFlash('red'); gameOver(); return;
        }

        snake.unshift(head);

        let eatenIdx = foods.findIndex(f => f.pos.x === head.x && f.pos.y === head.y);
        if(eatenIdx !== -1) {
          let f = foods[eatenIdx];
          let cx = head.x*box+box/2, cy = head.y*box+box/2;
          if(f.isCorrect) {
            score += 10 * combo;
            combo = Math.min(5, combo + 1);
            eatenCount++;
            triggerFlash(f.color);
            playTone(600 + (combo*100), 'sine', 0.1);
            
            shakeIntensity = 5;
            for(let i=0; i<10; i++) particles.push(new Particle(cx, cy, f.color));
            floatingTexts.push(new FloatingText(cx, cy - 20, `+${10*combo}`, f.color));
            if(combo > 1) floatingTexts.push(new FloatingText(cx, cy - 40, `COMBO x${combo}!`, '#ff0055'));

            currentSpeed = Math.max(80, currentSpeed - 2);
            currentVal = nextSeq();
            updateTargetUI();
            genFoods();
          } else {
            shakeIntensity = 15;
            triggerFlash('#ff0055');
            for(let i=0; i<15; i++) particles.push(new Particle(cx, cy, '#ff0055'));
            gameOver(); return;
          }
        } else {
          snake.pop();
        }
      }
    }
    
    // Random sparkles around food
    if (Math.random() > 0.8) {
      let f = foods[Math.floor(Math.random() * foods.length)];
      if(f) sparkles.push(new Sparkle(f.pos.x * box + box/2, f.pos.y * box + box/2, f.color));
    }

    draw(dt);
    requestID = requestAnimationFrame(loop);
  }

  function draw(dt) {
    ctx.fillStyle = "#050508";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    if(shakeIntensity > 0) {
      let dx = (Math.random()-0.5)*shakeIntensity;
      let dy = (Math.random()-0.5)*shakeIntensity;
      ctx.translate(dx, dy);
      shakeIntensity *= 0.9;
      if(shakeIntensity<0.5) shakeIntensity=0;
    }

    stars.forEach(s => { s.update(dt); s.draw(ctx); });

    ctx.strokeStyle = "rgba(0, 240, 255, 0.03)";
    ctx.lineWidth = 1;
    for(let i=0; i<=cols; i++) { ctx.beginPath(); ctx.moveTo(i*box,0); ctx.lineTo(i*box,canvas.height); ctx.stroke(); }
    for(let i=0; i<=rows; i++) { ctx.beginPath(); ctx.moveTo(0,i*box); ctx.lineTo(canvas.width,i*box); ctx.stroke(); }

    ctx.globalCompositeOperation = 'lighter';
    for(let i=particles.length-1; i>=0; i--) {
      particles[i].update();
      particles[i].draw(ctx);
      if(particles[i].life<=0) particles.splice(i,1);
    }
    for(let i=sparkles.length-1; i>=0; i--) {
      sparkles[i].update();
      sparkles[i].draw(ctx);
      if(sparkles[i].life<=0) sparkles.splice(i,1);
    }
    ctx.globalCompositeOperation = 'source-over';

    let pulse = 1 + Math.sin(globalTime * 3) * 0.05;
    
    // Draw Foods with unique colors
    foods.forEach(f => {
      let cx = f.pos.x * box + box/2;
      let cy = f.pos.y * box + box/2;
      let r = (box/2 - 4) * pulse;

      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fill();
      
      // Colored Glow Border
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.strokeStyle = f.color;
      ctx.lineWidth = 2; 
      ctx.shadowBlur = 10; ctx.shadowColor = f.color;
      ctx.stroke();
      ctx.shadowBlur = 0;

      ctx.fillStyle = "#fff"; 
      ctx.font = "700 16px 'Orbitron'";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(f.val, cx, cy);
    });

    // Draw Morphing Snake
    if(snake.length > 0) {
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      
      // R·∫Øn b√©o l√™n khi ƒÉn nhi·ªÅu (Max +10px)
      let fatness = Math.min(10, eatenCount / 2);
      ctx.lineWidth = (box - 12) + fatness;
      
      let headPos = snake[0]; 
      let tailPos = snake[snake.length-1];
      
      // Super Saiyan Mode (Rainbow) when Combo >= 3
      let snakeGrad;
      if (combo >= 3) {
          snakeGrad = ctx.createLinearGradient(headPos.x*box, headPos.y*box, tailPos.x*box, tailPos.y*box);
          let hue = (globalTime * 200) % 360;
          snakeGrad.addColorStop(0, `hsl(${hue}, 100%, 60%)`);
          snakeGrad.addColorStop(1, `hsl(${(hue + 180)%360}, 100%, 50%)`);
          // Stronger glow
          ctx.shadowBlur = 20; ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
      } else {
          // Normal Mode
          snakeGrad = ctx.createLinearGradient(headPos.x*box, headPos.y*box, tailPos.x*box, tailPos.y*box);
          snakeGrad.addColorStop(0, '#00f0ff');
          snakeGrad.addColorStop(1, '#0051ff');
          ctx.shadowBlur = 0;
      }
      
      ctx.beginPath();
      ctx.strokeStyle = snakeGrad;
      ctx.moveTo(headPos.x*box+box/2, headPos.y*box+box/2);
      for(let i=1; i<snake.length; i++) { ctx.lineTo(snake[i].x*box+box/2, snake[i].y*box+box/2); }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Head
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(headPos.x*box+box/2, headPos.y*box+box/2, (box/3) + (fatness/4), 0, Math.PI*2); ctx.fill();
    }

    floatingTexts.forEach((t, i) => {
      t.update(); t.draw(ctx);
      if(t.life<=0) floatingTexts.splice(i,1);
    });

    ctx.restore();

    document.getElementById('score').textContent = score;
    document.getElementById('combo').textContent = 'x' + combo;
    document.getElementById('combo').style.opacity = combo > 1 ? 1 : 0.3;
  }

  // --- INIT ---

  function initGame() {
    startScreen.classList.add('anim-exit');
    setTimeout(() => {
      startScreen.classList.add('hidden');
      startScreen.classList.remove('anim-exit');
      
      gameUI.style.display = 'flex';
      gameUI.style.opacity = 0;
      // Fade in Game UI via CSS transition or simple animation class
      gameUI.classList.add('anim-enter');
      setTimeout(() => gameUI.style.opacity = 1, 100);

      resizeCanvas();
      btnPause.style.display = 'flex';
      restartGame();
    }, 300);
  }

  function backToMenu() {
    isPaused = false;
    modalPause.classList.remove('show');
    modalGO.classList.remove('show');
    
    // Anim exit game
    gameUI.classList.remove('anim-enter');
    gameUI.classList.add('anim-exit');
    
    setTimeout(() => {
        gameUI.style.display = 'none';
        gameUI.classList.remove('anim-exit');
        startScreen.classList.remove('hidden');
        startScreen.classList.add('anim-enter');
        btnPause.style.display = 'none';
        cancelAnimationFrame(requestID);
    }, 300);
  }

  function restartGame() {
    let sx = Math.floor(cols/2), sy = Math.floor(rows/2);
    snake = [{x:sx, y:sy}, {x:sx-1, y:sy}, {x:sx-2, y:sy}];
    dir = ''; nextDir = '';
    score = 0; combo = 1; eatenCount = 0;
    currentSpeed = 200; moveTimer = 0;
    foods = []; particles = []; floatingTexts = []; sparkles = []; shakeIntensity = 0;
    
    modalGO.classList.remove('show');
    initSeq(); genFoods();
    
    isPaused = false;
    lastTime = performance.now();
    requestID = requestAnimationFrame(loop);
  }

  // Controls
  document.addEventListener('keydown', e => {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    if(e.key==='ArrowUp' && dir!=='DOWN') nextDir='UP';
    if(e.key==='ArrowDown' && dir!=='UP') nextDir='DOWN';
    if(e.key==='ArrowLeft' && dir!=='RIGHT') nextDir='LEFT';
    if(e.key==='ArrowRight' && dir!=='LEFT') nextDir='RIGHT';
  });

  let tsX=0, tsY=0;
  canvas.addEventListener('touchstart', e => { tsX=e.touches[0].clientX; tsY=e.touches[0].clientY; }, {passive:false});
  canvas.addEventListener('touchend', e => {
    let dx = e.changedTouches[0].clientX - tsX;
    let dy = e.changedTouches[0].clientY - tsY;
    if(Math.abs(dx)>10 || Math.abs(dy)>10) {
      if(Math.abs(dx)>Math.abs(dy)) { nextDir = dx>0 ? 'RIGHT':'LEFT'; if(dir===(dx>0?'LEFT':'RIGHT')) nextDir=dir; }
      else { nextDir = dy>0 ? 'DOWN':'UP'; if(dir===(dy>0?'UP':'DOWN')) nextDir=dir; }
      if(audioCtx.state==='suspended') audioCtx.resume();
    }
  }, {passive:false});

  updateFormInputs();
</script>
</body>
</html>
