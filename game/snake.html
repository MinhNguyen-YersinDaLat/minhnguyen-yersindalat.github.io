<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>üåå QUANTUM SNAKE: YERSIN EDITION</title>
  
  <!-- Font Chakra Petch -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --q-cyan: #00f0ff;
      --q-pink: #ff0055;
      --q-void: #050508;
      --q-panel-bg: rgba(10, 15, 25, 0.95);
      --q-border: rgba(0, 240, 255, 0.5);
    }
    
    * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

    body {
      background-color: var(--q-void);
      margin: 0; padding: 0;
      height: 100vh; width: 100vw;
      overflow: hidden;
      color: #fff;
      display: flex; justify-content: center; align-items: center;
      font-family: 'Chakra Petch', sans-serif;
    }

    #main-wrapper {
      position: relative; width: 100%; height: 100%;
      display: flex; flex-direction: column; 
      justify-content: center; align-items: center;
      z-index: 10;
    }

    /* --- ANIMATIONS --- */
    @keyframes zoomIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
    @keyframes textGlitch {
      0% { text-shadow: 2px 2px var(--q-pink), -2px -2px var(--q-cyan); }
      50% { text-shadow: 2px -2px var(--q-pink), -2px 2px var(--q-cyan); }
      100% { text-shadow: 2px 2px var(--q-pink), -2px -2px var(--q-cyan); }
    }
    
    .anim-enter { animation: zoomIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

    /* --- UI ELEMENTS --- */
    .glass-panel {
      background: var(--q-panel-bg);
      border: 2px solid var(--q-border);
      box-shadow: 0 0 40px rgba(0, 240, 255, 0.15), inset 0 0 50px rgba(0,0,0,0.8);
      border-radius: 24px;
      padding: 30px;
      max-width: 480px; width: 90%;
      position: absolute;
      transition: opacity 0.3s, transform 0.3s, visibility 0.3s;
      z-index: 100;
      display: flex; flex-direction: column; gap: 15px;
      visibility: visible;
    }
    
    .glass-panel.hidden-panel {
        opacity: 0;
        pointer-events: none;
        visibility: hidden;
        transform: scale(0.9);
    }

    /* Decor corners */
    .glass-panel::before, .glass-panel::after {
      content: ''; position: absolute; width: 30px; height: 30px;
      border: 4px solid var(--q-cyan); transition: 0.3s;
      box-shadow: 0 0 15px var(--q-cyan);
    }
    .glass-panel::before { top: -2px; left: -2px; border-right: none; border-bottom: none; }
    .glass-panel::after { bottom: -2px; right: -2px; border-left: none; border-top: none; }

    h1 {
      margin: 0;
      font-family: 'Chakra Petch', sans-serif;
      font-weight: 700; font-size: 2.8rem;
      color: #fff;
      text-transform: uppercase; letter-spacing: 2px;
      text-align: center;
      line-height: 1.1;
      animation: textGlitch 3s infinite alternate-reverse;
    }

    .subtitle {
      color: #ccc; font-size: 1rem;
      text-align: center; text-transform: uppercase; letter-spacing: 3px;
      font-weight: 600; margin-top: -5px; opacity: 0.8;
      border-bottom: 1px solid var(--q-cyan);
      display: inline-block; padding-bottom: 5px;
    }

    .control-group {
      background: rgba(255,255,255,0.03);
      border-radius: 12px; padding: 12px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    .control-label {
      font-size: 0.85rem; color: var(--q-cyan); 
      text-transform: uppercase; font-weight: 700; letter-spacing: 1px;
      margin-bottom: 6px; display: block;
    }

    select, input {
      width: 100%; padding: 12px;
      background: #000; border: 1px solid #333; border-radius: 8px;
      color: #fff; font-family: 'Chakra Petch', sans-serif; font-size: 1rem; font-weight: 600;
      outline: none; transition: 0.3s; appearance: none;
    }
    
    select {
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2300f0ff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 15px top 50%;
      background-size: 12px auto;
    }

    select:focus, input:focus { border-color: var(--q-cyan); box-shadow: 0 0 15px rgba(0, 240, 255, 0.3); }

    #dynamicParams { display: flex; gap: 15px; animation: zoomIn 0.3s ease-out; }
    .param-box { flex: 1; }

    .btn-start {
      width: 100%; padding: 15px;
      background: linear-gradient(90deg, var(--q-cyan), #0051ff);
      border: none; border-radius: 12px;
      color: #fff; font-weight: 700; font-size: 1.2rem;
      text-transform: uppercase; letter-spacing: 2px;
      cursor: pointer; position: relative; overflow: hidden;
      font-family: 'Chakra Petch', sans-serif;
      transition: 0.3s;
      box-shadow: 0 5px 20px rgba(0, 240, 255, 0.3);
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .btn-start:hover { transform: translateY(-2px); box-shadow: 0 10px 40px rgba(0, 240, 255, 0.5); filter: brightness(1.1); }

    /* --- GAME UI --- */
    #gameUI { 
      display: none; flex-direction: column; align-items: center; 
      width: 100%; height: 100%; justify-content: center; z-index: 20; 
      opacity: 0; transition: opacity 0.5s;
    }

    .hud-bar {
      display: flex; width: 100%; max-width: 800px;
      justify-content: space-between; align-items: center;
      margin-bottom: 10px; padding: 0 15px;
    }

    .hud-item { display: flex; flex-direction: column; }
    .hud-label { font-size: 0.8rem; color: #889; font-weight: 700; letter-spacing: 1px; }
    .hud-value { font-family: 'Chakra Petch', sans-serif; font-size: 2rem; color: #fff; text-shadow: 0 0 10px var(--q-cyan); font-weight: bold;}
    
    .hud-center {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--q-cyan);
      padding: 5px 25px; border-radius: 30px;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.15);
      text-align: center;
      transition: opacity 0.3s;
    }
    .hud-center.hidden-hint { opacity: 0; }

    .canvas-container {
      position: relative; border-radius: 16px;
      filter: drop-shadow(0 0 25px rgba(0, 240, 255, 0.1)); 
      background: #000; box-shadow: 0 0 0 1px rgba(255,255,255,0.15);
    }
    canvas { display: block; border-radius: 16px; }

    /* CONTROLS */
    .controls {
      position: absolute; top: 15px; right: 15px;
      display: flex; gap: 10px; z-index: 200;
    }
    .btn-icon {
      width: 44px; height: 44px;
      background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px; color: #fff;
      display: flex; justify-content: center; align-items: center;
      cursor: pointer; transition: 0.2s;
    }
    .btn-icon:hover { background: var(--q-cyan); color:#000; border-color:var(--q-cyan); }
    .btn-icon svg { width: 22px; height: 22px; fill: currentColor; }

    /* UTILS & MODALS */
    .hidden { display: none !important; }
    .txt-accent { color: var(--q-pink); text-shadow: 0 0 15px var(--q-pink); }
    
    #pauseModal, #gameOverModal {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.95); backdrop-filter: blur(8px);
      display: flex; justify-content: center; align-items: center;
      z-index: 50; opacity: 0; pointer-events: none; transition: 0.3s; visibility: hidden;
    }
    .show { opacity: 1 !important; pointer-events: auto !important; visibility: visible !important; }

    #flashOverlay {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: #fff; pointer-events: none; opacity: 0;
      z-index: 40; transition: opacity 0.1s; mix-blend-mode: overlay;
    }

    /* COPYRIGHT FOOTER */
    .copyright {
      position: absolute; bottom: 15px; width: 100%;
      text-align: center; font-size: 0.9rem;
      color: rgba(255,255,255,0.4);
      text-transform: uppercase;
      letter-spacing: 1px;
      z-index: 90;
      text-shadow: 0 0 5px rgba(0,0,0,0.8);
    }
    .copyright strong { color: var(--q-cyan); font-weight: 700; }

    /* STATS TABLE */
    .stats-table { width: 100%; margin: 15px 0; border-collapse: collapse; color: #ddd; font-size: 0.95rem; }
    .stats-table td { padding: 8px 5px; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .stats-table td:last-child { text-align: right; font-weight: 700; color: #fff; }
    .stats-header { color: var(--q-cyan); text-transform: uppercase; font-size: 0.8rem; letter-spacing: 1px; }
  </style>
</head>
<body>

  <!-- Audio Element -->
  <audio id="bgMusic" loop>
    <source src="musicsnake.mp3" type="audio/mpeg">
  </audio>

  <div id="flashOverlay"></div>

  <!-- CONTROL BUTTONS -->
  <div class="controls">
    <div class="btn-icon" onclick="toggleMute()" id="btnMute" title="B·∫≠t/T·∫Øt √Çm Thanh">
      <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
    </div>
    <div class="btn-icon" onclick="togglePause()" id="btnPause" style="display:none" title="T·∫°m D·ª´ng">
      <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
    </div>
  </div>

  <div id="main-wrapper">

    <!-- START SCREEN (MENU) -->
    <div id="startScreen" class="glass-panel anim-enter">
      <div style="display:flex; flex-direction:column; align-items:center;">
        <h1>QUANTUM<br>FLUX</h1>
        <div class="subtitle">TO√ÅN H·ªåC SI√äU T·ªêC</div>
      </div>
      
      <!-- Ch·∫ø ƒë·ªô ch∆°i -->
      <div class="control-group">
        <label class="control-label">CH·∫æ ƒê·ªò CH∆†I</label>
        <select id="modeSelect" onchange="updateFormInputs()">
          <option value="geometric" selected>‚úñ C·∫•p S·ªë Nh√¢n</option>
          <option value="arithmetic">‚úö C·∫•p S·ªë C·ªông</option>
          <option value="natural">123 S·ªë T·ª± Nhi√™n</option>
          <option value="even">246 S·ªë Ch·∫µn</option>
          <option value="odd">135 S·ªë L·∫ª</option>
          <option value="prime">‚òÖ S·ªë Nguy√™n T·ªë</option>
          <option value="fibonacci">üåÄ Fibonacci</option>
          <option value="divisible">‚ûó B·ªôi S·ªë C·ªßa N</option>
        </select>
      </div>

      <!-- Tham s·ªë t√πy ch·ªânh -->
      <div id="dynamicParams" class="hidden">
        <div class="param-box" id="u1Container">
          <div class="control-group">
            <label class="control-label">S·ªê ƒê·∫¶U (u‚ÇÅ)</label>
            <input type="number" id="startInput" value="1" min="0" max="100">
          </div>
        </div>
        <div class="param-box" id="paramContainer">
          <div class="control-group">
            <label class="control-label" id="paramLabel">C√îNG B·ªòI (q)</label>
            <input type="number" id="paramInput" value="2" min="1" max="20">
          </div>
        </div>
      </div>

      <button class="btn-start" onclick="initGame()">B·∫ÆT ƒê·∫¶U NGAY</button>
    </div>

    <!-- COPYRIGHT -->
    <div class="copyright">
      Th·∫ßy <strong>Th√°i Minh Nguy√™n</strong><br>
      Tr∆∞·ªùng TH, THCS & THPT YERSIN ƒê√Ä L·∫†T
    </div>

    <!-- GAME UI -->
    <div id="gameUI">
      <div class="hud-bar">
        <div class="hud-item">
          <span class="hud-label">ƒêI·ªÇM</span>
          <span class="hud-value" id="score">0</span>
        </div>
        
        <div class="hud-center" id="targetWrapper">
          <div class="hud-label" style="color:var(--q-cyan)">C·∫¶N T√åM</div>
          <div class="hud-value" id="targetBadge" style="font-size: 2rem;">?</div>
        </div>

        <div class="hud-item" style="align-items: flex-end;">
          <span class="hud-label">COMBO</span>
          <span class="hud-value txt-accent" id="combo">x1</span>
        </div>
      </div>
      
      <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
      </div>
      
      <div style="margin-top:20px; font-size:0.9rem; color:#678; font-weight:600; text-transform:uppercase; letter-spacing:1px">
        ƒêi·ªÅu khi·ªÉn: Vu·ªët ho·∫∑c d√πng ph√≠m m≈©i t√™n
      </div>
    </div>

    <!-- PAUSE MODAL -->
    <div id="pauseModal">
      <div class="glass-panel" style="text-align: center; width: 320px; align-items: center;">
        <h2 style="color: #fff; margin-bottom: 20px;">T·∫†M D·ª™NG</h2>
        <button class="btn-start" onclick="togglePause()">TI·∫æP T·ª§C</button>
        <button class="btn-start" style="background:transparent; border:1px solid #556; margin-top:10px" onclick="backToMenu()">V·ªÄ TRANG CH·ª¶</button>
      </div>
    </div>

    <!-- GAME OVER MODAL -->
    <div id="gameOverModal">
      <div class="glass-panel" style="border-color: var(--q-pink);">
        <h2 style="color: var(--q-pink); margin: 0; text-align: center; font-size: 2.2rem; text-shadow: 0 0 20px var(--q-pink);">T·ªîNG K·∫æT</h2>
        
        <div id="statsContent">
            <!-- Content injected via JS -->
        </div>
        
        <div style="display:flex; justify-content: center; width:100%; margin-top: 10px;">
          <button class="btn-start" style="background: linear-gradient(135deg, var(--q-pink), #990033); width: 80%; font-size: 1.1rem;" onclick="backToMenu()">V·ªÄ TRANG CH·ª¶</button>
        </div>
      </div>
    </div>

  </div>

<script>
  // --- CORE SYSTEM ---
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const box = 40; 
  let rows, cols;
  
  // Elements
  const startScreen = document.getElementById('startScreen');
  const gameUI = document.getElementById('gameUI');
  const modalGO = document.getElementById('gameOverModal');
  const modalPause = document.getElementById('pauseModal');
  const targetWrapper = document.getElementById('targetWrapper');
  const dynamicParams = document.getElementById('dynamicParams');
  const flashOverlay = document.getElementById('flashOverlay');
  const btnPause = document.getElementById('btnPause');
  const copyright = document.querySelector('.copyright');
  const bgMusic = document.getElementById('bgMusic');
  const statsContent = document.getElementById('statsContent');

  // Game State
  let requestID;
  let isPaused = false;
  let isMuted = false;
  
  let snake = [];
  let dir = '', nextDir = '';
  let score = 0;
  let combo = 1;
  let foods = [];
  let eatenCount = 0;
  let eatenSum = 0; // Track sum
  let lastEatenVal = 0; // Track last eaten
  
  // Timing
  let lastTime = 0;
  let moveTimer = 0;
  let currentSpeed = 200; 
  let moveProgress = 0;
  
  // Visual Effects
  let particles = [];
  let floatingTexts = [];
  let stars = [];
  let sparkles = []; 
  let shootingStars = []; // Sao bƒÉng
  let shakeIntensity = 0;
  let globalTime = 0;

  // Math Logic
  let gameMode = 'geometric', param1 = 2, paramStart = 1, currentVal = 1, prevVal = 0;

  // --- CLASSES ---
  class Star {
    constructor() { this.reset(); this.y = Math.random() * canvas.height; }
    reset() {
      this.x = Math.random() * canvas.width;
      this.y = -10;
      this.z = Math.random() * 2 + 0.5;
      this.size = Math.random() * 1.5;
      this.opacity = Math.random() * 0.5 + 0.1;
    }
    update(dt) {
      this.y += this.z * (dt * 0.05);
      if (this.y > canvas.height) this.reset();
    }
    draw(ctx) {
      ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
    }
  }

  // L·ªõp Sao BƒÉng
  class ShootingStar {
    constructor() {
      this.reset();
    }
    reset() {
      this.x = Math.random() * canvas.width + 100;
      this.y = Math.random() * canvas.height * 0.5;
      this.len = Math.random() * 80 + 20;
      this.speed = Math.random() * 10 + 10;
      this.size = Math.random() * 2 + 0.5;
      this.angle = Math.PI / 4; // Bay ch√©o 45 ƒë·ªô
      this.active = false;
      this.waitTime = globalTime + Math.random() * 5 + 2; // Xu·∫•t hi·ªán ng·∫´u nhi√™n sau v√†i gi√¢y
    }
    update() {
      if (globalTime > this.waitTime && !this.active) {
          this.active = true;
      }
      if (this.active) {
          this.x -= this.speed;
          this.y += this.speed;
          if (this.x < -100 || this.y > canvas.height + 100) {
              this.reset(); // Reset khi bay kh·ªèi m√†n h√¨nh
              this.waitTime = globalTime + Math.random() * 10 + 5;
          }
      }
    }
    draw(ctx) {
      if (!this.active) return;
      ctx.save();
      ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      ctx.lineWidth = this.size;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x + this.len, this.y - this.len);
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#ffffff";
      ctx.stroke();
      ctx.restore();
    }
  }

  class Particle {
    constructor(x, y, color) {
      this.x = x; this.y = y;
      let angle = Math.random() * Math.PI * 2;
      let speed = Math.random() * 5 + 2;
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;
      this.life = 1.0;
      this.color = color;
      this.size = Math.random() * 3 + 1;
    }
    update() {
      this.x += this.vx; this.y += this.vy;
      this.vx *= 0.94; this.vy *= 0.94;
      this.life -= 0.03;
    }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = this.color;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  class Sparkle {
    constructor(x, y, color) {
      this.x = x + (Math.random() - 0.5) * box;
      this.y = y + (Math.random() - 0.5) * box;
      this.color = color;
      this.life = 1.0;
      this.size = Math.random() * 2 + 1;
      this.blinkRate = Math.random() * 0.1 + 0.05;
    }
    update() { this.life -= this.blinkRate; }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = "#fff";
      ctx.shadowBlur = 5; ctx.shadowColor = this.color;
      ctx.fillRect(this.x - this.size, this.y, this.size * 2, 1);
      ctx.fillRect(this.x, this.y - this.size, 1, this.size * 2);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
  }

  class FloatingText {
    constructor(x, y, text, color) {
      this.x = x; this.y = y;
      this.text = text; this.color = color;
      this.life = 1.0;
      this.yOffset = 0;
    }
    update() { this.yOffset -= 1.5; this.life -= 0.02; }
    draw(ctx) {
      ctx.globalAlpha = Math.max(0, this.life);
      ctx.fillStyle = this.color;
      ctx.font = "900 20px 'Chakra Petch'";
      ctx.textAlign = "center";
      ctx.fillText(this.text, this.x, this.y + this.yOffset);
      ctx.globalAlpha = 1;
    }
  }

  // --- SYSTEM ---

  function resizeCanvas() {
    const maxWidth = Math.min(window.innerWidth - 20, 800);
    const maxHeight = Math.min(window.innerHeight - 150, 800);
    const newCols = Math.floor(maxWidth / box);
    const newRows = Math.floor(maxHeight / box);
    canvas.width = newCols * box;
    canvas.height = newRows * box;
    cols = newCols; rows = newRows;
    stars = [];
    for(let i=0; i<50; i++) stars.push(new Star());
    
    // Init Shooting Stars
    shootingStars = [];
    for(let i=0; i<2; i++) shootingStars.push(new ShootingStar());
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = new AudioContext();

  function playTone(freq, type, duration) {
    if (isMuted || audioCtx.state === 'suspended') {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        if(isMuted) return;
    }
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
  }

  function toggleMute() { 
    isMuted = !isMuted; 
    document.getElementById('btnMute').style.opacity = isMuted ? 0.5 : 1; 
    bgMusic.muted = isMuted;
  }

  function togglePause() {
    if (gameUI.style.display === 'none') return;
    isPaused = !isPaused;
    if (isPaused) {
      modalPause.classList.add('show');
    } else {
      modalPause.classList.remove('show');
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }
  }

  function triggerFlash(color = 'white') {
    flashOverlay.style.background = color;
    flashOverlay.style.opacity = 0.2;
    setTimeout(() => { flashOverlay.style.opacity = 0; }, 50);
  }

  // --- MENU LOGIC ---
  
  function updateFormInputs() {
    const mode = document.getElementById('modeSelect').value;
    const u1 = document.getElementById('u1Container');
    const p1 = document.getElementById('paramContainer');
    const l1 = document.getElementById('paramLabel');
    const i1 = document.getElementById('paramInput');
    const s1 = document.getElementById('startInput');
    
    dynamicParams.classList.add('hidden');
    u1.classList.add('hidden'); 
    p1.classList.add('hidden');
    
    if(mode==='arithmetic') { 
        dynamicParams.classList.remove('hidden'); 
        u1.classList.remove('hidden'); 
        p1.classList.remove('hidden'); 
        l1.textContent="C√¥ng Sai (d)"; i1.value=5; s1.value=0; 
    }
    else if(mode==='geometric') { 
        dynamicParams.classList.remove('hidden'); 
        u1.classList.remove('hidden'); 
        p1.classList.remove('hidden'); 
        l1.textContent="C√¥ng B·ªôi (q)"; i1.value=2; s1.value=1; 
    }
    else if(mode==='divisible') { 
        dynamicParams.classList.remove('hidden'); 
        p1.classList.remove('hidden'); 
        l1.textContent="S·ªë Chia (N)"; i1.value=3; 
    }
  }

  // --- GAME LOGIC ---

  function isPrime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (let i = 5; i * i <= n; i += 6) {
      if (n % i === 0 || n % (i + 2) === 0) return false;
    }
    return true;
  }

  function nextPrime(n) {
    let x = n + 1;
    while (!isPrime(x)) x++;
    return x;
  }

  function initSeq() {
    switch(gameMode) {
      case 'natural': currentVal = 1; break;
      case 'even': currentVal = 2; break;
      case 'odd': currentVal = 1; break;
      case 'prime': currentVal = 2; break;
      case 'fibonacci': prevVal = 0; currentVal = 1; break; 
      case 'geometric': currentVal = paramStart; break;
      case 'arithmetic': currentVal = paramStart; break;
      case 'divisible': currentVal = param1; break;
      default: currentVal = 1;
    }
    updateTargetUI();
  }

  function nextSeq() {
    let nextVal;
    switch(gameMode) {
      case 'natural': nextVal = currentVal + 1; break;
      case 'even': nextVal = currentVal + 2; break;
      case 'odd': nextVal = currentVal + 2; break;
      case 'prime': nextVal = nextPrime(currentVal); break;
      case 'fibonacci': nextVal = currentVal + prevVal; prevVal = currentVal; break;
      case 'geometric': nextVal = currentVal * param1; break;
      case 'arithmetic': nextVal = currentVal + param1; break;
      case 'divisible': nextVal = currentVal + param1; break;
      default: nextVal = currentVal + 1;
    }
    return nextVal;
  }

  function updateTargetUI() {
    document.getElementById("targetBadge").textContent = currentVal;
    if(eatenCount >= 3) targetWrapper.classList.add('hidden-hint');
    else targetWrapper.classList.remove('hidden-hint');
  }

  function getSafePos() {
    let pos, safe=false, att=0;
    while(!safe && att<100) {
      pos = { x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows) };
      safe = !snake.some(s=>s.x===pos.x && s.y===pos.y) && !foods.some(f=>f.pos && f.pos.x===pos.x && f.pos.y===pos.y);
      att++;
    }
    return pos;
  }

  function genFoods() {
    foods = [];
    let nextVal = nextSeq();
    // Revert Fibonacci side-effect manually for display correctness
    if (gameMode === 'fibonacci') {
        let actualNext = currentVal; 
        currentVal = prevVal; 
        prevVal = actualNext - prevVal;
    }
    
    // Correct Food
    let hue = Math.random() * 360;
    let color = `hsl(${hue}, 100%, 60%)`;
    // Restore logic for Fib
    if (gameMode === 'fibonacci') {
        let temp = prevVal + currentVal;
        prevVal = currentVal;
        currentVal = temp;
    }
    
    foods.push({ val: currentVal, pos: getSafePos(), isCorrect: true, spawnTime: globalTime, color: color });
    
    // Fake Foods logic...
    let attempts = 0;
    while(foods.length < 4 && attempts < 100) {
      let fake;
      let range = Math.max(5, Math.floor(currentVal * 0.5));
      let diff = Math.floor(Math.random() * range * 2) - range;
      fake = currentVal + diff;
      let fakeHue = (hue + 60 + Math.random() * 240) % 360; 
      let fakeColor = `hsl(${fakeHue}, 100%, 60%)`;
      if (fake > -100 && fake !== currentVal && !foods.some(f=>f.val===fake)) {
        foods.push({ val: fake, pos: getSafePos(), isCorrect: false, spawnTime: globalTime, color: fakeColor });
      }
      attempts++;
    }
    while (foods.length < 4) {
       let r = Math.floor(Math.random() * 50) + currentVal + 10;
       let rHue = Math.random() * 360;
       if (!foods.some(f=>f.val===r)) foods.push({ val: r, pos: getSafePos(), isCorrect: false, spawnTime: globalTime, color: `hsl(${rHue}, 100%, 60%)` });
    }
  }

  // --- GAME OVER LOGIC ---
  function getModeDetails() {
      let name = "", params = "";
      switch(gameMode) {
          case 'geometric': name="C·∫•p S·ªë Nh√¢n"; params=`u‚ÇÅ=${paramStart}, q=${param1}`; break;
          case 'arithmetic': name="C·∫•p S·ªë C·ªông"; params=`u‚ÇÅ=${paramStart}, d=${param1}`; break;
          case 'natural': name="S·ªë T·ª± Nhi√™n"; params="u‚ÇÅ=1, d=1"; break;
          case 'even': name="S·ªë Ch·∫µn"; params="u‚ÇÅ=2, d=2"; break;
          case 'odd': name="S·ªë L·∫ª"; params="u‚ÇÅ=1, d=2"; break;
          case 'prime': name="S·ªë Nguy√™n T·ªë"; params="2, 3, 5, 7..."; break;
          case 'fibonacci': name="D√£y Fibonacci"; params="1, 1, 2, 3, 5..."; break;
          case 'divisible': name=`B·ªôi S·ªë C·ªßa ${param1}`; params=`u‚ÇÅ=${param1}, d=${param1}`; break;
      }
      return { name, params };
  }

  function gameOver() {
    playTone(100, 'sawtooth', 0.5);
    isPaused = true;
    
    const info = getModeDetails();
    
    let html = `
        <table class="stats-table">
            <tr><td class="stats-header">Quy Lu·∫≠t</td><td>${info.name}</td></tr>
            <tr><td class="stats-header">Tham S·ªë</td><td>${info.params}</td></tr>
            <tr><td>S·ªë cu·ªëi c√πng (u<sub>n</sub>)</td><td style="color:var(--q-cyan)">${eatenCount > 0 ? lastEatenVal : 'Ch∆∞a ƒÉn'}</td></tr>
            <tr><td>S·ªë h·∫°ng th·ª© (n)</td><td>${eatenCount}</td></tr>
            <tr><td>T·ªïng d√£y s·ªë (S<sub>n</sub>)</td><td style="color:var(--q-pink)">${eatenSum}</td></tr>
        </table>
    `;
    
    statsContent.innerHTML = html;
    modalGO.classList.add('show');
    modalGO.classList.add('anim-enter');
  }

  // --- LOOP ---

  function loop(timestamp) {
    if (isPaused) return;

    let dt = timestamp - lastTime;
    lastTime = timestamp;
    if (dt > 100) dt = 100;

    globalTime += dt * 0.001;
    moveTimer += dt;
    
    if (moveTimer >= currentSpeed) {
      moveTimer = 0;
      if (nextDir) dir = nextDir;
      if (dir) {
        let head = { ...snake[0] };
        if(dir==='LEFT') head.x--;
        if(dir==='RIGHT') head.x++;
        if(dir==='UP') head.y--;
        if(dir==='DOWN') head.y++;

        if(head.x<0 || head.x>=cols || head.y<0 || head.y>=rows || snake.some(s=>s.x===head.x && s.y===head.y)) {
          shakeIntensity = 20; triggerFlash('red'); gameOver(); return;
        }

        snake.unshift(head);

        let eatenIdx = foods.findIndex(f => f.pos.x === head.x && f.pos.y === head.y);
        if(eatenIdx !== -1) {
          let f = foods[eatenIdx];
          let cx = head.x*box+box/2, cy = head.y*box+box/2;
          if(f.isCorrect) {
            score += 10 * combo;
            combo = Math.min(5, combo + 1);
            
            // Analytics tracking
            lastEatenVal = f.val;
            eatenCount++;
            eatenSum += f.val;
            
            triggerFlash(f.color);
            playTone(600 + (combo*100), 'sine', 0.1);
            
            shakeIntensity = 5;
            for(let i=0; i<10; i++) particles.push(new Particle(cx, cy, f.color));
            floatingTexts.push(new FloatingText(cx, cy - 20, `+${10*combo}`, f.color));
            if(combo > 1) floatingTexts.push(new FloatingText(cx, cy - 40, `COMBO x${combo}!`, '#ff0055'));

            currentSpeed = Math.max(80, currentSpeed - 2);
            currentVal = nextSeq();
            updateTargetUI();
            genFoods();
          } else {
            shakeIntensity = 15;
            triggerFlash('#ff0055');
            for(let i=0; i<15; i++) particles.push(new Particle(cx, cy, '#ff0055'));
            gameOver(); return;
          }
        } else {
          snake.pop();
        }
      }
    }
    
    if (Math.random() > 0.8) {
      let f = foods[Math.floor(Math.random() * foods.length)];
      if(f) sparkles.push(new Sparkle(f.pos.x * box + box/2, f.pos.y * box + box/2, f.color));
    }

    draw(dt);
    requestID = requestAnimationFrame(loop);
  }

  function drawMoon(ctx) {
      let cx = canvas.width - 80;
      let cy = 80;
      let r = 40;
      
      // Glow Pulse
      let glow = 10 + Math.sin(globalTime) * 5;
      
      ctx.save();
      ctx.shadowBlur = glow;
      ctx.shadowColor = "#e0f7fa";
      ctx.fillStyle = "rgba(224, 247, 250, 0.9)";
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fill();
      
      // Moon texture/crater hint (optional simple style)
      ctx.fillStyle = "rgba(200, 230, 240, 0.5)";
      ctx.beginPath();
      ctx.arc(cx - 10, cy - 10, 10, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 15, cy + 5, 6, 0, Math.PI*2);
      ctx.fill();
      
      ctx.restore();
  }

  function draw(dt) {
    ctx.fillStyle = "#050508";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    if(shakeIntensity > 0) {
      let dx = (Math.random()-0.5)*shakeIntensity;
      let dy = (Math.random()-0.5)*shakeIntensity;
      ctx.translate(dx, dy);
      shakeIntensity *= 0.9;
      if(shakeIntensity<0.5) shakeIntensity=0;
    }

    // Draw Background Elements
    stars.forEach(s => { s.update(dt); s.draw(ctx); });
    shootingStars.forEach(s => { s.update(); s.draw(ctx); });
    drawMoon(ctx);

    ctx.strokeStyle = "rgba(0, 240, 255, 0.03)";
    ctx.lineWidth = 1;
    for(let i=0; i<=cols; i++) { ctx.beginPath(); ctx.moveTo(i*box,0); ctx.lineTo(i*box,canvas.height); ctx.stroke(); }
    for(let i=0; i<=rows; i++) { ctx.beginPath(); ctx.moveTo(0,i*box); ctx.lineTo(canvas.width,i*box); ctx.stroke(); }

    ctx.globalCompositeOperation = 'lighter';
    for(let i=particles.length-1; i>=0; i--) {
      particles[i].update();
      particles[i].draw(ctx);
      if(particles[i].life<=0) particles.splice(i,1);
    }
    for(let i=sparkles.length-1; i>=0; i--) {
      sparkles[i].update();
      sparkles[i].draw(ctx);
      if(sparkles[i].life<=0) sparkles.splice(i,1);
    }
    ctx.globalCompositeOperation = 'source-over';

    let pulse = 1 + Math.sin(globalTime * 3) * 0.05;
    
    foods.forEach(f => {
      let cx = f.pos.x * box + box/2;
      let cy = f.pos.y * box + box/2;
      let r = (box/2 - 4) * pulse;

      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fill();
      
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.strokeStyle = f.color;
      ctx.lineWidth = 2; 
      ctx.shadowBlur = 10; ctx.shadowColor = f.color;
      ctx.stroke();
      ctx.shadowBlur = 0;

      ctx.fillStyle = "#fff"; 
      ctx.font = "700 16px 'Chakra Petch'";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(f.val, cx, cy);
    });

    if(snake.length > 0) {
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      let fatness = Math.min(10, eatenCount / 2);
      ctx.lineWidth = (box - 12) + fatness;
      
      let headPos = snake[0]; 
      let tailPos = snake[snake.length-1];
      
      let snakeGrad;
      if (combo >= 3) {
          snakeGrad = ctx.createLinearGradient(headPos.x*box, headPos.y*box, tailPos.x*box, tailPos.y*box);
          let hue = (globalTime * 200) % 360;
          snakeGrad.addColorStop(0, `hsl(${hue}, 100%, 60%)`);
          snakeGrad.addColorStop(1, `hsl(${(hue + 180)%360}, 100%, 50%)`);
          ctx.shadowBlur = 20; ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
      } else {
          snakeGrad = ctx.createLinearGradient(headPos.x*box, headPos.y*box, tailPos.x*box, tailPos.y*box);
          snakeGrad.addColorStop(0, '#00f0ff');
          snakeGrad.addColorStop(1, '#0051ff');
          ctx.shadowBlur = 0;
      }
      
      ctx.beginPath();
      ctx.strokeStyle = snakeGrad;
      ctx.moveTo(headPos.x*box+box/2, headPos.y*box+box/2);
      for(let i=1; i<snake.length; i++) { ctx.lineTo(snake[i].x*box+box/2, snake[i].y*box+box/2); }
      ctx.stroke();
      ctx.shadowBlur = 0;

      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(headPos.x*box+box/2, headPos.y*box+box/2, (box/3) + (fatness/4), 0, Math.PI*2); ctx.fill();
    }

    floatingTexts.forEach((t, i) => {
      t.update(); t.draw(ctx);
      if(t.life<=0) floatingTexts.splice(i,1);
    });

    ctx.restore();

    document.getElementById('score').textContent = score;
    document.getElementById('combo').textContent = 'x' + combo;
    document.getElementById('combo').style.opacity = combo > 1 ? 1 : 0.3;
  }

  // --- INIT ---

  function initGame() {
    gameMode = document.getElementById('modeSelect').value;
    let pInput = parseInt(document.getElementById('paramInput').value);
    param1 = isNaN(pInput) ? 2 : pInput;
    let sInput = parseInt(document.getElementById('startInput').value);
    paramStart = isNaN(sInput) ? 1 : sInput;

    startScreen.classList.add('hidden-panel');
    copyright.classList.add('hidden'); 
    
    bgMusic.play().catch(e=>console.log(e));

    setTimeout(() => {
      gameUI.style.display = 'flex';
      gameUI.style.opacity = 1;
      resizeCanvas();
      btnPause.style.display = 'flex';
      restartGame();
    }, 300);
  }

  function backToMenu() {
    isPaused = false;
    modalPause.classList.remove('show');
    modalGO.classList.remove('show');
    bgMusic.pause(); bgMusic.currentTime = 0;

    gameUI.style.opacity = 0;
    
    if(requestID) cancelAnimationFrame(requestID);

    setTimeout(() => {
        gameUI.style.display = 'none';
        startScreen.classList.remove('hidden-panel');
        copyright.classList.remove('hidden'); 
        btnPause.style.display = 'none';
    }, 300);
  }

  function restartGame() {
    if(requestID) cancelAnimationFrame(requestID);
    
    let sx = Math.floor(cols/2), sy = Math.floor(rows/2);
    snake = [{x:sx, y:sy}, {x:sx-1, y:sy}, {x:sx-2, y:sy}];
    dir = ''; nextDir = '';
    score = 0; combo = 1; eatenCount = 0; eatenSum = 0; lastEatenVal = 0;
    currentSpeed = 200; moveTimer = 0;
    foods = []; particles = []; floatingTexts = []; sparkles = []; shakeIntensity = 0;
    
    modalGO.classList.remove('show');
    initSeq(); genFoods();
    
    bgMusic.play().catch(e=>console.log(e));

    isPaused = false;
    lastTime = performance.now();
    requestID = requestAnimationFrame(loop);
  }

  document.addEventListener('keydown', e => {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    if(e.key==='ArrowUp' && dir!=='DOWN') nextDir='UP';
    if(e.key==='ArrowDown' && dir!=='UP') nextDir='DOWN';
    if(e.key==='ArrowLeft' && dir!=='RIGHT') nextDir='LEFT';
    if(e.key==='ArrowRight' && dir!=='LEFT') nextDir='RIGHT';
  });

  let tsX=0, tsY=0;
  canvas.addEventListener('touchstart', e => { tsX=e.touches[0].clientX; tsY=e.touches[0].clientY; }, {passive:false});
  canvas.addEventListener('touchend', e => {
    let dx = e.changedTouches[0].clientX - tsX;
    let dy = e.changedTouches[0].clientY - tsY;
    if(Math.abs(dx)>10 || Math.abs(dy)>10) {
      if(Math.abs(dx)>Math.abs(dy)) { nextDir = dx>0 ? 'RIGHT':'LEFT'; if(dir===(dx>0?'LEFT':'RIGHT')) nextDir=dir; }
      else { nextDir = dy>0 ? 'DOWN':'UP'; if(dir===(dy>0?'UP':'DOWN')) nextDir=dir; }
      if(audioCtx.state==='suspended') audioCtx.resume();
    }
  }, {passive:false});

  updateFormInputs();
</script>
</body>
</html>
