<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Game Kim Cương: Bão Khói Độc</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet"/>
    <script src="https://kit.fontawesome.com/4a2129a3a2.js" crossorigin="anonymous"></script>

    <style>
        /* --- General Styles --- */
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            animation: vignette-pulse 8s infinite alternate ease-in-out;
            background-color: #0c0a09;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        @keyframes vignette-pulse {
            from { background: radial-gradient(ellipse at center, #1a1111 50%, #000000 100%); }
            to { background: radial-gradient(ellipse at center, #110a0a 40%, #000000 100%); }
        }
        canvas {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        #game-wrapper {
            position: absolute;
            width: 1280px; /* Native width */
            height: 720px; /* Native height */
            transform-origin: top left;
            transition: transform 0.2s ease-out;
        }

        /* --- Character / Monster Styles --- */
        #character-container {
            position: absolute;
            top: -95px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
            z-index: 20;
        }
        .character-aura {
            position: absolute;
            width: 250px;
            height: 150px;
            background: radial-gradient(ellipse at center, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0) 70%);
            border-radius: 50%;
            animation: aura-pulse 4s infinite alternate ease-in-out;
            z-index: -1;
        }
        @keyframes aura-pulse {
            from { transform: scale(1); opacity: 0.7; }
            to { transform: scale(1.2); opacity: 0.4; }
        }
        #cigarette-svg, #vape-svg, #ht-svg {
            width: 240px; 
            height: 120px; 
            filter: drop-shadow(0 5px 20px rgba(0, 0, 0, 0.8));
            animation: idle-spasm 6s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        @keyframes idle-spasm {
            0%, 100% { transform: translate(0, 0) rotate(0); } 10% { transform: translate(-2px, 2px) rotate(-1deg); } 20% { transform: translate(2px, -2px) rotate(1deg); } 30% { transform: translate(-3px, 0px) rotate(-1.5deg); } 40% { transform: translate(3px, 1px) rotate(1.5deg); } 50% { transform: translate(0, 0) rotate(0); } 70% { transform: translate(0, 0) rotate(0); } 72% { transform: translate(5px, -5px) rotate(3deg); } 74% { transform: translate(0, 0) rotate(0); }
        }
        .cigarette-body-shape { fill: url(#paper-gradient); } .filter-shape { fill: #6b3520; } .ash-shape { fill: #333; } .ember-shape { fill: #ff4500; filter: url(#emberGlow); animation: ember-flicker 1.5s infinite alternate; }
        @keyframes ember-flicker { from { opacity: 0.9; } to { opacity: 1; } }
        .eye-socket { fill: #1a0000; } .eye-ball { fill: #dc143c; } .eye-pupil { fill: #000; transition: transform 0.1s linear; } .eye-vein { stroke: #8b0000; stroke-width: 0.5; fill: none; } .mouth { fill: #1a1a1a; transition: d 0.3s ease-in-out; } .crack { fill: none; stroke: #4e2a1d; stroke-width: 1.2; } .stain { fill: #704214; opacity: 0.6; } .spark { fill: #ffdd00; animation: spark-fly 1.5s infinite linear; }
        @keyframes spark-fly { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(-30px, var(--y-end)) scale(0); opacity: 0; } }
        .smoke-container { position: absolute; left: -120px; top: 50%; transform: translateY(-50%); width: 200px; height: 200px; pointer-events: none; filter: url(#smokeFilter); }
        .smoke-wisp { position: absolute; background: white; border-radius: 50%; animation: wisp-rise 12s infinite linear; opacity: 0; }
        @keyframes wisp-rise { 0% { transform: translate(0, 0) scale(0.5); opacity: 0; } 15% { opacity: 0.8; } 100% { transform: translate(-120px, var(--y-end)) scale(2.5); opacity: 0; } }
        .smoke-wisp:nth-child(1) { width: 60px; height: 60px; animation-delay: 0s; --y-end: -80px; } .smoke-wisp:nth-child(2) { width: 80px; height: 80px; animation-delay: 4s; --y-end: 50px; } .smoke-wisp:nth-child(3) { width: 50px; height: 50px; animation-delay: 8s; --y-end: -20px; }

        /* --- UI & Game Elements --- */
        #custom-cursor { position: fixed; width: 20px; height: 20px; border: 2px solid #ff4500; border-radius: 50%; pointer-events: none; transform: translate(-50%, -50%); z-index: 9999; transition: transform 0.1s ease-out; }
        
        /* --- Screens & Modals --- */
        #start-screen { position: fixed; inset: 0; background-color: rgba(0,0,0,0.8); backdrop-filter: blur(10px); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; text-align: center; padding: 1rem; }
        .tutorial-icon { height: 60px; margin: 0 auto 0.5rem auto; display: flex; align-items: center; justify-content: center; }
       
        /* --- UI Buttons --- */
        .ui-button { position: fixed; z-index: 101; width: 44px; height: 44px; background: rgba(10, 20, 30, 0.5); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 50%; color: rgba(236, 72, 153, 0.7); display: flex; align-items: center; justify-content: center; cursor: pointer; backdrop-filter: blur(5px); transition: all 0.3s ease; box-shadow: 0 0 15px rgba(236, 72, 153, 0.2), inset 0 0 5px rgba(236, 72, 153, 0.1); }
        .ui-button:hover { background: rgba(20, 40, 60, 0.7); color: white; border-color: rgba(236, 72, 153, 0.8); box-shadow: 0 0 25px rgba(236, 72, 153, 0.5), inset 0 0 10px rgba(236, 72, 153, 0.2); transform: scale(1.1); }
        #fullscreen-btn { top: 1rem; right: 1rem; }
        #back-to-menu-btn { bottom: 1rem; right: 1rem; }

        /* --- Smoke Storm Mode Styles --- */
        .smoke-column-warning {
            position: absolute;
            top: 0;
            width: 100%;
            height: 40px;
            background: radial-gradient(ellipse at center, rgba(255, 0, 0, 0.6) 0%, rgba(255, 0, 0, 0) 70%);
            border-radius: 50%;
            animation: pulse-warning 1s infinite alternate;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .smoke-column-warning.visible {
            opacity: 1;
        }
        @keyframes pulse-warning {
            from { transform: scale(1); opacity: 0.5; }
            to { transform: scale(1.2); opacity: 1; }
        }
        .info-panel {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 1rem;
            width: 280px;
            flex-shrink: 0;
            height: 680px;
            overflow-y: auto;
        }
        .recovery-milestone {
            transition: all 0.5s ease;
            padding: 4px;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        .recovery-milestone.achieved {
            background-color: rgba(4, 120, 87, 0.5); /* green-700 with opacity */
            color: #f0fdf4; /* green-50 */
        }

        /* --- New 3D Lung Styles --- */
        .lung-3d {
            transform-style: preserve-3d;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .lung-path.lung-healthy {
            fill: url(#healthyGradient);
            stroke: url(#healthyStroke);
            stroke-width: 3;
            filter: drop-shadow(0 8px 25px rgba(255, 107, 107, 0.4)) drop-shadow(0 0 15px rgba(255, 182, 193, 0.6));
            animation: breathe3D 4s ease-in-out infinite;
        }
        
        .lung-path.lung-damaged {
            fill: url(#damagedGradient);
            stroke: url(#damagedStroke);
            stroke-width: 3;
            filter: drop-shadow(0 8px 25px rgba(0, 0, 0, 0.7)) drop-shadow(0 0 20px rgba(139, 0, 0, 0.8));
            animation: wheeze3D 2.5s ease-in-out infinite;
        }

        .airway.airway-healthy {
            fill: url(#airwayGradient);
            stroke: url(#healthyStroke);
            filter: url(#glow);
        }

        .airway.airway-damaged {
            fill: url(#damagedGradient);
            stroke: url(#damagedStroke);
            opacity: 0.9;
        }
        
        @keyframes breathe3D {
            0%, 100% { 
                transform: scale(1) rotateY(0deg) rotateX(0deg); 
                filter: drop-shadow(0 8px 25px rgba(255, 107, 107, 0.4)) drop-shadow(0 0 15px rgba(255, 182, 193, 0.6)) brightness(1);
            }
            25% { 
                transform: scale(1.03) rotateY(2deg) rotateX(1deg); 
                filter: drop-shadow(0 10px 30px rgba(255, 107, 107, 0.5)) drop-shadow(0 0 20px rgba(255, 182, 193, 0.8)) brightness(1.1);
            }
            50% { 
                transform: scale(1.05) rotateY(0deg) rotateX(2deg); 
                filter: drop-shadow(0 12px 35px rgba(255, 107, 107, 0.6)) drop-shadow(0 0 25px rgba(255, 182, 193, 1)) brightness(1.2);
            }
            75% { 
                transform: scale(1.03) rotateY(-2deg) rotateX(1deg); 
                filter: drop-shadow(0 10px 30px rgba(255, 107, 107, 0.5)) drop-shadow(0 0 20px rgba(255, 182, 193, 0.8)) brightness(1.1);
            }
        }
        
        @keyframes wheeze3D {
            0%, 100% { 
                transform: scale(1) rotateY(0deg) rotateX(0deg); 
                filter: drop-shadow(0 8px 25px rgba(0, 0, 0, 0.7)) drop-shadow(0 0 20px rgba(139, 0, 0, 0.8)) brightness(0.6);
            }
            20% { 
                transform: scale(0.97) rotateY(-3deg) rotateX(-2deg); 
                filter: drop-shadow(0 6px 20px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 25px rgba(139, 0, 0, 1)) brightness(0.5);
            }
            40% { 
                transform: scale(1.02) rotateY(4deg) rotateX(3deg); 
                filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.9)) drop-shadow(0 0 30px rgba(139, 0, 0, 1.2)) brightness(0.4);
            }
            60% { 
                transform: scale(0.98) rotateY(-2deg) rotateX(-1deg); 
                filter: drop-shadow(0 7px 22px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 22px rgba(139, 0, 0, 0.9)) brightness(0.55);
            }
            80% { 
                transform: scale(1.01) rotateY(1deg) rotateX(2deg); 
                filter: drop-shadow(0 9px 28px rgba(0, 0, 0, 0.85)) drop-shadow(0 0 28px rgba(139, 0, 0, 1.1)) brightness(0.45);
            }
        }
        
        .spot-3d {
            fill: url(#spotGradient);
            opacity: 0;
            transform: scale(0);
            filter: drop-shadow(0 1px 4px rgba(0, 0, 0, 0.8));
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .spot-3d.visible {
            opacity: 0.95;
            transform: scale(1);
            animation: spotGrow3D 0.5s ease-out forwards;
        }
        
        @keyframes spotGrow3D {
            from { opacity: 0; transform: scale(0); }
            to { opacity: 0.95; transform: scale(1); }
        }

        .damage-flash #healthy-lung-group {
            animation: damageWaveFlash 1s ease-out;
        }

        @keyframes damageWaveFlash {
            0%, 100% { 
                filter: none;
            }
            50% { 
                filter: hue-rotate(20deg) brightness(0.7) saturate(0.5) contrast(1.2);
            }
        }

    </style>
</head>
<body class="bg-gradient-to-br from-gray-700 via-gray-800 to-gray-900 p-4">

<div id="pollution-overlay" class="fixed inset-0 bg-yellow-900/50 opacity-0 transition-opacity duration-1000 ease-in-out pointer-events-none z-10"></div>

<audio id="bg-music" src="nhackimcuong.mp3" loop></audio>
    
<button id="fullscreen-btn" class="ui-button" title="Toàn màn hình" aria-label="Chế độ toàn màn hình">
    <svg id="fullscreen-icon-open" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
    <svg id="fullscreen-icon-close" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
</button>
<button id="back-to-menu-btn" class="ui-button hidden" title="Về màn hình chính" aria-label="Về màn hình chính">
     <i class="fas fa-redo"></i>
</button>

<div id="start-screen">
    <h1 class="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-gray-300 via-white to-gray-400 mb-4">Bão Khói Độc</h1>
    <p class="text-gray-200 italic text-xl md:text-2xl mb-6 max-w-2xl">Cột khói độc đang dâng lên! Hãy phá chúng trước khi quá muộn.</p>
    <p id="slogan-text" class="text-amber-300 text-lg mb-6 max-w-2xl font-semibold h-8"></p>
    
    <div id="highscore-board" class="mb-6 bg-black/20 p-4 rounded-xl border border-white/10 w-full max-w-sm">
        <h2 class="text-2xl font-bold text-yellow-400 mb-2">Bảng Xếp Hạng</h2>
        <ul id="highscore-list" class="text-lg text-white">
            <!-- Điểm cao sẽ được chèn vào đây bằng JS -->
        </ul>
    </div>

    <button id="start-game-btn" class="bg-gray-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">Bắt Đầu</button>
</div>

<div id="tutorial-modal" role="dialog" aria-modal="true" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm" aria-labelledby="tutorial-modal-title">
    <div class="bg-gray-800 border border-gray-700 rounded-2xl p-6 md:p-8 shadow-2xl max-w-md w-full text-white text-center">
        <div id="tutorial-step-smoke-storm">
            <h2 class="text-3xl font-bold text-gray-400 mb-4" id="tutorial-modal-title">Luật Chơi Bão Khói Độc</h2>
            <div class="tutorial-icon text-5xl">☠️</div>
            <p class="text-lg mb-4">Các cột <strong class="text-gray-300">khói độc</strong> sẽ liên tục dâng lên từ dưới đáy.</p>
            <p class="text-lg mb-6">Hãy ghép kim cương để phá tan làn khói và đẩy chúng xuống. Nếu bất kỳ cột khói nào chạm đỉnh, bạn sẽ thua!</p>
            <p class="text-yellow-400 mb-6">Mẹo: Các combo lớn và kim cương đặc biệt sẽ phá được nhiều khói hơn!</p>
            <button id="smoke-storm-tutorial-finish-btn" class="bg-gray-600 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-700 transition-transform hover:scale-105">Sinh Tồn!</button>
        </div>
    </div>
</div>

<div id="custom-cursor"></div>

<div id="game-wrapper">
    <div id="game-ui" class="w-full h-full mx-auto flex flex-row items-center justify-evenly hidden p-4">
        
        <div id="left-panel" class="info-panel flex flex-col">
            <h2 class="text-xl font-bold text-center text-red-400 mb-2">Lá Phổi Bị Hủy Hoại</h2>
            <div id="lung-svg-container" class="w-full h-48 bg-black/20 rounded-lg mb-4 flex items-center justify-center flex-grow">
                 <svg id="lung-svg" width="180" height="220" viewBox="0 0 220 280" class="mx-auto relative z-10 lung-3d">
                    <defs>
                        <radialGradient id="healthyGradient" cx="50%" cy="40%" r="70%">
                            <stop offset="0%" style="stop-color:#ffc1cc;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff6b6b;stop-opacity:1" />
                        </radialGradient>
                        <linearGradient id="healthyStroke" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#ff6b6b;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff4757;stop-opacity:1" />
                        </linearGradient>
                        <linearGradient id="airwayGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                             <stop offset="0%" style="stop-color:#ffc1cc;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff9999;stop-opacity:1" />
                        </linearGradient>
                        <radialGradient id="damagedGradient" cx="50%" cy="40%" r="70%">
                            <stop offset="0%" style="stop-color:#8b8b8b;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#2d2d2d;stop-opacity:1" />
                        </radialGradient>
                        <linearGradient id="damagedStroke" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#2d2d2d;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#1a1a1a;stop-opacity:1" />
                        </linearGradient>
                        <radialGradient id="spotGradient" cx="50%" cy="50%" r="50%">
                            <stop offset="0%" style="stop-color:#000000;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#1a1a1a;stop-opacity:0.9" />
                        </radialGradient>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge> 
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    <!-- Lớp phổi khỏe mạnh (nền) -->
                    <g id="healthy-lung-group">
                        <path class="lung-path lung-healthy" d="M55 70 C35 70, 25 90, 25 110 L25 190 C25 210, 35 230, 55 230 L75 230 C85 230, 90 220, 90 210 L90 190 L90 170 C90 150, 85 130, 80 110 C75 90, 65 70, 55 70 Z"/>
                        <path class="lung-path lung-healthy" d="M155 70 C175 70, 185 90, 185 110 L185 190 C185 210, 175 230, 155 230 L135 230 C125 230, 120 220, 120 210 L120 190 L120 170 C120 150, 125 130, 130 110 C135 90, 145 70, 155 70 Z"/>
                        <rect class="airway airway-healthy" x="100" y="30" width="12" height="70" stroke-width="2" rx="6"/>
                        <path class="airway airway-healthy" d="M106 100 L90 120" stroke-width="4" fill="none"/>
                        <path class="airway airway-healthy" d="M106 100 L120 120" stroke-width="4" fill="none"/>
                    </g>
                    <!-- Lớp phổi bị tổn thương (phủ lên trên) -->
                    <g id="damaged-lung-overlay" style="opacity: 0; transition: opacity 0.5s ease-in-out;">
                        <path class="lung-path lung-damaged" d="M55 70 C35 70, 25 90, 25 110 L25 190 C25 210, 35 230, 55 230 L75 230 C85 230, 90 220, 90 210 L90 190 L90 170 C90 150, 85 130, 80 110 C75 90, 65 70, 55 70 Z"/>
                        <path class="lung-path lung-damaged" d="M155 70 C175 70, 185 90, 185 110 L185 190 C185 210, 175 230, 155 230 L135 230 C125 230, 120 220, 120 210 L120 190 L120 170 C120 150, 125 130, 130 110 C135 90, 145 70, 155 70 Z"/>
                        <rect class="airway airway-damaged" x="100" y="30" width="12" height="70" stroke-width="2" rx="6"/>
                        <path class="airway airway-damaged" d="M106 100 L90 120" stroke-width="4" fill="none"/>
                        <path class="airway airway-damaged" d="M106 100 L120 120" stroke-width="4" fill="none"/>
                    </g>
                     <!-- Lớp đốm tổn thương -->
                    <g id="damage-spots">
                        <circle cx="50" cy="110" r="5" class="spot-3d"/>
                        <circle cx="65" cy="140" r="4" class="spot-3d"/>
                        <circle cx="55" cy="170" r="6" class="spot-3d"/>
                        <circle cx="75" cy="200" r="4" class="spot-3d"/>
                        <circle cx="160" cy="120" r="5" class="spot-3d"/>
                        <circle cx="145" cy="150" r="4" class="spot-3d"/>
                        <circle cx="155" cy="180" r="6" class="spot-3d"/>
                        <circle cx="135" cy="210" r="4" class="spot-3d"/>
                    </g>
                </svg>
            </div>
            <h3 class="text-lg font-bold text-center text-yellow-400 mb-2">Chất Độc Trong Khói Thuốc</h3>
            <div id="chemical-info" class="text-center text-white p-2 bg-black/20 rounded-lg h-32 flex flex-col justify-center"></div>
        </div>

        <div class="flex flex-col items-center justify-end pb-4 gap-2 h-full">
            <div class="text-center">
                <div class="relative" id="game-container" style="width: 500px; height: 500px;">
                    <div id="fact-popup" class="absolute top-1/3 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black/70 border border-yellow-400 text-white p-4 rounded-lg shadow-lg z-30 opacity-0 transition-opacity duration-500 pointer-events-none max-w-sm text-center hidden">
                        <h3 class="font-bold text-lg text-yellow-300 mb-2">Thông Tin Thêm!</h3>
                        <p id="fact-text" class="text-base"></p>
                    </div>
                    <div id="character-container">
                        <div id="monster-name-container" class="absolute z-20 pointer-events-none" style="top: 45px; left: 230px; width: max-content;">
                            <p id="monster-name" class="text-2xl font-bold text-red-400" style="text-shadow: 1px 1px 5px rgba(0,0,0,0.7);"></p>
                        </div>
                        <div class="character-aura"></div>
                        <div id="monster-collection">
                            <svg id="cigarette-svg" viewBox="0 0 200 100">
                                <defs>
                                    <filter id="smokeFilter"><feTurbulence type="fractalNoise" baseFrequency="0.02 0.05" numOctaves="3" result="turbulence" /><feDisplacementMap in2="turbulence" in="SourceGraphic" scale="15" xChannelSelector="R" yChannelSelector="G" /></filter>
                                    <filter id="emberGlow"><feGaussianBlur stdDeviation="3.5" result="coloredBlur" /><feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge></filter>
                                    <radialGradient id="paper-gradient"><stop offset="0%" stop-color="#d2b48c" /><stop offset="100%" stop-color="#c8a97e" /></radialGradient>
                                </defs>
                                <path class="filter-shape" d="M160,30 L180,28 Q192,30 190,50 Q188,70 180,72 L160,70 Z" /><path class="cigarette-body-shape" d="M20,30 L160,30 L160,70 L20,70 Q10,70 10,50 Q10,30 20,30 Z" /><path class="stain" d="M110,40 C 120,35 130,45 125,55 C 120,60 110,55 110,40 Z" /><path class="stain" d="M70,60 C 75,55 85,58 80,68 Z" /><path class="crack" d="M140,45 C 145,50, 145,55, 150,60" /><path class="crack" d="M100,35 C 105,45, 95,55, 100,65" /><path class="crack" d="M40,35 L 45,65" /><path class="crack" d="M155,35 L 158,65" /><path class="ash-shape" d="M20,30 Q10,30 10,50 Q10,70 20,70 L30,70 Q25,50 30,30 Z" /><path d="M28 40 L 32 38 M28 50 L 33 50 M28 60 L 32 62" stroke="#a0522d" stroke-width="1" /><path class="ember-shape" d="M25,35 Q20,50 25,65 L20,65 Q15,50 20,35 Z" /><g id="sparks"><circle class="spark" cx="22" cy="40" r="1.5" style="animation-delay: 0s; --y-end: -20px;"></circle><circle class="spark" cx="20" cy="50" r="1" style="animation-delay: 0.5s; --y-end: 0px;"></circle><circle class="spark" cx="22" cy="60" r="1.5" style="animation-delay: 1s; --y-end: 20px;"></circle></g>
                                <g id="face">
                                    <g id="eye1_group"><circle class="eye-socket" cx="55" cy="50" r="12" /><circle class="eye-ball" cx="55" cy="50" r="11" /><path class="eye-vein" d="M50,50 C 52,47 55,47 57,50" /><path class="eye-vein" d="M57,50 C 59,53 62,53 85,50" /><circle class="eye-pupil" id="pupil1" cx="55" cy="50" r="5" /></g>
                                    <g id="eye2_group"><circle class="eye-socket" cx="80" cy="50" r="12" /><circle class="eye-ball" cx="80" cy="50" r="11" /><path class="eye-vein" d="M75,50 C 77,47 80,47 82,50" /><path class="eye-vein" d="M82,50 C 84,53 87,53 85,50" /><circle class="eye-pupil" id="pupil2" cx="80" cy="50" r="5" /></g>
                                    <path class="mouth" id="mouth-path" d="M60 65 L 64 63 L 68 65 L 72 63 L 76 65" />
                                </g>
                            </svg>
                            <svg id="vape-svg" viewBox="0 0 200 100" class="hidden">
                                 <defs>
                                    <linearGradient id="vape-body-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                        <stop offset="0%" style="stop-color:#3a3a3a" />
                                        <stop offset="50%" style="stop-color:#1a1a1a" />
                                        <stop offset="100%" style="stop-color:#3a3a3a" />
                                    </linearGradient>
                                    <filter id="ledGlow"><feGaussianBlur stdDeviation="2.5" result="coloredBlur" /><feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge></filter>
                                </defs>
                                <!-- Vape Body -->
                                <path d="M50,25 L150,25 Q160,25 160,35 L160,75 Q160,85 150,85 L50,85 Q40,85 40,75 L40,35 Q40,25 50,25 Z" fill="url(#vape-body-gradient)" />
                                <!-- Mouthpiece -->
                                <path d="M20,40 L40,40 L40,70 L20,70 Q15,70 15,60 L15,50 Q15,40 20,40 Z" fill="#505050" />
                                <!-- LED Light -->
                                <circle cx="145" cy="75" r="5" fill="#32CD32" filter="url(#ledGlow)" />
                                 <g id="face-vape">
                                    <g id="eye1_group-vape"><circle class="eye-socket" cx="65" cy="55" r="12" /><circle class="eye-ball" cx="65" cy="55" r="11" /><circle class="eye-pupil" id="pupil1-vape" cx="65" cy="55" r="5" /></g>
                                    <g id="eye2_group-vape"><circle class="eye-socket" cx="95" cy="55" r="12" /><circle class="eye-ball" cx="95" cy="55" r="11" /><circle class="eye-pupil" id="pupil2-vape" cx="95" cy="55" r="5" /></g>
                                    <path class="mouth" id="mouth-path-vape" d="M75 75 Q 85 70 95 75" stroke="#ff4500" stroke-width="2" fill="none" />
                                </g>
                            </svg>
                            <svg id="ht-svg" viewBox="0 0 200 100" class="hidden">
                                <defs>
                                    <linearGradient id="ht-body-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#e0e0e0" />
                                        <stop offset="100%" style="stop-color:#b0b0b0" />
                                    </linearGradient>
                                </defs>
                                <!-- HT Body -->
                                <path d="M40,20 L160,20 Q170,20 170,30 L170,80 Q170,90 160,90 L40,90 Q30,90 30,80 L30,30 Q30,20 40,20 Z" fill="url(#ht-body-gradient)" />
                                <!-- Stick Port -->
                                <circle cx="100" cy="30" r="8" fill="#2a2a2a" />
                                <!-- Status Light -->
                                <rect x="98" y="75" width="4" height="10" fill="#00BFFF" filter="url(#ledGlow)" />
                                <g id="face-ht">
                                    <g id="eye1_group-ht"><path class="eye-socket" d="M55 45 L 75 45 L 70 60 Z" /><path class="eye-ball" d="M60 50 L 70 50 L 67 55 Z" fill="#FF4500" /><circle class="eye-pupil" id="pupil1-ht" cx="65" cy="52" r="3" /></g>
                                    <g id="eye2_group-ht"><path class="eye-socket" d="M125 45 L 145 45 L 130 60 Z" /><path class="eye-ball" d="M130 50 L 140 50 L 133 55 Z" fill="#FF4500" /><circle class="eye-pupil" id="pupil2-ht" cx="135" cy="52" r="3" /></g>
                                    <path class="mouth" id="mouth-path-ht" d="M80 70 L 120 70" stroke-width="3" stroke="black" />
                                </g>
                            </svg>
                        </div>
                        <div class="smoke-container"><div class="smoke-wisp"></div><div class="smoke-wisp"></div><div class="smoke-wisp"></div></div>
                    </div>
                    <canvas id="gameCanvas" role="img" aria-label="Bảng chơi Kim Cương: Phá tan các cột khói độc"></canvas>
                </div>
            </div>
            <div id="top-info-bar" class="flex flex-row gap-4 text-white">
                 <div class="p-2 bg-black/20 rounded-xl shadow-lg text-center backdrop-blur-sm border border-white/10">
                    <p class="text-sm font-bold text-white/70">Thời Gian</p>
                    <p class="text-2xl font-bold text-white" id="smoke-storm-timer">0</p>
                </div>
                <div class="p-2 bg-black/20 rounded-xl shadow-lg text-center backdrop-blur-sm border border-white/10">
                    <p class="text-sm font-bold text-white/70">Điểm</p>
                    <p class="text-2xl font-bold text-white" id="smoke-storm-score">0</p>
                </div>
                <div class="p-2 bg-black/20 rounded-xl shadow-lg text-center backdrop-blur-sm border border-white/10">
                    <p class="text-sm font-bold text-white/70">Cấp Độ</p>
                    <p class="text-2xl font-bold text-white" id="smoke-storm-level">1</p>
                </div>
            </div>
        </div>
        
        <div id="right-panel" class="info-panel">
            <h2 class="text-xl font-bold text-center text-green-400 mb-2">Cơ Thể Hồi Sinh</h2>
            <div id="recovery-timeline" class="text-white mb-4"></div>
            <h3 class="text-lg font-bold text-center text-yellow-400 mb-2">Hỏi - Đáp Nhanh</h3>
            <div id="qa-info" class="text-center text-white p-2 bg-black/20 rounded-lg h-32 flex flex-col justify-center"></div>
        </div>
    </div>
</div>


<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="gameOverModal" role="dialog" aria-modal="true" tabindex="-1" aria-labelledby="gameOverModalTitle">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-red-800 mb-4" id="gameOverModalTitle">Thất Bại!</h2>
        <p class="text-lg text-gray-700 mb-2">Khói độc đã bao trùm!</p>
        <p class="text-xl text-gray-800 mb-8" id="gameOverMessageContainer"></p>
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="gameOverHomeButton">Về Trang Chủ</button>
            <button class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105" id="gameOverRestartButton">Chơi Lại</button>
        </div>
    </div>
</div>

<script>
(function() {
    'use strict';

    // --- MODULE: CONSTANTS & CONFIGURATION ---
    const CONFIG = {
        GRID_SIZE: 8,
        GEM_COLORS: ['#FF3131', '#00FF7F', '#1E90FF', '#FF00FF', '#FF8C00', '#FFFF00'],
        ANIM_SWAP_SPEED: 150,
        ANIM_FALL_SPEED: 400,
        ANIM_CLEAR_SPEED: 200,
        ANIM_SPECIAL_PULSE_SPEED: 150,
        MAX_PARTICLES: 150, 
        HINT_TIMEOUT: 5000,
        WATCHDOG_TIMEOUT: 15000, // Tăng thời gian chờ lên 15 giây
        SMOKE_STORM: {
            // These will now be overridden by level config
            INITIAL_RISE_SPEED: 0.05,
            RISE_ACCELERATION: 0.00002,
            MATCH_REDUCTION: 30,
        }
    };

    const LEVEL_CONFIG = [
        { level: 1, timeToNextLevel: 30, initialRiseSpeed: 0.2, riseAcceleration: 0.00005, initialColumns: 1, maxColumns: 5, newColumnInterval: 15, initialHeightPercentage: 0.10 },
        { level: 2, timeToNextLevel: 60, initialRiseSpeed: 0.3, riseAcceleration: 0.00007, initialColumns: 2, maxColumns: 6, newColumnInterval: 14, initialHeightPercentage: 0.15 },
        { level: 3, timeToNextLevel: 90, initialRiseSpeed: 0.4, riseAcceleration: 0.00009, initialColumns: 3, maxColumns: 7, newColumnInterval: 13, initialHeightPercentage: 0.20 },
        { level: 4, timeToNextLevel: 120, initialRiseSpeed: 0.5, riseAcceleration: 0.00011, initialColumns: 4, maxColumns: 8, newColumnInterval: 12, initialHeightPercentage: 0.25 },
        { level: 5, timeToNextLevel: Infinity, initialRiseSpeed: 0.6, riseAcceleration: 0.00013, initialColumns: 5, maxColumns: 8, newColumnInterval: 10, initialHeightPercentage: 0.30 }
    ];

    const SPECIAL_TYPES = { NONE: 'none', H_BEAM: 'h_beam', V_BEAM: 'v_beam', BOMB: 'bomb', HYPERCUBE: 'hypercube', GREEN_LUNG: 'green_lung' };

    const SLOGANS = [
        "Nói không với khói độc - Bảo vệ tương lai.",
        "Thuốc lá điện tử: Lời mời gọi tử thần.",
        "Đừng để khói thuốc che mờ cuộc sống của bạn.",
        "Một hơi vape, vạn lời từ biệt sức khỏe.",
        "Thuốc lá nung nóng: Nguy cơ tiềm ẩn, đừng thử!"
    ];

    const GAMEOVER_MESSAGES = [
        "Khói độc đã chiến thắng. Mỗi năm, thuốc lá cướp đi sinh mạng của 8 triệu người.",
        "Bạn đã bị bao vây bởi hóa chất độc hại. Thuốc lá điện tử chứa nicotine gây nghiện và nhiều chất gây ung thư.",
        "Lá phổi của bạn đã bị tổn thương. Đừng hút thuốc, dù chỉ một lần.",
        "Trò chơi kết thúc, nhưng cuộc chiến với thuốc lá vẫn tiếp diễn ngoài đời thực."
    ];

    const LEVEL_FACTS = {
        3: "Thuốc lá điện tử (Vape) không vô hại. Nó chứa Nicotine gây nghiện và các hóa chất có thể gây tổn thương phổi vĩnh viễn.",
        5: "Thuốc lá nung nóng vẫn tạo ra các hóa chất độc hại và gây ung thư, tương tự như thuốc lá điếu thông thường."
    };

    const CHEMICAL_FACTS = [
        { name: "Arsenic", use: "Có trong thuốc diệt chuột", icon: "fa-skull-crossbones" },
        { name: "Formaldehyde", use: "Dùng trong dung dịch ướp xác", icon: "fa-vial" },
        { name: "Lead (Chì)", use: "Chất độc hại có trong pin cũ", icon: "fa-car-battery" },
        { name: "Nicotine", use: "Dùng làm thuốc trừ sâu, gây nghiện cao", icon: "fa-bug" }
    ];

    const QA_FACTS = [
        { q: "Vape có an toàn không?", a: "Không. Vape vẫn chứa Nicotine gây nghiện và nhiều hóa chất gây ung thư." },
        { q: "Hút thuốc giúp giảm căng thẳng?", a: "Không. Nicotine chỉ làm bạn lệ thuộc và lo âu hơn khi không có nó." },
        { q: "Thuốc lá 'nhẹ' có ít tác hại hơn?", a: "Không. Người hút có xu hướng hít sâu hơn, gây hại tương đương." }
    ];

    const RECOVERY_MILESTONES = [
        { time: 5, text: "Sau 20 phút: Nhịp tim trở lại bình thường." },
        { time: 20, text: "Sau 12 giờ: Mức Carbon Monoxide trong máu giảm." },
        { time: 40, text: "Sau 2 tuần: Chức năng phổi bắt đầu cải thiện." },
        { time: 60, text: "Sau 1 tháng: Cơn ho và khó thở giảm dần." },
        { time: 80, text: "Sau 1 năm: Nguy cơ mắc bệnh tim mạch giảm một nửa." }
    ];



    // --- MODULE: GAME STATE & DOM ELEMENTS ---
    let DOMElements;
    let gemSize, board = [], selectedGem = null, isAnimating = false;
    let isPaused = false, animations = [], particlePool = [], hintTimeout = null;
    let startDragPos = { x: null, y: null }, startGem = null;
    let isDragging = false, gemCache = {}, hintGems = [];
    let resizeTimer = null, currentModal = null;
    let animationWatchdog = null;
    let smokeColumns = [], currentRiseSpeed = 0, smokeStormTimerInterval = null, smokeStormTime = 0;
    let smokeStormScore = 0, gemsClearedCount = 0, highscores = [], currentLevel = 1;
    let nextColumnSpawnTime = 0;
    let sparkles = []; // Thêm mảng cho hiệu ứng lấp lánh
    let lastClick = { gem: null, time: 0 }; // Theo dõi double-click
    let coughSoundAllowed = true; // Cờ để kiểm soát âm thanh ho
    let lungDamage = 0, lastLungDamage = 0, isDamageFlashAnimating = false;
    let chemicalFactInterval, qaFactInterval;
    let announcedMilestones = new Set();
    let gameScale = 1;


    // --- MODULE: AUDIO MANAGER ---
    const AudioManager = {
        isInitialized: false, isMusicStarted: false, sfxBus: null, sfx: {},
        lastSfxTime: 0,
        sfxTimeOffset: 0.02, // 20ms offset to prevent time collisions
        async init() {
            if (this.isInitialized) return;
            await Tone.start();
            this.sfxBus = new Tone.Volume(-8).toDestination();
            this.sfx.select = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).connect(this.sfxBus);
            this.sfx.match = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.7 }).connect(this.sfxBus);
            this.sfx.bombKick = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).connect(this.sfxBus);
            this.sfx.bombNoise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).connect(this.sfxBus);
            const beamFilter = new Tone.AutoFilter("16n").connect(this.sfxBus).start();
            beamFilter.baseFrequency = 400; beamFilter.octaves = 3;
            this.sfx.beam = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0 } }).connect(beamFilter);
            this.sfx.unlock = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, release: 0.1 } }).connect(this.sfxBus);
            this.sfx.levelUp = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).connect(this.sfxBus);
            this.sfx.wind = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.1, release: 0.5 } }).connect(this.sfxBus);
            this.sfx.milestone = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).connect(this.sfxBus);
            
            const coughFilter = new Tone.Filter(400, "lowpass").connect(this.sfxBus);
            const coughSynth = new Tone.NoiseSynth({
                noise: { type: "brown" },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0, release: 0.1 }
            }).connect(coughFilter);
            const coughEnv = new Tone.FrequencyEnvelope({
                attack: 0.02,
                decay: 0.15,
                release: 0.2,
                baseFrequency: "C2",
                octaves: 3,
            });
            coughEnv.connect(coughFilter.frequency);
            this.sfx.cough = coughSynth;
            this.sfx.coughEnv = coughEnv;

            this.isInitialized = true;
        },
        startMusic() {
            if (!this.isMusicStarted) {
                const music = document.getElementById("bg-music");
                if (music && music.getAttribute('src')) {
                    music.volume = 0.2; 
                    music.play().catch(e => console.warn("Audio play failed:", e.message)); 
                    this.isMusicStarted = true; 
                }
            }
        },
        playSfx(type) {
            if (!this.isInitialized) return;

            const now = Tone.now();
            let scheduleTime = this.lastSfxTime < now ? now : this.lastSfxTime + this.sfxTimeOffset;
            this.lastSfxTime = scheduleTime;

            try {
                switch (type) {
                    case 'select': this.sfx.select.triggerAttackRelease('C7', '32n', scheduleTime); break;
                    case 'match': this.sfx.match.triggerAttackRelease('G5', '8n', scheduleTime); break;
                    case 'bomb': 
                        this.sfx.bombKick.triggerAttackRelease('C2', '8n', scheduleTime); 
                        this.sfx.bombNoise.triggerAttackRelease('16n', scheduleTime + 0.01); 
                        break;
                    case 'unlock': this.sfx.unlock.triggerAttackRelease('A6', '16n', scheduleTime); break;
                    case 'beam': case 'hypercube': this.sfx.beam.triggerAttackRelease('8n', scheduleTime); break;
                    case 'levelUp': this.sfx.levelUp.triggerAttackRelease('C6', '8n', scheduleTime); break;
                    case 'wind': this.sfx.wind.triggerAttackRelease('2n', scheduleTime); break;
                    case 'cough': 
                        this.sfx.coughEnv.triggerAttackRelease("0.2", scheduleTime); 
                        this.sfx.cough.triggerAttackRelease("0.2", scheduleTime); 
                        break;
                    case 'milestone': this.sfx.milestone.triggerAttackRelease('G6', '16n', scheduleTime); break;
                }
            } catch (e) { console.error('SFX error:', e); }
        }
    };

    // --- MODULE: UI & RENDERING ---
    function showModal(modalElement, focusElement) {
        currentModal = modalElement;
        modalElement.classList.remove('hidden');
        setTimeout(() => { 
            const innerDiv = modalElement.querySelector('div');
            if(innerDiv) innerDiv.classList.add('scale-100');
            if (focusElement) focusElement.focus(); 
            trapFocus(modalElement);
        }, 10);
    }

    function hideModal(modalElement) {
        if (modalElement) {
            releaseFocus(modalElement);
            const innerDiv = modalElement.querySelector('div');
            if(innerDiv) innerDiv.classList.remove('scale-100'); 
            setTimeout(() => modalElement.classList.add('hidden'), 200); 
        }
        currentModal = null;
    }
    
    function trapFocus(modal) {
      if (!modal) return;
      const focusables = modal.querySelectorAll('button, a, input, textarea, [tabindex]:not([tabindex="-1"])');
      if (!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      function keyHandler(e) { if (e.key === 'Tab') { if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); } else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); } } }
      modal._keyHandler = keyHandler;
      modal.addEventListener('keydown', keyHandler);
    }
    
    function releaseFocus(modal) {
      if (modal && modal._keyHandler) {
          modal.removeEventListener('keydown', modal._keyHandler);
          delete modal._keyHandler;
      }
    }

    function showGameOver() {
        if (animationWatchdog) clearTimeout(animationWatchdog);
        isAnimating = true; isPaused = true; 
        if (smokeStormTimerInterval) clearInterval(smokeStormTimerInterval);
        
        saveHighscores();
        displayHighscores();

        const randomMessage = GAMEOVER_MESSAGES[Math.floor(Math.random() * GAMEOVER_MESSAGES.length)];
        DOMElements.gameOverMessageContainer.innerHTML = `Bạn đạt <span class="font-bold text-yellow-500">${smokeStormScore}</span> điểm. <br/> <span class="text-base text-gray-600 mt-2 block">${randomMessage}</span>`;
        showModal(DOMElements.gameOverModal, DOMElements.gameOverModal.querySelector('#gameOverRestartButton'));
    }

    function createSparkle(x, y) {
        if (sparkles.length > 50) return; // Giới hạn số lượng lấp lánh
        const life = Math.random() * 60 + 30; // Thời gian tồn tại: 30-90 khung hình
        sparkles.push({
            x: x + (Math.random() - 0.5) * gemSize * 0.5,
            y: y + (Math.random() - 0.5) * gemSize * 0.5,
            life: life,
            initialLife: life,
            size: Math.random() * 2 + 1,
        });
    }

    function drawSparkles(time) {
        const { ctx } = DOMElements;
        for (let i = sparkles.length - 1; i >= 0; i--) {
            const s = sparkles[i];
            s.life--;
            if (s.life <= 0) {
                sparkles.splice(i, 1);
            } else {
                const progress = s.life / s.initialLife;
                const alpha = Math.sin(progress * Math.PI); // Mờ dần vào và ra
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                // Vẽ hình ngôi sao 4 cánh
                ctx.moveTo(s.x, s.y - s.size);
                ctx.lineTo(s.x + s.size, s.y);
                ctx.lineTo(s.x, s.y + s.size);
                ctx.lineTo(s.x - s.size, s.y);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
    }

    function update3DLungs(damage) {
        if (!DOMElements.damagedLungOverlay || !DOMElements.lungSpots) return;

        // Đặt độ mờ của lớp phổi bị tổn thương.
        // Sử dụng đường cong lũy thừa để thiệt hại ban đầu tinh tế hơn và tăng tốc về cuối.
        const overlayOpacity = Math.pow(damage, 1.5);
        DOMElements.damagedLungOverlay.style.opacity = overlayOpacity.toFixed(2);

        // Hiển thị hoặc ẩn các đốm tổn thương.
        const spotsToShow = Math.floor(damage * DOMElements.lungSpots.length);
        DOMElements.lungSpots.forEach((spot, index) => {
            // Chuyển đổi trạng thái hiển thị dựa trên số lượng đốm cần hiển thị.
            spot.classList.toggle('visible', index < spotsToShow);
        });
    }

    function updateRecoveryTimeline(time) {
        const timelineEl = DOMElements.recoveryTimeline;
        if (!timelineEl) return;
        
        let content = '';
        RECOVERY_MILESTONES.forEach(milestone => {
            const isAchieved = time >= milestone.time;
             if (isAchieved && !announcedMilestones.has(milestone.time)) {
                AudioManager.playSfx('milestone');
                announcedMilestones.add(milestone.time);
            }
            content += `<div class="recovery-milestone ${isAchieved ? 'achieved' : ''}"><p>${milestone.text}</p></div>`;
        });
        timelineEl.innerHTML = content;
    }


    function drawBoard(time) {
        const { ctx } = DOMElements;
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                const gem = board[row][col];
                if (!gem) continue;
                ctx.save();
                ctx.globalAlpha = gem.alpha;
                const centerX = gem.x + gemSize / 2, centerY = gem.y + gemSize / 2;
                ctx.translate(centerX, centerY); ctx.scale(gem.scale, gem.scale); ctx.translate(-centerX, -centerY);
                let cacheKey = gem.special === SPECIAL_TYPES.HYPERCUBE ? SPECIAL_TYPES.HYPERCUBE : 
                             gem.special === SPECIAL_TYPES.GREEN_LUNG ? SPECIAL_TYPES.GREEN_LUNG :
                             (gem.special !== SPECIAL_TYPES.NONE ? `${gem.special}_${gem.colorIndex}` : CONFIG.GEM_COLORS[gem.colorIndex]);
                if (gemCache[cacheKey]) ctx.drawImage(gemCache[cacheKey], gem.x, gem.y, gemSize, gemSize);
                if (gem.isLocked) ctx.drawImage(gemCache['chain'], gem.x, gem.y, gemSize, gemSize);
                ctx.restore();

                // Thêm hiệu ứng lấp lánh ngẫu nhiên
                if (!isAnimating && Math.random() < 0.001) { // Tỷ lệ xuất hiện thấp cho mỗi khung hình
                    createSparkle(gem.x + gemSize / 2, gem.y + gemSize / 2);
                }
            }
        }
    }

    function drawSmokeColumns(time) {
        const { ctx, canvas } = DOMElements;
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            const smokeHeight = smokeColumns[c];
            if (smokeHeight <= 0) continue;

            const columnPadding = 1;
            const x = c * gemSize + columnPadding;
            const columnWidth = gemSize - (columnPadding * 2);
            const topY = canvas.height - smokeHeight;

            // Gradient mới, trông "ảo diệu" và độc hại hơn
            const mainGradient = ctx.createLinearGradient(x, canvas.height, x, topY);
            mainGradient.addColorStop(0, 'rgba(48, 25, 52, 0.85)'); // Tím đậm ở đáy
            mainGradient.addColorStop(0.6, 'rgba(0, 100, 0, 0.5)');   // Xanh lá cây đậm ở giữa
            mainGradient.addColorStop(1, 'rgba(144, 238, 144, 0.1)'); // Xanh lá nhạt trong suốt ở đỉnh

            ctx.fillStyle = mainGradient;
            ctx.beginPath();
            ctx.moveTo(x, canvas.height);
            for (let i = 0; i <= columnWidth; i++) {
                const waveX = x + i;
                const waveY = topY + Math.sin(waveX / 20 + time / 300 + c) * 8 + Math.cos(waveX / 15 + time / 400) * 5;
                ctx.lineTo(waveX, waveY);
            }
            ctx.lineTo(x + columnWidth, canvas.height);
            ctx.closePath();
            ctx.fill();

            // Thêm các hạt bong bóng bay lên trong cột khói
            const bubbleCount = 5;
            for (let i = 0; i < bubbleCount; i++) {
                // Sử dụng hàm băm đơn giản để có vị trí và tốc độ ổn định cho mỗi bong bóng
                const seed = c * bubbleCount + i;
                const bubbleX = x + (Math.sin(seed * 1.23) * 0.5 + 0.5) * columnWidth;
                const speedFactor = (Math.cos(seed * 2.34) * 0.5 + 0.5) * 0.5 + 0.5; // Tốc độ khác nhau
                const initialOffsetY = (Math.sin(seed * 3.45) * 0.5 + 0.5) * smokeHeight;
                
                let bubbleY = canvas.height - (( (time * speedFactor) + initialOffsetY) % smokeHeight);

                // Chỉ vẽ bong bóng nếu nó nằm trong phạm vi cột khói
                if (bubbleY > topY) {
                    const radius = (Math.cos(seed * 4.56) * 0.5 + 0.5) * (gemSize / 15) + 2;
                    const opacity = (1 - ( (canvas.height - bubbleY) / smokeHeight)) * 0.8; // Mờ dần khi lên cao
                    
                    ctx.beginPath();
                    ctx.arc(bubbleX, bubbleY, radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(173, 255, 47, ${opacity})`; // Màu xanh nõn chuối
                    ctx.fill();
                }
            }
            
            // Thêm hiệu ứng tia điện "toxic"
            if (Math.random() < 0.05) { // Tỷ lệ xuất hiện tia điện mỗi khung hình
                ctx.save();
                ctx.strokeStyle = 'rgba(173, 255, 47, 0.6)'; // Màu xanh nõn chuối
                ctx.lineWidth = Math.random() * 2 + 1;
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                const startX = x + Math.random() * columnWidth;
                ctx.moveTo(startX, canvas.height);
                let currentY = canvas.height;
                while(currentY > topY) {
                    currentY -= (Math.random() * 20 + 10);
                    const currentX = startX + (Math.random() - 0.5) * 20;
                    ctx.lineTo(currentX, Math.max(topY, currentY));
                }
                ctx.stroke();
                ctx.restore();
            }

            const warningEl = document.getElementById(`smoke-warning-${c}`);
            if (warningEl) {
                warningEl.classList.toggle('visible', smokeHeight >= canvas.height - (gemSize / 2));
            }
        }
    }

    function drawHint(time) {
        if (hintGems.length === 2 && !isAnimating) {
            const [gem1, gem2] = hintGems;
            const pulse = (Math.sin(time / 200) + 1) / 2;
            const scale = 1 + 0.05 * pulse;
            const drawPulse = (gem) => {
                if (!gem) return;
                const { ctx } = DOMElements;
                ctx.save();
                const centerX = gem.x + gemSize / 2, centerY = gem.y + gemSize / 2;
                ctx.translate(centerX, centerY); ctx.scale(scale, scale); ctx.translate(-centerX, -centerY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`; ctx.lineWidth = 4;
                ctx.strokeRect(gem.x + 2, gem.y + 2, gemSize - 4, gemSize - 4);
                ctx.restore();
            };
            drawPulse(gem1); drawPulse(gem2);
        }
    }

    function drawParticles() {
        const { ctx } = DOMElements;
        for (let i = particlePool.length - 1; i >= 0; i--) {
            const p = particlePool[i];
            if (!p.active) continue;
            p.x += p.vx; p.y += p.vy; p.alpha -= 0.02;
            if (p.alpha <= 0) { p.active = false; } 
            else {
                ctx.save(); ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }
    }

    function drawSelection(time) {
        if (selectedGem) {
            const { ctx } = DOMElements;
            const pulse = Math.sin(time / 100) * 0.5 + 0.5;
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`; ctx.lineWidth = 4;
            ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
        }
    }

    async function preRenderGems() {
        gemCache = {}; const promises = []; const specials = Object.values(SPECIAL_TYPES); const size = Math.max(1, Math.round(gemSize));
        CONFIG.GEM_COLORS.forEach((col) => { const canvas = renderGemCanvas(col, size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[col] = img; })); } else { gemCache[col] = canvas; } });
        specials.forEach(special => {
            if (special === SPECIAL_TYPES.HYPERCUBE) { const canvas = renderHypercubeCanvas(size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[special] = img; })); } else { gemCache[special] = canvas; } } 
            else if (special === SPECIAL_TYPES.GREEN_LUNG) { const canvas = renderGreenLungCanvas(size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[special] = img; })); } else { gemCache[special] = canvas; } }
            else if (special !== SPECIAL_TYPES.NONE) { CONFIG.GEM_COLORS.forEach((col, idx) => { const canvas = renderSpecialCanvas(special, col, size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[`${special}_${idx}`] = img; })); } else { gemCache[`${special}_${idx}`] = canvas; } }); }
        });
        const chainCanvas = renderChainCanvas(size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(chainCanvas).then(img => { gemCache['chain'] = img; })); } else { gemCache['chain'] = canvas; }
        await Promise.all(promises);
    }
    
    function renderGemCanvas(color, size) {
        const offscreenCanvas = document.createElement('canvas'); offscreenCanvas.width = size; offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        
        // Thêm hiệu ứng vầng sáng để làm nổi bật kim cương
        offscreenCtx.shadowColor = 'rgba(255, 255, 255, 0.7)';
        offscreenCtx.shadowBlur = 10;

        const shadeColor = (col, percent) => { let f = parseInt(col.slice(1), 16), t = percent < 0 ? 0 : 255, p = Math.abs(percent), R = f >> 16, G = (f >> 8) & 0xff, B = f & 0xff; const hex = (0x1000000 + (Math.round((t-R)*p)+R)*0x10000 + (Math.round((t-G)*p)+G)*0x100 + (Math.round((t-B)*p)+B)).toString(16).slice(1); return `#${hex.padStart(6,'0')}`; };
        const lightColor = shadeColor(color, 0.6), darkColor = shadeColor(color, -0.6);
        const grad = offscreenCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, half); grad.addColorStop(0, lightColor); grad.addColorStop(1, color);
        offscreenCtx.fillStyle = grad; offscreenCtx.beginPath(); offscreenCtx.moveTo(centerX, centerY - half); offscreenCtx.lineTo(centerX + half, centerY); offscreenCtx.lineTo(centerX, centerY + half); offscreenCtx.lineTo(centerX - half, centerY); offscreenCtx.closePath(); offscreenCtx.fill();
        
        // Bỏ hiệu ứng bóng cho đường viền để giữ độ sắc nét
        offscreenCtx.shadowColor = 'transparent';

        offscreenCtx.strokeStyle = darkColor; offscreenCtx.lineWidth = 2; offscreenCtx.stroke();
        return offscreenCanvas;
    }

    function renderGreenLungCanvas(size) {
        const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        ctx.shadowColor = 'rgba(144, 238, 144, 0.9)';
        ctx.shadowBlur = 15;
        // Draw a simple leaf shape
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - size * 0.4);
        ctx.quadraticCurveTo(centerX + size * 0.5, centerY, centerX, centerY + size * 0.4);
        ctx.quadraticCurveTo(centerX - size * 0.5, centerY, centerX, centerY - size * 0.4);
        ctx.fillStyle = "rgba(60, 179, 113, 0.9)";
        ctx.fill();
        // Vein
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - size * 0.3);
        ctx.lineTo(centerX, centerY + size * 0.3);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 1;
        ctx.stroke();
        return canvas;
    }

    function renderSpecialCanvas(special, color, size) {
        const canvas = renderGemCanvas(color, size); const ctx = canvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        ctx.fillStyle = 'white'; ctx.shadowColor = 'white'; ctx.shadowBlur = 10;
        if(special === SPECIAL_TYPES.H_BEAM) { ctx.fillRect(centerX - half, centerY - half * 0.1, s, half * 0.2); } 
        else if (special === SPECIAL_TYPES.V_BEAM) { ctx.fillRect(centerX - half * 0.1, centerY - half, half * 0.2, s); } 
        else if (special === SPECIAL_TYPES.BOMB) { ctx.fillStyle = `rgba(255, 255, 255, 0.8)`; ctx.beginPath(); ctx.arc(centerX, centerY, half * 0.6, 0, 2 * Math.PI); ctx.fill(); }
        return canvas;
    }

    function renderHypercubeCanvas(size) {
        const offscreenCanvas = document.createElement('canvas'); offscreenCanvas.width = size; offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        offscreenCtx.shadowColor = 'rgba(255, 255, 255, 0.7)'; offscreenCtx.shadowBlur = 10;
        for (let i = 0; i < 6; i++) { offscreenCtx.fillStyle = CONFIG.GEM_COLORS[i]; offscreenCtx.beginPath(); offscreenCtx.moveTo(centerX,centerY); const angle1 = (i / 6) * 2 * Math.PI, angle2 = ((i+1) / 6) * 2 * Math.PI; offscreenCtx.arc(centerX,centerY, half, angle1, angle2); offscreenCtx.closePath(); offscreenCtx.fill(); }
        return offscreenCanvas;
    }

    function renderChainCanvas(size) {
        const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d'); const p = size * 0.1, lw = size * 0.08;
        ctx.strokeStyle = 'rgba(200, 200, 220, 0.7)'; ctx.lineWidth = lw; ctx.lineCap = 'round'; ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 4;
        ctx.beginPath(); ctx.moveTo(p, p); ctx.lineTo(size - p, size - p); ctx.moveTo(size - p, p); ctx.lineTo(p, size - p); ctx.stroke();
        return canvas;
    }
    
    // --- MODULE: CORE GAME LOGIC ---
    async function handleSuccessfulMove() {
        if (!hasPossibleMoves(board)) {
            await reshuffleBoard();
        }
    }

    async function triggerSpecialCombo(gemA, gemB) {
        const gemsToClear = new Set([gemA, gemB]);
        const { row, col } = gemA;
        const typeA = gemA.special;
        const typeB = gemB.special;
        const isBomb = (type) => type === SPECIAL_TYPES.BOMB;
        const isBeam = (type) => type === SPECIAL_TYPES.H_BEAM || type === SPECIAL_TYPES.V_BEAM;
        if (isBomb(typeA) && isBomb(typeB)) {
            AudioManager.playSfx('bomb');
            for (let r = row - 2; r <= row + 2; r++) { for (let c = col - 2; c <= col + 2; c++) { if (r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) { gemsToClear.add(board[r][c]); } } }
        }
        else if (isBeam(typeA) && isBeam(typeB)) {
             AudioManager.playSfx('beam');
             for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (board[row][c]) gemsToClear.add(board[row][c]); }
             for (let r = 0; r < CONFIG.GRID_SIZE; r++) { if (board[r][col]) gemsToClear.add(board[r][col]); }
        }
        else if ((isBomb(typeA) && isBeam(typeB)) || (isBeam(typeA) && isBomb(typeB))) {
            AudioManager.playSfx('bomb'); AudioManager.playSfx('beam');
            for (let r = row - 1; r <= row + 1; r++) { if (r >= 0 && r < CONFIG.GRID_SIZE) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (board[r][c]) gemsToClear.add(board[r][c]); } } }
            for (let c = col - 1; c <= col + 1; c++) { if (c >= 0 && c < CONFIG.GRID_SIZE) { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { if (board[r][c]) gemsToClear.add(board[r][c]); } } }
        }
        if (gemsToClear.size > 2) {
            await cascadeMatches([], Array.from(gemsToClear));
        }
    }

    async function processSwap(gem1, gem2) {
        if (isAnimating || isPaused || gem1.isLocked || gem2.isLocked) return;
        isAnimating = true; 
        selectedGem = null;
        if (animationWatchdog) clearTimeout(animationWatchdog);
        animationWatchdog = setTimeout(() => {
            console.error("WATCHDOG: Game logic took too long. Forcing state reset.");
            isAnimating = false; isPaused = false; resetHintTimer();
        }, CONFIG.WATCHDOG_TIMEOUT);
        try {
            const isHyperCombo = gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE;
            const isSpecialCombo = gem1.special !== SPECIAL_TYPES.NONE && gem2.special !== SPECIAL_TYPES.NONE;
            if (isHyperCombo) {
                const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
                const otherGem = hypercube === gem1 ? gem2 : gem1;
                await triggerHypercube(hypercube, otherGem);
                await handleSuccessfulMove();
            } else if (isSpecialCombo) {
                await swapGems(gem1, gem2);
                await triggerSpecialCombo(gem1, gem2);
                await handleSuccessfulMove();
            } else {
                const startPos1 = { row: gem1.row, col: gem1.col }, startPos2 = { row: gem2.row, col: gem2.col };
                await swapGems(gem1, gem2);
                const matchInfo = findMatchesAndSpecial(startPos1, startPos2);
                if (matchInfo.allMatchGroups.length > 0) {
                    await cascadeMatches(matchInfo.allMatchGroups, [], matchInfo.specialToCreate);
                    await handleSuccessfulMove();
                } else {
                    await sleep(100);
                    await swapGems(gem1, gem2);
                }
            }
        } catch(error) { 
            console.error("Error during swap process:", error); 
        } finally {
            clearTimeout(animationWatchdog);
            isAnimating = false;
            resetHintTimer();
        }
    }

    async function cascadeMatches(initialMatchGroups, additionalGemsToClear = [], specialToCreate = null) {
        try {
            let allInitialGems = [...new Set([...initialMatchGroups.flat(), ...(additionalGemsToClear || [])])];
            let gemsToClear = new Set(allInitialGems);
            let processedSpecials = new Set();
            
            let greenLungEffect = false;
            for (const gem of gemsToClear) {
                if (gem.special === SPECIAL_TYPES.GREEN_LUNG) {
                    greenLungEffect = true;
                    break; 
                }
            }
            if (greenLungEffect) {
                AudioManager.playSfx('wind');
                for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                    if (smokeColumns[c] > 0) {
                        smokeColumns[c] = Math.max(0, smokeColumns[c] - (DOMElements.canvas.height / 3));
                    }
                }
            }

            while (true) {
                let newGemsFromExplosion = new Set();
                let foundNewExplosion = false;
                for (const gem of gemsToClear) {
                    if (gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                        foundNewExplosion = true;
                        processedSpecials.add(gem);
                        switch (gem.special) {
                            case SPECIAL_TYPES.H_BEAM: case SPECIAL_TYPES.V_BEAM: AudioManager.playSfx('beam'); break;
                            case SPECIAL_TYPES.BOMB: AudioManager.playSfx('bomb'); break;
                        }
                        getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                    }
                }
                if (!foundNewExplosion) break;
                newGemsFromExplosion.forEach(g => gemsToClear.add(g));
            }
            
            await handleMatches(initialMatchGroups, Array.from(gemsToClear), specialToCreate);
            await sleep(150);
            await shiftAndRefill();
            
            const newMatchGroups = findMatches(board, true);
            if (newMatchGroups.length > 0) {
                await cascadeMatches(newMatchGroups, [], findSpecialFromCascade(newMatchGroups));
            }
        } catch (err) { 
            console.error('Error in cascadeMatches:', err); 
            if (!currentModal) { 
                isAnimating = false; 
                isPaused = false; 
                resetHintTimer(); 
            } 
        }
    }

    async function activateGreenLung(gem) {
        if (isAnimating || isPaused) return;
        isAnimating = true;

        AudioManager.playSfx('wind');
        
        // Animate the gem before removing
        await animate(gem, { scale: 1.5, alpha: 0.5 }, 200);

        // Push back all smoke columns
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            if (smokeColumns[c] > 0) {
                smokeColumns[c] = Math.max(0, smokeColumns[c] - (DOMElements.canvas.height / 3));
            }
        }

        // Remove the gem from the board
        board[gem.row][gem.col] = null;
        
        // Trigger the board to refill
        await shiftAndRefill();

        // Check for new matches after refill
        const newMatchGroups = findMatches(board, true);
        if (newMatchGroups.length > 0) {
            await cascadeMatches(newMatchGroups, [], findSpecialFromCascade(newMatchGroups));
        }

        isAnimating = false;
        resetHintTimer();
    }


    async function handleMatches(matchGroups, allGemsToClear, specialToCreate) {
        if (allGemsToClear.length > 0) AudioManager.playSfx('match');

        const handledGems = new Set();
        // --- Áp dụng luật phá khói mới ---
        for (const group of matchGroups) {
            if (group.length === 3) {
                const isVertical = group[0].col === group[1].col;
                const isHorizontal = group[0].row === group[1].row;
                if (isVertical) {
                    const col = group[0].col;
                    if (smokeColumns[col] >= 0) {
                        smokeColumns[col] = 0; // Phá hủy hoàn toàn cột khói
                    }
                    group.forEach(g => handledGems.add(g));
                } else if (isHorizontal) {
                    group.forEach(gem => {
                        if (smokeColumns[gem.col] >= 0) {
                            smokeColumns[gem.col] /= 2; // Giảm một nửa cột khói
                        }
                        handledGems.add(gem);
                    });
                }
            }
        }
        
        // --- Logic xóa kim cương và giảm khói thông thường ---
        const promises = [];
        let unlockedGems = new Set();
        allGemsToClear.forEach(gem => {
            const neighbors = [{ r: gem.row - 1, c: gem.col }, { r: gem.row + 1, c: gem.col }, { r: gem.row, c: gem.col - 1 }, { r: gem.row, c: gem.col + 1 }];
            neighbors.forEach(n => { if (n.r >= 0 && n.r < CONFIG.GRID_SIZE && n.c >= 0 && n.c < CONFIG.GRID_SIZE) { const neighborGem = board[n.r][n.c]; if (neighborGem && neighborGem.isLocked) unlockedGems.add(neighborGem); } });
        });

        for (const gem of unlockedGems) {
            gem.isLocked = false;
            promises.push((async () => { await animate(gem, { scale: 1.2 }, 100); await animate(gem, { scale: 1 }, 100); })());
        }
        if (unlockedGems.size > 0) AudioManager.playSfx('unlock');

        allGemsToClear.forEach(gem => {
            if (!gem || !board[gem.row] || board[gem.row][gem.col] !== gem) return;
            if (specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) return;
            
            // Giảm khói chung cho các viên không thuộc luật match-3 đặc biệt (áp dụng cho bom, tia sáng, match 4, 5)
            if (!handledGems.has(gem)) {
                if (smokeColumns[gem.col] >= 0) {
                    const reduction = CONFIG.SMOKE_STORM.MATCH_REDUCTION * (gem.special !== 'none' ? 2 : 1);
                    smokeColumns[gem.col] = Math.max(0, smokeColumns[gem.col] - reduction);
                }
            }

            gemsClearedCount++;
            createParticleBurst(gem.x + gemSize / 2, gem.y + gemSize / 2, CONFIG.GEM_COLORS[gem.colorIndex]);
            promises.push(new Promise(async (resolve) => {
                if (gem) {
                    await animate(gem, { scale: 0, alpha: 0 }, CONFIG.ANIM_CLEAR_SPEED, easing.easeInQuad).catch(console.error);
                    if (board[gem.row] && board[gem.row][gem.col] === gem) board[gem.row][gem.col] = null;
                } resolve();
            }));
        });

        // Logic giảm khói cho các cột liền kề
        const clearedColumns = new Set(allGemsToClear.map(gem => gem.col));
        const adjacentColumnsToReduce = new Set();

        clearedColumns.forEach(col => {
            // Cột bên trái
            if (col > 0 && !clearedColumns.has(col - 1) && smokeColumns[col - 1] >= 0) {
                adjacentColumnsToReduce.add(col - 1);
            }
            // Cột bên phải
            if (col < CONFIG.GRID_SIZE - 1 && !clearedColumns.has(col + 1) && smokeColumns[col + 1] >= 0) {
                adjacentColumnsToReduce.add(col + 1);
            }
        });

        adjacentColumnsToReduce.forEach(col => {
            smokeColumns[col] = Math.max(0, smokeColumns[col] - CONFIG.SMOKE_STORM.MATCH_REDUCTION);
        });
        
        smokeStormScore = (smokeStormTime * 5) + (gemsClearedCount * 5); // Adjusted score calculation
        DOMElements.smokeStormScoreEl.textContent = smokeStormScore;

        await Promise.all(promises);
        if (specialToCreate) {
            let gem = board[specialToCreate.row] && board[specialToCreate.row][specialToCreate.col];
            if (!gem) {
                gem = { row: specialToCreate.row, col: specialToCreate.col, x: specialToCreate.col * gemSize, y: specialToCreate.row * gemSize, colorIndex: specialToCreate.colorIndex ?? Math.floor(Math.random() * CONFIG.GEM_COLORS.length), isHeart: false, isLocked: false, special: SPECIAL_TYPES.NONE, scale: 0, alpha: 1 };
                board[specialToCreate.row][specialToCreate.col] = gem;
            }
            gem.special = specialToCreate.special;
            if (specialToCreate.special !== SPECIAL_TYPES.HYPERCUBE) gem.colorIndex = specialToCreate.colorIndex;
            await animate(gem, { scale: 1.5 }, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad);
            await animate(gem, { scale: 1 }, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad);
        }
    }


    function findMatches(currentBoard, returnGroups = false) { const matches = new Set(); const groups = []; for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE - 2;) { const gem = currentBoard[r][c]; if (gem) { let match = [gem]; for (let i = c + 1; i < CONFIG.GRID_SIZE; i++) { const nextGem = currentBoard[r][i]; if (nextGem && nextGem.colorIndex === gem.colorIndex) { match.push(nextGem); } else { break; } } if (match.length >= 3) { match.forEach(m => matches.add(m)); if (returnGroups) groups.push(match); } c += match.length > 1 ? match.length : 1; } else { c++; } } } for (let c = 0; c < CONFIG.GRID_SIZE; c++) { for (let r = 0; r < CONFIG.GRID_SIZE - 2;) { const gem = currentBoard[r][c]; if (gem) { let match = [gem]; for (let i = r + 1; i < CONFIG.GRID_SIZE; i++) { const nextGem = currentBoard[i][c]; if (nextGem && nextGem.colorIndex === gem.colorIndex) { match.push(nextGem); } else { break; } } if (match.length >= 3) { match.forEach(m => matches.add(m)); if (returnGroups) groups.push(match); } r += match.length > 1 ? match.length : 1; } else { r++; } } } return returnGroups ? groups : Array.from(matches); }
    function findSpecialFromCascade(matchGroups) { let bestSpecial = null; let bestRank = 0; let processedInGroups = new Set(); for (const group of matchGroups) { if (group.length >= 5) { const middleGem = group[Math.floor(group.length / 2)]; if (processedInGroups.has(middleGem)) continue; bestRank = 3; bestSpecial = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: middleGem.colorIndex, row: middleGem.row, col: middleGem.col }; group.forEach(g => processedInGroups.add(g)); return bestSpecial; } } for (let i = 0; i < matchGroups.length; i++) { for (let j = i + 1; j < matchGroups.length; j++) { const group1 = matchGroups[i]; const group2 = matchGroups[j]; const intersection = group1.find(gem1 => group2.some(gem2 => gem1 === gem2)); if (intersection && !processedInGroups.has(intersection)) { if (bestRank < 2) { bestRank = 2; bestSpecial = { special: SPECIAL_TYPES.BOMB, colorIndex: intersection.colorIndex, row: intersection.row, col: intersection.col }; group1.forEach(g => processedInGroups.add(g)); group2.forEach(g => processedInGroups.add(g)); } } } } if (bestRank < 2) { for (const group of matchGroups) { if (group.length === 4) { const gemToReplace = group[1]; if (processedInGroups.has(gemToReplace)) continue; if (bestRank < 1) { bestRank = 1; const isHorizontal = group[0].row === group[1].row; bestSpecial = { special: isHorizontal ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: gemToReplace.colorIndex, row: gemToReplace.row, col: gemToReplace.col }; group.forEach(g => processedInGroups.add(g)); } } } } return bestSpecial; }
    
    function findMatchesAndSpecial(startPos1, startPos2) {
        const checkLine = (line) => {
            const res = [];
            for (let i = 0; i < line.length - 2; i++) {
                const g = line[i];
                if (!g) continue;
                let len = 1;
                while (i + len < line.length && line[i + len] && line[i + len].colorIndex === g.colorIndex) len++;
                if (len >= 3) {
                    const matchGroup = line.slice(i, i + len);
                    res.push(matchGroup);
                    i += len - 1;
                }
            }
            return res;
        };

        const h1 = checkLine(board[startPos1.row] || []);
        const v1 = checkLine(board.map(r => r[startPos1.col]) || []);
        const h2 = checkLine(board[startPos2.row] || []);
        const v2 = checkLine(board.map(r => r[startPos2.col]) || []);

        const allMatchGroups = [];
        const seenGroups = new Set();
        [...h1, ...v1, ...h2, ...v2].forEach(group => {
            const key = group.map(g => `${g.row},${g.col}`).sort().join('-');
            if (!seenGroups.has(key)) {
                allMatchGroups.push(group);
                seenGroups.add(key);
            }
        });
        
        const allMatchesFlat = allMatchGroups.flat();
        let specialToCreate = null;
        let intersectionGem = null;
        const movedGem = board[startPos1.row][startPos1.col];
        const otherGem = board[startPos2.row][startPos2.col];
        const checkGems = [movedGem, otherGem];

        for (const gem of checkGems) {
            if (!gem || !allMatchesFlat.includes(gem)) continue;
            const horizontalMatch = allMatchesFlat.filter(g => g.row === gem.row && g.colorIndex === gem.colorIndex);
            const verticalMatch = allMatchesFlat.filter(g => g.col === gem.col && g.colorIndex === gem.colorIndex);
            if (horizontalMatch.length >= 3 && verticalMatch.length >= 3) {
                intersectionGem = gem;
                break;
            }
        }

        if (intersectionGem) {
            specialToCreate = { special: SPECIAL_TYPES.BOMB, colorIndex: intersectionGem.colorIndex, row: intersectionGem.row, col: intersectionGem.col };
        } else {
            const relevantGroups = allMatchGroups.filter(group => group.some(g => g === movedGem || g === otherGem));
            relevantGroups.sort((a, b) => b.length - a.length);

            if (relevantGroups.length > 0) {
                const longestMatch = relevantGroups[0];
                const pivotGem = longestMatch.includes(movedGem) ? movedGem : otherGem;
                if (longestMatch.length >= 5) {
                    specialToCreate = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: pivotGem.colorIndex, row: pivotGem.row, col: pivotGem.col };
                } else if (longestMatch.length === 4) {
                    const isHorizontal = longestMatch[0].row === longestMatch[1].row;
                    specialToCreate = { special: isHorizontal ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: pivotGem.colorIndex, row: pivotGem.row, col: pivotGem.col };
                }
            }
        }
        return { allMatchGroups, specialToCreate };
    }

    async function shiftAndRefill() { 
        const shiftPromises = []; 
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) { 
            let emptySlots = 0; 
            for (let r = CONFIG.GRID_SIZE - 1; r >= 0; r--) { 
                if (board[r][c] === null) { 
                    emptySlots++; 
                } else if (emptySlots > 0) { 
                    const gem = board[r][c]; 
                    board[r + emptySlots][c] = gem; 
                    board[r][c] = null; 
                    gem.row += emptySlots; 
                    shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300, easing.easeOutQuad)); 
                } 
            } 
        } 
        await Promise.all(shiftPromises); 
        
        const refillPromises = []; 
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) { 
            for (let r = 0; r < CONFIG.GRID_SIZE; r++) { 
                if (board[r][c] === null) { 
                    const newGem = { 
                        colorIndex: Math.floor(Math.random() * CONFIG.GEM_COLORS.length), 
                        isLocked: false, 
                        special: SPECIAL_TYPES.NONE, 
                        row: r, 
                        col: c, 
                        x: c * gemSize, 
                        y: (r - CONFIG.GRID_SIZE) * gemSize, 
                        scale: 1, 
                        alpha: 1, 
                    };
                    
                    if (Math.random() < 0.02) { // 2% chance to spawn a green lung
                        newGem.special = SPECIAL_TYPES.GREEN_LUNG;
                        newGem.colorIndex = -1; // No color for this special type
                    }
                    
                    board[r][c] = newGem; 
                    refillPromises.push(animate(newGem, { y: r * gemSize }, CONFIG.ANIM_FALL_SPEED, easing.easeOutQuad)); 
                } 
            } 
        } 
        await Promise.all(refillPromises); 
    }

    async function reshuffleBoard() { isAnimating = true; const promises = []; board.flat().forEach(gem => { if (gem) { promises.push(animate(gem, { alpha: 0, scale: 0 }, 300)); } }); await Promise.all(promises); let attempts = 0; do { createBoard(); attempts++; if (attempts > 100) { console.error("Could not generate a board with possible moves."); break; } } while (!hasPossibleMoves(board)); const refillPromises = []; board.flat().forEach(gem => { if (gem) { gem.alpha = 0; gem.scale = 0; refillPromises.push(animate(gem, { alpha: 1, scale: 1 }, 300)); } }); await Promise.all(refillPromises); isAnimating = false; resetHintTimer(); }
        
    function handlePointerStart(e) { 
        e.preventDefault(); 
        if (isAnimating || isPaused) return; 
        resetHintTimer(); 
        hintGems = []; 
        const pos = getEventPos(e); 
        const col = Math.floor(pos.x / gemSize); 
        const row = Math.floor(pos.y / gemSize); 
        if (row < 0 || row >= CONFIG.GRID_SIZE || col < 0 || col >= CONFIG.GRID_SIZE) { 
            selectedGem = null; return; 
        } 
        const clickedGem = board[row][col]; 
        
        if (clickedGem.isLocked) { 
            AudioManager.playSfx('unlock'); 
            return; 
        }

        // Logic mới: Kích hoạt Lá Phổi Xanh bằng cách nhấn đúp
        if (clickedGem.special === SPECIAL_TYPES.GREEN_LUNG) {
            const now = performance.now();
            if (lastClick.gem === clickedGem && (now - lastClick.time) < 300) { // Ngưỡng 300ms cho double click
                activateGreenLung(clickedGem);
                lastClick = { gem: null, time: 0 }; // Reset sau khi kích hoạt
                return;
            } else {
                lastClick = { gem: clickedGem, time: now };
                return; // Ngăn không cho chọn để hoán đổi sau lần click đầu tiên
            }
        }

        isDragging = true; 
        startDragPos = pos; 
        startGem = clickedGem; 
        if (selectedGem) { 
            if (selectedGem === clickedGem) { 
                selectedGem = null; 
                return; 
            } 
            const isAdjacent = Math.abs(selectedGem.row - clickedGem.row) + Math.abs(selectedGem.col - clickedGem.col) === 1; 
            if (isAdjacent) { 
                processSwap(selectedGem, clickedGem); 
            } else { 
                AudioManager.playSfx('select'); 
                selectedGem = clickedGem; 
            } 
        } else { 
            AudioManager.playSfx('select'); 
            selectedGem = clickedGem; 
        } 
    }
    function handlePointerMove(e) { e.preventDefault(); if (!isDragging || isAnimating || isPaused) return; const pos = getEventPos(e); const deltaX = pos.x - startDragPos.x; const deltaY = pos.y - startDragPos.y; if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) { let endGem = null; if (Math.abs(deltaX) > Math.abs(deltaY)) { const endCol = startGem.col + (deltaX > 0 ? 1 : -1); if (endCol >= 0 && endCol < CONFIG.GRID_SIZE) { endGem = board[startGem.row][endCol]; } } else { const endRow = startGem.row + (deltaY > 0 ? 1 : -1); if (endRow >= 0 && endRow < CONFIG.GRID_SIZE) { endGem = board[endRow][startGem.col]; } } if (endGem && !endGem.isLocked && startGem !== endGem) { isDragging = false; selectedGem = null; processSwap(startGem, endGem); } } }
    function handlePointerEnd(e) { isDragging = false; startGem = null; }
    const easing = { easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t, easeInQuad: t => t * t, easeOutQuad: t => t * (2 - t) }; function animate(target, toProperties, duration, easeFunc = easing.easeInOutQuad) { return new Promise(resolve => { const startProps = {}; const endProps = {}; for (const key in toProperties) { const cur = typeof target[key] === 'number' && !isNaN(target[key]) ? target[key] : 0; startProps[key] = cur; endProps[key] = Number(toProperties[key]); } animations.push({ target, startProperties: startProps, endProperties: endProps, duration, easeFunc, startTime: performance.now(), onComplete: resolve }); }); }
    function handleAnimations(time) { const now = performance.now(); for (let i = animations.length - 1; i >= 0; i--) { const anim = animations[i]; const elapsed = now - (anim.startTime || now); const duration = Number(anim.duration) || 0; const t = duration > 0 ? Math.min(elapsed / duration, 1) : 1; const progress = (typeof anim.easeFunc === 'function') ? anim.easeFunc(t) : t; if (t >= 1) { for (const key in anim.endProperties) { if (anim.target) anim.target[key] = anim.endProperties[key]; } try { if (anim.onComplete) anim.onComplete(); } catch (err) { console.error('Error in animation onComplete:', err); } animations.splice(i, 1); } else { for (const key in anim.endProperties) { if (anim.target) { const start = anim.startProperties[key] || 0; const end = anim.endProperties[key]; anim.target[key] = start + (end - start) * progress; } } } } }
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    function toggleFullScreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`); }); } else { if (document.exitFullscreen) { document.exitFullscreen(); } } }
    function updateFullscreenIcons() { const fullscreenIconOpen = document.getElementById('fullscreen-icon-open'); const fullscreenIconClose = document.getElementById('fullscreen-icon-close'); if (document.fullscreenElement) { fullscreenIconOpen.classList.add('hidden'); fullscreenIconClose.classList.remove('hidden'); } else { fullscreenIconOpen.classList.remove('hidden'); fullscreenIconClose.classList.add('hidden'); } }
    function getParticle() { for (let i = 0; i < particlePool.length; i++) { if (!particlePool[i].active) return particlePool[i]; } return null; }
    function createParticleBurst(x, y, color) { for (let i = 0; i < 10; i++) { const p = getParticle(); if (p) { p.active = true; p.x = x; p.y = y; p.vx = (Math.random() - 0.5) * 6; p.vy = (Math.random() - 0.5) * 6; p.size = Math.random() * 4 + 2; p.color = color; p.alpha = 1; } } }
    async function resizeCanvas() { 
        const container = DOMElements.canvas.parentElement;
        if (!container) return;
        const containerWidth = container.clientWidth;
        const dpr = window.devicePixelRatio || 1; 
        DOMElements.canvas.style.width = containerWidth + 'px'; 
        DOMElements.canvas.style.height = containerWidth + 'px'; 
        DOMElements.canvas.width = Math.floor(containerWidth * dpr); 
        DOMElements.canvas.height = Math.floor(containerWidth * dpr); 
        DOMElements.ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
        gemSize = containerWidth / CONFIG.GRID_SIZE; 
        await preRenderGems(); 
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if(board[r] && board[r][c]) { board[r][c].x = c * gemSize; board[r][c].y = r * gemSize; } } } 
    }
    
    function scaleGame() {
        const wrapper = DOMElements.gameWrapper;
        const nativeWidth = 1280;
        const nativeHeight = 720;

        const { innerWidth, innerHeight } = window;
        
        const scaleX = innerWidth / nativeWidth;
        const scaleY = innerHeight / nativeHeight;

        gameScale = Math.min(scaleX, scaleY);
        
        wrapper.style.transform = `scale(${gameScale})`;
        wrapper.style.left = `${(innerWidth - (nativeWidth * gameScale)) / 2}px`;
        wrapper.style.top = `${(innerHeight - (nativeHeight * gameScale)) / 2}px`;
    }

    function onResizeDebounced() { 
        if (resizeTimer) clearTimeout(resizeTimer); 
        resizeTimer = setTimeout(() => { 
            resizeCanvas(); 
            scaleGame();
        }, 150); 
    }
    function createBoard() { board = []; for (let row = 0; row < CONFIG.GRID_SIZE; row++) { board[row] = []; for (let col = 0; col < CONFIG.GRID_SIZE; col++) { let possibleColors = Array.from({ length: CONFIG.GEM_COLORS.length }, (_, i) => i); if (col >= 2 && board[row][col-1].colorIndex === board[row][col-2].colorIndex) { const colorToRemove = board[row][col-1].colorIndex; possibleColors = possibleColors.filter(c => c !== colorToRemove); } if (row >= 2 && board[row-1][col].colorIndex === board[row-2][col].colorIndex) { const colorToRemove = board[row-1][col].colorIndex; possibleColors = possibleColors.filter(c => c !== colorToRemove); } const colorIndex = possibleColors[Math.floor(Math.random() * possibleColors.length)]; board[row][col] = { colorIndex: colorIndex, isLocked: false, special: SPECIAL_TYPES.NONE, row: row, col: col, x: col * gemSize, y: row * gemSize, scale: 1, alpha: 1 }; } } }
    function swapGems(gem1, gem2) { const r1 = gem1.row, c1 = gem1.col; const r2 = gem2.row, c2 = gem2.col; board[r1][c1] = gem2; board[r2][c2] = gem1; gem1.row = r2; gem1.col = c2; gem2.row = r1; gem2.col = c1; const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad); const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad); return Promise.all([p1, p2]); }
    function getSpecialEffectGems(gem) { let affected = new Set(); if (gem.special === SPECIAL_TYPES.H_BEAM) { for(let c=0; c<CONFIG.GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); } } else if (gem.special === SPECIAL_TYPES.V_BEAM) { for(let r=0; r<CONFIG.GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); } } else if (gem.special === SPECIAL_TYPES.BOMB) { for(let r = gem.row - 1; r <= gem.row + 1; r++) { for(let c = gem.col - 1; c <= gem.col + 1; c++) { if(r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) { affected.add(board[r][c]); } } } } return affected; }
    async function triggerHypercube(hypercube, otherGem) {
        AudioManager.playSfx('hypercube');
        let gemsToClear = new Set([hypercube, otherGem]);
        if (otherGem.special === SPECIAL_TYPES.HYPERCUBE) {
            board.flat().forEach(g => { if (g) gemsToClear.add(g); });
        }
        else if (otherGem.special !== SPECIAL_TYPES.NONE) {
            const specialTypeToCreate = otherGem.special;
            const targetColorIndex = otherGem.colorIndex;
            const transformationPromises = [];
            board.flat().forEach(g => {
                if (g && g.colorIndex === targetColorIndex) {
                    g.special = specialTypeToCreate;
                    transformationPromises.push(animate(g, { scale: 1.2 }, 100).then(() => animate(g, { scale: 1 }, 100)));
                    gemsToClear.add(g);
                }
            });
            await Promise.all(transformationPromises);
        }
        else {
            const targetColorIndex = otherGem.colorIndex;
            board.flat().forEach(g => {
                if (g && g.colorIndex === targetColorIndex) {
                    gemsToClear.add(g);
                }
            });
        }
        await cascadeMatches([], Array.from(gemsToClear));
    }
    function hasPossibleMoves(currentBoard) { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (c < CONFIG.GRID_SIZE - 1) { const gem1 = currentBoard[r][c]; const gem2 = currentBoard[r][c+1]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [currentBoard[r][c], currentBoard[r][c+1]] = [gem2, gem1]; const matches = findMatches(currentBoard); [currentBoard[r][c], currentBoard[r][c+1]] = [gem1, gem2]; if (matches.length > 0) return true; } if (r < CONFIG.GRID_SIZE - 1) { const gem1 = currentBoard[r][c]; const gem2 = currentBoard[r+1][c]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [currentBoard[r][c], currentBoard[r+1][c]] = [gem2, gem1]; const matches = findMatches(currentBoard); [currentBoard[r][c], currentBoard[r+1][c]] = [gem1, gem2]; if (matches.length > 0) return true; } } } return false; }
    function findFirstPossibleMove() { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (c < CONFIG.GRID_SIZE - 1) { const gem1 = board[r][c]; const gem2 = board[r][c+1]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [board[r][c], board[r][c+1]] = [gem2, gem1]; const matches = findMatches(board); [board[r][c], board[r][c+1]] = [gem1, gem2]; if (matches.length > 0) return { gem1, gem2 }; } if (r < CONFIG.GRID_SIZE - 1) { const gem1 = board[r][c]; const gem2 = board[r+1][c]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [board[r][c], board[r+1][c]] = [gem2, gem1]; const matches = findMatches(board); [board[r][c], board[r+1][c]] = [gem1, gem2]; if (matches.length > 0) return { gem1, gem2 }; } } } return null; }
    function resetHintTimer() { if (hintTimeout) clearTimeout(hintTimeout); hintGems = []; hintTimeout = setTimeout(() => { if (!isAnimating && !isPaused) { const move = findFirstPossibleMove(); if (move) { hintGems = [move.gem1, move.gem2]; } } }, CONFIG.HINT_TIMEOUT); }
    function getEventPos(e) {
        const rect = DOMElements.canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const x = (clientX - rect.left) / gameScale;
        const y = (clientY - rect.top) / gameScale;
        return { x, y };
    }
    
    function loadHighscores() {
        const savedScores = localStorage.getItem('smokeStormHighscores');
        highscores = savedScores ? JSON.parse(savedScores) : [];
    }

    function displayHighscores() {
        const listEl = DOMElements.highscoreListEl;
        listEl.innerHTML = '';
        if (highscores.length === 0) {
            listEl.innerHTML = '<li>Chưa có kỷ lục nào!</li>';
        } else {
            highscores.forEach((score, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span class="font-bold text-yellow-300 mr-2">#${index + 1}</span> ${score} điểm`;
                listEl.appendChild(li);
            });
        }
    }

    function saveHighscores() {
        highscores.push(smokeStormScore);
        highscores.sort((a, b) => b - a); // Sắp xếp điểm từ cao đến thấp
        highscores = highscores.slice(0, 3); // Chỉ giữ lại 3 điểm cao nhất
        localStorage.setItem('smokeStormHighscores', JSON.stringify(highscores));
    }
    
    function trackPupil(pupilElement, e) {
        if (!DOMElements || !DOMElements.characterContainerEl) return;
        const svgRect = DOMElements.characterContainerEl.getBoundingClientRect();
        if (!svgRect || svgRect.width === 0) return;
        const pupilData = { cx: parseFloat(pupilElement.getAttribute('cx')), cy: parseFloat(pupilElement.getAttribute('cy')) }; 
        const pupilX = svgRect.left + (pupilData.cx / 200) * svgRect.width; 
        const pupilY = svgRect.top + (pupilData.cy / 100) * svgRect.height; 
        const angle = Math.atan2(e.clientY - pupilY, e.clientX - pupilX); 
        const maxMove = 4; 
        const moveX = Math.cos(angle) * maxMove; 
        const moveY = Math.sin(angle) * maxMove; 
        pupilElement.setAttribute('transform', `translate(${moveX} ${moveY})`);
    }

    function updateMonsterPosition() { 
        const columnCenter = (CONFIG.GRID_SIZE / 2 * gemSize);
        const svgScaledWidth = 240 * 0.7; // Use width from CSS
        const translateX = columnCenter - (svgScaledWidth / 2);
        let scale = 0.7;
        DOMElements.characterContainerEl.style.transform = `translateX(${translateX}px) scale(${scale})`; 
    }
        
    function updateMonsterVisuals() {
        const cigarette = DOMElements.cigaretteSvg;
        const vape = DOMElements.vapeSvg;
        const ht = DOMElements.htSvg;
        const monsterNameEl = DOMElements.monsterNameEl;

        // Hide all
        cigarette.classList.add('hidden');
        vape.classList.add('hidden');
        ht.classList.add('hidden');

        if (currentLevel <= 2) {
            cigarette.classList.remove('hidden');
            monsterNameEl.textContent = "Quái vật Thuốc Lá";
        } else if (currentLevel <= 4) {
            vape.classList.remove('hidden');
            monsterNameEl.textContent = "Quái vật Vape";
        } else {
            ht.classList.remove('hidden');
            monsterNameEl.textContent = "Quái vật Thuốc Lá Nung Nóng";
        }
    }


    async function initSmokeStormMode() {
        // Khởi tạo canvas cho lá phổi trước

        await resizeCanvas();
        DOMElements.ctx.font = `${gemSize * 0.7}px sans-serif`;
        createBoard();
        while (!hasPossibleMoves(board)) { createBoard(); }
        
        selectedGem = null; isAnimating = false; isPaused = false; animations = [];
        particlePool = []; for (let i = 0; i < CONFIG.MAX_PARTICLES; i++) { particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', alpha: 0 }); }
        
        currentLevel = 1;
        announcedMilestones = new Set();
        const levelConfig = LEVEL_CONFIG[currentLevel - 1];
        nextColumnSpawnTime = smokeStormTime + levelConfig.newColumnInterval;

        smokeColumns = [], smokeStormTimerInterval = null, smokeStormTime = 0;
        smokeStormScore = 0, gemsClearedCount = 0;
        lungDamage = 0;
        lastLungDamage = 0;
        isDamageFlashAnimating = false;
        DOMElements.smokeStormScoreEl.textContent = 0;
        DOMElements.smokeStormLevelEl.textContent = currentLevel;

        // Use an array to track active columns
        let activeColumns = [];
        while(activeColumns.length < levelConfig.initialColumns) {
            let randomIndex = Math.floor(Math.random() * CONFIG.GRID_SIZE);
            if(!activeColumns.includes(randomIndex)) {
                activeColumns.push(randomIndex);
            }
        }
        
        const oldWarnings = DOMElements.gameContainer.querySelectorAll('.smoke-column-warning');
        oldWarnings.forEach(w => w.remove());

        const initialSmokeHeight = DOMElements.canvas.height * (levelConfig.initialHeightPercentage || 0);

        for (let i = 0; i < CONFIG.GRID_SIZE; i++) {
            smokeColumns.push(activeColumns.includes(i) ? initialSmokeHeight : -1); // -1 for inactive

            const warningDiv = document.createElement('div');
            warningDiv.id = `smoke-warning-${i}`;
            warningDiv.className = 'smoke-column-warning';
            const gameContainerRect = DOMElements.gameContainer.getBoundingClientRect();
            const canvasRect = DOMElements.canvas.getBoundingClientRect();
            const topOffset = canvasRect.top - gameContainerRect.top;
            warningDiv.style.top = `${topOffset}px`;
            warningDiv.style.left = `${i * gemSize}px`;
            warningDiv.style.width = `${gemSize}px`;
            DOMElements.gameContainer.appendChild(warningDiv);
        }
        currentRiseSpeed = levelConfig.initialRiseSpeed;
        CONFIG.SMOKE_STORM.RISE_ACCELERATION = levelConfig.riseAcceleration;

        smokeStormTime = 0;
        DOMElements.smokeStormTimerEl.textContent = smokeStormTime;

        if (smokeStormTimerInterval) clearInterval(smokeStormTimerInterval);
        smokeStormTimerInterval = setInterval(() => {
            if (isPaused) return;
            smokeStormTime++;
            DOMElements.smokeStormTimerEl.textContent = smokeStormTime;

            // Logic mới để thêm cột khói theo thời gian
            const levelConfig = LEVEL_CONFIG[Math.min(currentLevel - 1, LEVEL_CONFIG.length - 1)];
            const activeColumnCount = smokeColumns.filter(c => c >= 0).length;

            if (smokeStormTime >= nextColumnSpawnTime && activeColumnCount < levelConfig.maxColumns) {
                const inactiveColumns = smokeColumns.map((val, idx) => val === -1 ? idx : -1).filter(idx => idx !== -1);
                if (inactiveColumns.length > 0) {
                    const randomIndex = Math.floor(Math.random() * inactiveColumns.length);
                    const colIndex = inactiveColumns[randomIndex];
                    if (colIndex !== undefined) {
                        smokeColumns[colIndex] = 0; // Kích hoạt một cột mới ở dưới cùng
                    }
                }
                // Đặt thời gian cho lần xuất hiện tiếp theo
                nextColumnSpawnTime = smokeStormTime + levelConfig.newColumnInterval;
            }
        }, 1000);
       
       // Khởi tạo trạng thái ban đầu cho phổi 3D
        if (DOMElements.damagedLungOverlay) {
            DOMElements.damagedLungOverlay.style.opacity = 0;
        }
        if (DOMElements.lungSpots) {
            DOMElements.lungSpots.forEach(spot => spot.classList.remove('visible'));
        }


        updateMonsterPosition();
        updateMonsterVisuals();
        startInfoCyclers(); // Bắt đầu chu kỳ hiển thị thông tin
        requestAnimationFrame(gameLoop);
        resetHintTimer();
    }

    function levelUp() {
        currentLevel++;
        const levelConfig = LEVEL_CONFIG[Math.min(currentLevel - 1, LEVEL_CONFIG.length - 1)]; // Dùng cấp cuối nếu vượt quá
        
        nextColumnSpawnTime = smokeStormTime + levelConfig.newColumnInterval;

        DOMElements.smokeStormLevelEl.textContent = currentLevel;
        currentRiseSpeed = levelConfig.initialRiseSpeed;
        CONFIG.SMOKE_STORM.RISE_ACCELERATION = levelConfig.riseAcceleration; // Cập nhật gia tốc
        updateMonsterVisuals();
        
        // Hiển thị thông tin thực tế khi lên cấp
        if (LEVEL_FACTS[currentLevel]) {
            const factPopup = DOMElements.factPopup;
            const factText = DOMElements.factText;
            factText.textContent = LEVEL_FACTS[currentLevel];
            factPopup.classList.remove('hidden');
            setTimeout(() => {
                factPopup.style.opacity = '1';
                setTimeout(() => {
                    factPopup.style.opacity = '0';
                     setTimeout(() => factPopup.classList.add('hidden'), 500);
                }, 5000); // Hiển thị trong 5 giây
            }, 10);
        }
        
        AudioManager.playSfx('levelUp');

        // Hiệu ứng hình ảnh nhỏ
        DOMElements.smokeStormLevelEl.classList.add('animate-pulse', 'text-yellow-400');
        setTimeout(() => {
             DOMElements.smokeStormLevelEl.classList.remove('animate-pulse', 'text-yellow-400');
        }, 1500);
    }

    function gameLoop(time) { 
        requestAnimationFrame(gameLoop); 
        handleAnimations(time); 
        const { ctx, canvas } = DOMElements; 
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        
        if (!isPaused) {
            // Level up check
            const levelConfig = LEVEL_CONFIG[Math.min(currentLevel - 1, LEVEL_CONFIG.length - 1)];
            if (smokeStormTime >= levelConfig.timeToNextLevel) {
                levelUp();
            }

            let totalSmokeHeight = 0;
            let activeColumnCount = 0;
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if (smokeColumns[c] >= 0) {
                    totalSmokeHeight += smokeColumns[c];
                    activeColumnCount++;
                }
            }

            if (coughSoundAllowed && activeColumnCount > 0 && (totalSmokeHeight / activeColumnCount) > (DOMElements.canvas.height * 0.66)) {
                AudioManager.playSfx('cough');
                coughSoundAllowed = false;
                setTimeout(() => { coughSoundAllowed = true; }, 500); // Thêm thời gian chờ 500ms
            }

            // Cập nhật hiệu ứng ô nhiễm môi trường và lá phổi
            if (activeColumnCount > 0) {
                const avgSmokeHeight = totalSmokeHeight / activeColumnCount;
                const pollutionLevel = Math.min(avgSmokeHeight / (DOMElements.canvas.height * 0.8), 1); // 0.8 để hiệu ứng rõ hơn
                DOMElements.pollutionOverlay.style.opacity = (pollutionLevel * 0.4).toFixed(2);
                lungDamage = pollutionLevel;
            } else {
                DOMElements.pollutionOverlay.style.opacity = 0;
                lungDamage = 0;
            }

            // Check for damage increase to trigger flash effect
            if (lungDamage > lastLungDamage && !isDamageFlashAnimating && lungDamage > 0.05) {
                isDamageFlashAnimating = true;
                DOMElements.lungSvg.classList.add('damage-flash');
                setTimeout(() => {
                    DOMElements.lungSvg.classList.remove('damage-flash');
                    isDamageFlashAnimating = false;
                }, 1000); // Animation duration is 1s
            }
            lastLungDamage = lungDamage;


            currentRiseSpeed += CONFIG.SMOKE_STORM.RISE_ACCELERATION;
            let gameOver = false;
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if (smokeColumns[c] !== -1) { // Chỉ tăng các cột đang hoạt động
                    smokeColumns[c] += currentRiseSpeed;
                    if (smokeColumns[c] >= canvas.height) {
                        smokeColumns[c] = canvas.height;
                        gameOver = true;
                    }
                }
            }
            if (gameOver) {
                showGameOver();
            }
        }

        drawBoard(time); 
        drawSparkles(time);
        drawSmokeColumns(time);
        drawParticles(); 
        drawSelection(time); 
        drawHint(time); 
        update3DLungs(lungDamage);
        updateRecoveryTimeline(smokeStormTime);
    }
    
    function restartGame() {
        hideModal(DOMElements.gameOverModal);
        const warnings = DOMElements.gameContainer.querySelectorAll('.smoke-column-warning');
        warnings.forEach(w => w.remove());
        if (chemicalFactInterval) clearInterval(chemicalFactInterval);
        if (qaFactInterval) clearInterval(qaFactInterval);
        announcedMilestones = new Set();
        initSmokeStormMode();
    }

    function startInfoCyclers() {
        // Chu kỳ cho thông tin chất độc
        let chemicalIndex = 0;
        const chemicalInfoEl = DOMElements.chemicalInfo;
        const cycleChemicals = () => {
            const fact = CHEMICAL_FACTS[chemicalIndex];
            chemicalInfoEl.innerHTML = `<div class="text-4xl text-yellow-300 mb-2"><i class="fas ${fact.icon}"></i></div><div><p class="font-bold text-lg">${fact.name}</p><p class="text-sm">${fact.use}</p></div>`;
            chemicalIndex = (chemicalIndex + 1) % CHEMICAL_FACTS.length;
        };
        if (chemicalFactInterval) clearInterval(chemicalFactInterval);
        chemicalFactInterval = setInterval(cycleChemicals, 7000);
        cycleChemicals();

        // Chu kỳ cho Hỏi - Đáp
        let qaIndex = 0;
        const qaInfoEl = DOMElements.qaInfo;
        const cycleQA = () => {
            const fact = QA_FACTS[qaIndex];
            qaInfoEl.innerHTML = `<p class="font-bold text-base text-yellow-300">Hỏi:</p><p class="text-sm mb-2">${fact.q}</p><p class="font-bold text-base text-green-400">Đáp:</p><p class="text-sm">${fact.a}</p>`;
            qaIndex = (qaIndex + 1) % QA_FACTS.length;
        };
        if (qaFactInterval) clearInterval(qaFactInterval);
        qaFactInterval = setInterval(cycleQA, 8000);
        cycleQA();
    }


    // --- MODULE: EVENT LISTENERS & INITIALIZATION ---
    window.addEventListener('DOMContentLoaded', () => {
        DOMElements = {
            gameWrapper: document.getElementById('game-wrapper'),
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            gameOverModal: document.getElementById('gameOverModal'),
            gameOverMessageContainer: document.getElementById('gameOverMessageContainer'),
            startScreen: document.getElementById('start-screen'),
            gameUI: document.getElementById('game-ui'),
            customCursor: document.getElementById('custom-cursor'),
            tutorialModal: document.getElementById('tutorial-modal'),
            startGameBtn: document.getElementById('start-game-btn'),
            backToMenuBtn: document.getElementById('back-to-menu-btn'),
            gameContainer: document.getElementById('game-container'),
            smokeStormTimerEl: document.getElementById('smoke-storm-timer'),
            smokeStormScoreEl: document.getElementById('smoke-storm-score'),
            smokeStormLevelEl: document.getElementById('smoke-storm-level'),
            smokeStormTutorialFinishBtn: document.getElementById('smoke-storm-tutorial-finish-btn'),
            characterContainerEl: document.getElementById('character-container'),
            cigaretteSvg: document.getElementById('cigarette-svg'),
            vapeSvg: document.getElementById('vape-svg'),
            htSvg: document.getElementById('ht-svg'),
            monsterNameEl: document.getElementById('monster-name'),
            pupil1: document.getElementById('pupil1'),
            pupil2: document.getElementById('pupil2'),
            highscoreBoardEl: document.getElementById('highscore-board'),
            highscoreListEl: document.getElementById('highscore-list'),
            gameOverHomeButton: document.getElementById('gameOverHomeButton'),
            sloganTextEl: document.getElementById('slogan-text'),
            pollutionOverlay: document.getElementById('pollution-overlay'),
            factPopup: document.getElementById('fact-popup'),
            factText: document.getElementById('fact-text'),
            lungSvg: document.getElementById('lung-svg'),
            healthyLungGroup: document.getElementById('healthy-lung-group'),
            damagedLungOverlay: document.getElementById('damaged-lung-overlay'),
            lungSpots: document.querySelectorAll('#damage-spots .spot-3d'),
            recoveryTimeline: document.getElementById('recovery-timeline'),
            chemicalInfo: document.getElementById('chemical-info'),
            qaInfo: document.getElementById('qa-info'),
        };

        function attachCanvasListeners() {
            const { canvas } = DOMElements; 
            if (!canvas.dataset.listenersAdded) { 
                const eventOptions = { passive: false };
                canvas.addEventListener('pointerdown', handlePointerStart, eventOptions); 
                canvas.addEventListener('pointermove', handlePointerMove, eventOptions); 
                canvas.addEventListener('pointerup', handlePointerEnd, eventOptions); 
                canvas.addEventListener('pointercancel', handlePointerEnd, eventOptions); 
                canvas.addEventListener('touchstart', handlePointerStart, eventOptions);
                canvas.addEventListener('touchmove', handlePointerMove, eventOptions);
                canvas.addEventListener('touchend', handlePointerEnd, eventOptions);
                canvas.addEventListener('touchcancel', handlePointerEnd, eventOptions);
                window.addEventListener('resize', onResizeDebounced); 
                canvas.dataset.listenersAdded = '1'; 
            } 
        }

        let firstInteraction = true;
        async function handleFirstInteraction() { if (firstInteraction) { firstInteraction = false; await AudioManager.init(); AudioManager.startMusic(); } }
        
        function startSmokeStormMode() {
            DOMElements.startScreen.style.display = 'none';
            DOMElements.gameUI.classList.remove('hidden');
            DOMElements.gameUI.classList.add('flex');
            DOMElements.backToMenuBtn.classList.remove('hidden');
            scaleGame();
            initSmokeStormMode();
            attachCanvasListeners();
        }

        DOMElements.startGameBtn.addEventListener('click', () => { 
            handleFirstInteraction(); 
            DOMElements.startScreen.style.display = 'none';
            showModal(DOMElements.tutorialModal, DOMElements.smokeStormTutorialFinishBtn);
        });
        
        DOMElements.smokeStormTutorialFinishBtn.addEventListener('click', () => { 
            hideModal(DOMElements.tutorialModal); 
            startSmokeStormMode(); 
        });

        document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
        DOMElements.backToMenuBtn.addEventListener('click', () => window.location.reload());
        DOMElements.gameOverHomeButton.addEventListener('click', () => window.location.reload());
        document.getElementById('gameOverRestartButton').addEventListener('click', restartGame);
        
        document.addEventListener('fullscreenchange', updateFullscreenIcons);
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && currentModal) { const closeButton = currentModal.querySelector('button'); if (closeButton) closeButton.click(); } });
        
        if (!window.matchMedia('(pointer: coarse)').matches) {
            document.body.style.cursor = 'none'; 
            if(DOMElements.customCursor) DOMElements.customCursor.style.display = 'block';
            if(DOMElements.canvas) DOMElements.canvas.style.cursor = 'none';
            let rafScheduled = false, lastMouseEvent = null;
            document.addEventListener('mousemove', (e) => {
                lastMouseEvent = e;
                if (!rafScheduled) { 
                    rafScheduled = true; 
                    requestAnimationFrame(() => { 
                        if (lastMouseEvent && DOMElements.customCursor) { 
                            DOMElements.customCursor.style.left = lastMouseEvent.clientX + 'px'; 
                            DOMElements.customCursor.style.top = lastMouseEvent.clientY + 'px'; 
                        } 
                        if (DOMElements.pupil1 && DOMElements.pupil2) {
                            trackPupil(DOMElements.pupil1, lastMouseEvent);
                            trackPupil(DOMElements.pupil2, lastMouseEvent);
                        }
                        // Track pupils for other monsters if they are visible
                        if (!DOMElements.vapeSvg.classList.contains('hidden')) {
                            trackPupil(document.getElementById('pupil1-vape'), lastMouseEvent);
                            trackPupil(document.getElementById('pupil2-vape'), lastMouseEvent);
                        }
                        if (!DOMElements.htSvg.classList.contains('hidden')) {
                             trackPupil(document.getElementById('pupil1-ht'), lastMouseEvent);
                             trackPupil(document.getElementById('pupil2-ht'), lastMouseEvent);
                        }
                        rafScheduled = false; 
                    }); 
                }
            });
        }
        loadHighscores();
        displayHighscores();
        const randomSlogan = SLOGANS[Math.floor(Math.random() * SLOGANS.length)];
        DOMElements.sloganTextEl.textContent = randomSlogan;
        window.addEventListener('resize', scaleGame);
        scaleGame();
    });
    window.addEventListener('beforeunload', () => { if (smokeStormTimerInterval) clearInterval(smokeStormTimerInterval); if (hintTimeout) clearTimeout(hintTimeout); if(animationWatchdog) clearTimeout(animationWatchdog); });
})(); 
</script>
</body>
</html>





















