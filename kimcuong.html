<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Game Kim C∆∞∆°ng: B·∫£o V·ªá Tr√°i Tim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #4a5568; /* gray-700 */
        }
        canvas {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .danger-zone {
            position: absolute;
            top: -10px;
            left: 0;
            right: 0;
            height: 50px;
            z-index: 10;
            pointer-events: none;
        }
        #cigarette-sprite {
            position: absolute;
            top: -50px;
            transition: left 0.3s ease-in-out;
            width: 120px;
            height: 120px;
            display: flex;
            justify-content: center;
            align-items: center;
            filter: drop-shadow(0 3px 5px rgba(0,0,0,0.5));
        }
        .cigarette-body {
            position: relative;
            width: 80px;
            height: 24px;
            transform: rotate(-20deg);
        }
        .cigar-main {
            position: absolute;
            left: 0;
            top: 0;
            width: 75%;
            height: 100%;
            background: linear-gradient(to bottom, #ffffff, #e2e8f0);
            border: 1px solid #94a3b8;
            border-right: none;
            border-radius: 4px 0 0 4px;
        }
        .cigar-ash {
            position: absolute;
            left: -6px;
            top: -2px;
            width: 12px;
            height: 28px;
            background: linear-gradient(to right, #475569, #94a3b8, #64748b);
            border-radius: 50%;
            box-shadow: 0 0 5px #f97316, 0 0 8px #f97316;
        }
        .cigar-filter {
            position: absolute;
            right: 0;
            top: 0;
            width: 25%;
            height: 100%;
            background: linear-gradient(to bottom, #f59e0b, #b45309);
            border: 1px solid #92400e;
            border-left: 2px solid #000;
            border-radius: 0 4px 4px 0;
        }
        .eye {
            position: absolute;
            z-index: 2;
            width: 10px;
            height: 10px;
            background-color: #ef4444;
            border-radius: 50%;
            box-shadow: 0 0 8px #ef4444, 0 0 12px #ef4444, 0 0 16px #ef4444;
            animation: eye-glow 1.5s infinite alternate;
        }
        .eye1 { top: 7px; left: 15px; }
        .eye2 { top: 7px; left: 35px; }
        @keyframes eye-glow {
            from { opacity: 0.7; transform: scale(1); }
            to { opacity: 1; transform: scale(1.1); }
        }
        .smoke {
            position: absolute;
            background: rgba(80, 80, 80, 0.4);
            border-radius: 50%;
            animation: smoke-rise 4s infinite;
            opacity: 0;
        }
        .smoke1 { width: 30px; height: 30px; left: 44px; bottom: 60px; animation-delay: 0s; }
        .smoke2 { width: 40px; height: 40px; left: 30px; bottom: 70px; animation-delay: 1s; }
        .smoke3 { width: 24px; height: 24px; left: 60px; bottom: 64px; animation-delay: 2s; }
        .smoke4, .smoke5 { display: none; }
        .evolved .smoke4 { display: block; width: 36px; height: 36px; left: 50px; bottom: 76px; animation-delay: 0.5s; }
        .evolved .smoke5 { display: block; width: 28px; height: 28px; left: 36px; bottom: 66px; animation-delay: 1.5s; }

        @keyframes smoke-rise {
            0% { transform: translateY(0) scale(1); opacity: 0.8; }
            100% { transform: translateY(-60px) scale(2.5); opacity: 0; }
        }
        .crack {
            position: absolute;
            z-index: 2;
            width: 3px;
            height: 15px;
            background: #ff4500;
            box-shadow: 0 0 4px #ff4500, 0 0 6px #ff4500, 0 0 8px #ff0000;
            border-radius: 2px;
            opacity: 0;
            transform: scale(0);
            transition: all 0.5s ease-out;
        }
        .crack1 { top: 5px; left: 25px; transform: rotate(25deg) scale(0); }
        .crack2 { top: 2px; left: 45px; transform: rotate(-35deg) scale(0); height: 18px; }
        .evolved .crack {
            opacity: 1;
            transform: rotate(25deg) scale(1);
        }
        .evolved .crack2 {
             transform: rotate(-35deg) scale(1);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-700 via-gray-800 to-gray-900 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-white mb-2" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">B·∫£o V·ªá Tr√°i Tim</h1>
        <p class="text-gray-300 mb-4" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">M·ªói tr√°i tim ƒë∆∞·ª£c c·ª©u l√† m·ªôt th√¥ng ƒëi·ªáp s·ª©c kh·ªèe!</p>

        <div id="game-container" class="relative">
             <div class="danger-zone">
                <div id="cigarette-sprite">
                    <div class="smoke smoke1"></div>
                    <div class="smoke smoke2"></div>
                    <div class="smoke smoke3"></div>
                    <div class="smoke smoke4"></div>
                    <div class="smoke smoke5"></div>
                    <div class="cigarette-body">
                        <div class="cigar-main">
                           <div class="cigar-ash"></div>
                        </div>
                        <div class="cigar-filter"></div>
                        <div class="eye eye1"></div>
                        <div class="eye eye2"></div>
                        <div class="crack crack1"></div>
                        <div class="crack crack2"></div>
                    </div>
                </div>
             </div>
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="mt-4 p-4 bg-black/20 rounded-2xl shadow-lg flex justify-around items-center backdrop-blur-sm border border-white/10">
            <div>
                <p class="text-lg font-bold text-white/70">Tr√°i tim ƒë√£ c·ª©u</p>
                <p id="score" class="text-3xl font-bold text-white">0</p>
            </div>
            <div>
                <p class="text-lg font-bold text-white/70">N∆∞·ªõc ƒëi</p>
                <p id="moves" class="text-3xl font-bold text-white">0</p>
            </div>
        </div>
    </div>

    <!-- Modal Game Over -->
    <div id="gameOverModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm">
        <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
            <h2 class="text-4xl font-bold text-red-800 mb-4">Nguy hi·ªÉm!</h2>
            <p class="text-lg text-gray-700 mb-2">Thu·ªëc l√° ƒë√£ l√†m h·∫°i m·ªôt tr√°i tim.</p>
            <p class="text-xl text-gray-800 mb-6">B·∫°n ƒë√£ b·∫£o v·ªá ƒë∆∞·ª£c <span id="finalScore" class="font-bold text-pink-600">0</span> tr√°i tim.</p>
            <button id="restartButton" class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-300">Ch∆°i l·∫°i</button>
        </div>
    </div>
    
    <!-- Modal Th√¥ng ƒëi·ªáp s·ª©c kh·ªèe -->
    <div id="factModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm">
        <div class="bg-white rounded-2xl p-6 md:p-8 text-center shadow-2xl transform transition-all scale-95 max-w-md w-full">
            <h2 class="text-2xl md:text-3xl font-bold text-blue-700 mb-4">S·ª± Th·∫≠t & L·ªùi Khuy√™n</h2>
            <p id="factText" class="text-base md:text-lg text-gray-800 mb-3 text-left"></p>
            <p id="adviceText" class="text-base md:text-lg text-green-700 font-semibold mb-6 text-left"></p>
            <button id="closeFactButton" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">ƒê√£ hi·ªÉu</button>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const movesEl = document.getElementById('moves');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const cigaretteEl = document.getElementById('cigarette-sprite');
        const factModal = document.getElementById('factModal');
        const factText = document.getElementById('factText');
        const adviceText = document.getElementById('adviceText');
        const closeFactButton = document.getElementById('closeFactButton');

        // --- D·ªØ li·ªáu tuy√™n truy·ªÅn ---
        const HEALTH_FACTS = [
            { fact: "H·∫ßu h·∫øt thu·ªëc l√° ƒëi·ªán t·ª≠ ch·ª©a Nicotine, m·ªôt ch·∫•t g√¢y nghi·ªán cao c√≥ trong thu·ªëc l√° truy·ªÅn th·ªëng. Nicotine ƒë·∫∑c bi·ªát c√≥ h·∫°i cho s·ª± ph√°t tri·ªÉn n√£o b·ªô c·ªßa thanh thi·∫øu ni√™n. (Ngu·ªìn: CDC Hoa K·ª≥)", advice: "L·ªùi khuy√™n: H√£y b·∫£o v·ªá t∆∞∆°ng lai c·ªßa b·∫°n b·∫±ng c√°ch n√≥i kh√¥ng v·ªõi t·∫•t c·∫£ c√°c s·∫£n ph·∫©m ch·ª©a nicotine." },
            { fact: "Aerosol (kh√≥i) t·ª´ thu·ªëc l√° ƒëi·ªán t·ª≠ kh√¥ng ph·∫£i l√† 'h∆°i n∆∞·ªõc' v√¥ h·∫°i. N√≥ ch·ª©a c√°c ch·∫•t ƒë·ªôc h·∫°i nh∆∞ kim lo·∫°i n·∫∑ng (niken, thi·∫øc, ch√¨) v√† c√°c h·ª£p ch·∫•t h·ªØu c∆° d·ªÖ bay h∆°i. (Ngu·ªìn: WHO)", advice: "L·ªùi khuy√™n: ƒê·ª´ng ƒë·ªÉ nh·ªØng l·ªùi qu·∫£ng c√°o ƒë√°nh l·ª´a. H√≠t th·ªü kh√¥ng kh√≠ trong l√†nh lu√¥n l√† l·ª±a ch·ªçn t·ªët nh·∫•t cho l√° ph·ªïi c·ªßa b·∫°n." },
            { fact: "S·ª≠ d·ª•ng thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ li√™n quan ƒë·∫øn c√°c b·ªánh ph·ªïi nghi√™m tr·ªçng, bao g·ªìm 't·ªïn th∆∞∆°ng ph·ªïi do thu·ªëc l√° ƒëi·ªán t·ª≠' (EVALI), c√≥ th·ªÉ g√¢y t·ª≠ vong. (Ngu·ªìn: CDC Hoa K·ª≥)", advice: "L·ªùi khuy√™n: M·ªói l·∫ßn t·ª´ ch·ªëi thu·ªëc l√° ƒëi·ªán t·ª≠ l√† m·ªôt l·∫ßn b·∫°n b·∫£o v·ªá l√° ph·ªïi kh·ªèi nh·ªØng t·ªïn th∆∞∆°ng kh√¥ng th·ªÉ ph·ª•c h·ªìi." },
            { fact: "Nicotine trong thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ th·ªÉ l√†m tƒÉng huy·∫øt √°p v√† nh·ªãp tim, l√†m tƒÉng nguy c∆° b·ªã ƒëau tim. (Ngu·ªìn: American Heart Association)", advice: "L·ªùi khuy√™n: Gi·ªØ cho tr√°i tim c·ªßa b·∫°n lu√¥n kh·ªèe m·∫°nh b·∫±ng c√°ch tr√°nh xa nicotine d∆∞·ªõi m·ªçi h√¨nh th·ª©c." },
            { fact: "H∆∞∆°ng li·ªáu trong thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ th·ªÉ ch·ª©a diacetyl, m·ªôt h√≥a ch·∫•t li√™n quan ƒë·∫øn b·ªánh ph·ªïi nghi√™m tr·ªçng ƒë∆∞·ª£c g·ªçi l√† 'ph·ªïi b·ªèng ng√¥'. (Ngu·ªìn: American Lung Association)", advice: "L·ªùi khuy√™n: Nh·ªØng m√πi h∆∞∆°ng h·∫•p d·∫´n c√≥ th·ªÉ che gi·∫•u nh·ªØng h√≥a ch·∫•t c·ª±c k·ª≥ nguy hi·ªÉm. H√£y l·ª±a ch·ªçn s·ª©c kh·ªèe thay v√¨ h∆∞∆°ng v·ªã nh√¢n t·∫°o." },
            { fact: "Thanh thi·∫øu ni√™n s·ª≠ d·ª•ng thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ kh·∫£ nƒÉng chuy·ªÉn sang h√∫t thu·ªëc l√° truy·ªÅn th·ªëng cao h∆°n so v·ªõi nh·ªØng ng∆∞·ªùi kh√¥ng s·ª≠ d·ª•ng. (Ngu·ªìn: National Academies of Sciences, Engineering, and Medicine)", advice: "L·ªùi khuy√™n: ƒê·ª´ng m·ªü c√°nh c·ª≠a ƒë·∫ßu ti√™n d·∫´n ƒë·∫øn nghi·ªán ng·∫≠p. Tr√°nh xa thu·ªëc l√° ƒëi·ªán t·ª≠ l√† c√°ch t·ªët nh·∫•t ƒë·ªÉ kh√¥ng bao gi·ªù tr·ªü th√†nh ng∆∞·ªùi h√∫t thu·ªëc." },
            { fact: "Pin c·ªßa thi·∫øt b·ªã thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ th·ªÉ b·ªã l·ªói v√† g√¢y ch√°y n·ªï, d·∫´n ƒë·∫øn th∆∞∆°ng t√≠ch nghi√™m tr·ªçng. (Ngu·ªìn: FDA Hoa K·ª≥)", advice: "L·ªùi khuy√™n: Nguy c∆° ch√°y n·ªï l√† c√≥ th·∫≠t. ƒê·ª´ng ƒë√°nh c∆∞·ª£c s·ª± an to√†n c·ªßa b·∫£n th√¢n v√† nh·ªØng ng∆∞·ªùi xung quanh." }
        ];
        let factsShown = [];

        // --- C·∫•u h√¨nh game ---
        const GRID_SIZE = 8;
        const GEM_COLORS = ['#FF3131', '#00FF7F', '#1E90FF', '#FF00FF', '#FF8C00', '#FFFF00'];
        const HEART_EMOJI = 'üíó';
        const MOVES_PER_HEART_SPAWN = 3; 
        const LUNGE_CHANCE = 0.25;
        const SPECIAL_TYPES = {
            NONE: 'none',
            H_BEAM: 'h_beam',
            V_BEAM: 'v_beam',
            BOMB: 'bomb',
            HYPERCUBE: 'hypercube'
        };

        let gemSize;
        let board = [];
        let selectedGem = null;
        let score = 0;
        let moves = 0;
        let isAnimating = false;
        let isPaused = false;
        let animations = [];
        let particles = [];
        let cigarette = { col: Math.floor(GRID_SIZE / 2), level: 1 };
        
        let startDragPos = { x: null, y: null };
        let startGem = null;
        let isDragging = false;


        // --- Kh·ªüi t·∫°o v√† Thi·∫øt l·∫≠p Game ---
        function init() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth;
            canvas.width = containerWidth;
            canvas.height = containerWidth;
            gemSize = canvas.width / GRID_SIZE;
            
            ctx.font = `${gemSize * 0.7}px sans-serif`;

            cigarette.col = Math.floor(GRID_SIZE / 2);
            cigarette.level = 1;
            cigaretteEl.classList.remove('evolved');
            updateCigarettePosition();

            board = [];
            score = 0;
            moves = 0;
            selectedGem = null;
            isAnimating = false;
            isPaused = false;
            animations = [];
            particles = [];
            factsShown = [];
            
            updateScore();
            updateMoves();
            createBoard();
            
            let matches = findMatches(board);
            while (matches.length > 0) {
                for (const gem of matches) {
                    let newColorIndex;
                    do {
                        newColorIndex = Math.floor(Math.random() * GEM_COLORS.length);
                    } while (newColorIndex === gem.colorIndex);
                    board[gem.row][gem.col].colorIndex = newColorIndex;
                }
                matches = findMatches(board);
            }
            
            spawnHeartIfNeeded(true);
            requestAnimationFrame(gameLoop);
        }

        function createBoard() {
            for (let row = 0; row < GRID_SIZE; row++) {
                board[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    board[row][col] = {
                        colorIndex: Math.floor(Math.random() * GEM_COLORS.length),
                        isHeart: false,
                        special: SPECIAL_TYPES.NONE,
                        row: row,
                        col: col,
                        x: col * gemSize,
                        y: row * gemSize,
                        scale: 1,
                        alpha: 1,
                    };
                }
            }
        }

        // --- V√≤ng l·∫∑p Game v√† V·∫Ω ---
        function gameLoop(time) {
            if (!isPaused) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                handleAnimations(time);
                drawBoard(time);
                drawParticles();
                drawSelection(time);
            }
            if(!gameOverModal.classList.contains('hidden')) {
                 // D·ª´ng game loop khi thua
            } else {
                 requestAnimationFrame(gameLoop);
            }
        }

        function drawGem(x, y, size, color, special, isHeart, time) {
            const s = size * 0.85;
            const half = s / 2;
            const pulse = Math.sin(time / 150) * 0.2 + 0.8;

            ctx.save();
            ctx.translate(x, y);
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;

            if (isHeart) {
                const heartPulse = Math.sin(time / 300) * 0.15 + 0.9;
                const heartGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, half * heartPulse * 1.3);
                heartGlow.addColorStop(0, 'rgba(255, 182, 193, 0.8)');
                heartGlow.addColorStop(1, 'rgba(255, 182, 193, 0)');
                ctx.fillStyle = heartGlow;
                ctx.beginPath();
                ctx.arc(0, 0, half * 1.3, 0, Math.PI * 2);
                ctx.fill();
            }

            if (special === SPECIAL_TYPES.HYPERCUBE) {
                ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                ctx.shadowBlur = 20;
                for (let i = 0; i < 6; i++) {
                    ctx.fillStyle = GEM_COLORS[(i + Math.floor(time / 200)) % 6];
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    const angle1 = (i / 6) * 2 * Math.PI + (time / 1000);
                    const angle2 = ((i+1) / 6) * 2 * Math.PI + (time/1000);
                    ctx.arc(0,0, half, angle1, angle2);
                    ctx.closePath();
                    ctx.fill();
                }
                const pulseCore = Math.sin(time / 200) * 0.2 + 0.8;
                ctx.fillStyle = `rgba(255, 255, 255, ${pulseCore})`;
                ctx.beginPath();
                ctx.arc(0, 0, half * 0.3, 0, 2 * Math.PI);
                ctx.fill();

            } else {
                const shadeColor = (col, percent) => {
                    let f=parseInt(col.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
                    return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
                };

                const lightColor = shadeColor(color, 0.6);
                const darkColor = shadeColor(color, -0.6);

                const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, half);
                grad.addColorStop(0, lightColor);
                grad.addColorStop(1, color);
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(0, -half); ctx.lineTo(half, 0); ctx.lineTo(0, half); ctx.lineTo(-half, 0);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = darkColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.moveTo(-half * 0.8, -half * 0.2);
                ctx.lineTo(0, -half * 0.8);
                ctx.lineTo(half * 0.2, -half * 0.6);
                ctx.closePath();
                ctx.fill();

                ctx.save();
                if (special === SPECIAL_TYPES.H_BEAM || special === SPECIAL_TYPES.V_BEAM) {
                    const beamPulse = Math.sin(time / 250) * 2.0 + 3.0;
                    ctx.fillStyle = 'white';
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 20 * pulse;
                    if(special === SPECIAL_TYPES.H_BEAM) {
                        const beamWidth = half * 0.8 * beamPulse;
                        const beamHeight = half * 0.15;
                        const tipOffset = beamHeight * 2;
                        ctx.beginPath();
                        ctx.moveTo(-beamWidth / 2, 0);
                        ctx.lineTo(-beamWidth / 2 + tipOffset, -beamHeight / 2);
                        ctx.lineTo(beamWidth / 2 - tipOffset, -beamHeight / 2);
                        ctx.lineTo(beamWidth / 2, 0);
                        ctx.lineTo(beamWidth / 2 - tipOffset, beamHeight / 2);
                        ctx.lineTo(-beamWidth / 2 + tipOffset, beamHeight / 2);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        const beamHeight = half * 0.8 * beamPulse;
                        const beamWidth = half * 0.15;
                        const tipOffset = beamWidth * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -beamHeight / 2);
                        ctx.lineTo(beamWidth / 2, -beamHeight / 2 + tipOffset);
                        ctx.lineTo(beamWidth / 2, beamHeight / 2 - tipOffset);
                        ctx.lineTo(0, beamHeight / 2);
                        ctx.lineTo(-beamWidth / 2, beamHeight / 2 - tipOffset);
                        ctx.lineTo(-beamWidth / 2, -beamHeight / 2 + tipOffset);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else if (special === SPECIAL_TYPES.BOMB) {
                    ctx.scale(pulse, pulse);
                    ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(0, 0, half * 0.6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.fillStyle = `hsl(${time / 10 % 60}, 100%, 50%)`;
                    ctx.shadowColor = `hsl(${time / 10 % 60}, 100%, 50%)`;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, -half * 0.5, size * 0.05, 0, 2 * Math.PI);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            ctx.restore();
        }

        function drawBoard(time) {
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const gem = board[row][col];
                    if (gem) {
                        const centerX = gem.x + gemSize / 2;
                        const centerY = gem.y + gemSize / 2;
                        
                        ctx.save();
                        ctx.globalAlpha = gem.alpha;
                        ctx.translate(centerX, centerY);
                        ctx.scale(gem.scale, gem.scale);
                        ctx.translate(-centerX, -centerY);
                        
                        const color = gem.special === SPECIAL_TYPES.HYPERCUBE ? null : GEM_COLORS[gem.colorIndex];
                        drawGem(centerX, centerY, gemSize, color, gem.special, gem.isHeart, time);
                        
                        if (gem.isHeart) {
                            const heartPulse = Math.sin(time / 300) * 0.75 + 1.25;
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.scale(heartPulse, heartPulse);
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'rgba(0,0,0,0)';
                            ctx.font = `${gemSize * 0.6}px sans-serif`;
                            ctx.fillText(HEART_EMOJI, 0, 0);
                            ctx.restore();
                        }
                        ctx.restore();
                    }
                }
            }
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.02;
                if (p.alpha <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function drawSelection(time) {
            if (selectedGem) {
                const pulse = Math.sin(time / 100) * 0.5 + 0.5;
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
            }
        }

        // --- X·ª≠ l√Ω s·ª± ki·ªán ng∆∞·ªùi d√πng (C∆† CH·∫æ L∆Ø·ªöT) ---
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function handleDragStart(e) {
            e.preventDefault();
            if (isAnimating || isPaused) return;
            const pos = getEventPos(e);
            const col = Math.floor(pos.x / gemSize);
            const row = Math.floor(pos.y / gemSize);

            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                isDragging = true;
                startDragPos = pos;
                startGem = board[row][col];
                selectedGem = startGem;
            }
        }

        function handleDragMove(e) {
            e.preventDefault();
            if (!isDragging || isAnimating || isPaused) return;
            
            const pos = getEventPos(e);
            const deltaX = pos.x - startDragPos.x;
            const deltaY = pos.y - startDragPos.y;
            
            if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) {
                let endGem = null;
                if (Math.abs(deltaX) > Math.abs(deltaY)) { // L∆∞·ªõt ngang
                    const endCol = startGem.col + (deltaX > 0 ? 1 : -1);
                    if (endCol >= 0 && endCol < GRID_SIZE) {
                        endGem = board[startGem.row][endCol];
                    }
                } else { // L∆∞·ªõt d·ªçc
                    const endRow = startGem.row + (deltaY > 0 ? 1 : -1);
                     if (endRow >= 0 && endRow < GRID_SIZE) {
                        endGem = board[endRow][startGem.col];
                    }
                }

                if (endGem) {
                    isDragging = false;
                    selectedGem = null;
                    processSwap(startGem, endGem);
                }
            }
        }

        function handleDragEnd(e) {
            isDragging = false;
            startGem = null;
            selectedGem = null;
        }

        canvas.addEventListener('mousedown', handleDragStart);
        canvas.addEventListener('mousemove', handleDragMove);
        canvas.addEventListener('mouseup', handleDragEnd);
        canvas.addEventListener('mouseleave', handleDragEnd);
        canvas.addEventListener('touchstart', handleDragStart, { passive: false });
        canvas.addEventListener('touchmove', handleDragMove, { passive: false });
        canvas.addEventListener('touchend', handleDragEnd);

        // --- Logic Game Ch√≠nh ---
        async function processSwap(gem1, gem2) {
            isAnimating = true;
            selectedGem = null;

            const isGem1Beam = gem1.special === SPECIAL_TYPES.H_BEAM || gem1.special === SPECIAL_TYPES.V_BEAM;
            const isGem2Beam = gem2.special === SPECIAL_TYPES.H_BEAM || gem2.special === SPECIAL_TYPES.V_BEAM;

            if (isGem1Beam && isGem2Beam) {
                let gemsToClear = new Set([gem1, gem2]);
                for(let c=0; c<GRID_SIZE; c++) { if(board[gem1.row][c]) gemsToClear.add(board[gem1.row][c]); }
                for(let r=0; r<GRID_SIZE; r++) { if(board[r][gem2.col]) gemsToClear.add(board[r][gem2.col]); }
                moves++;
                updateMoves();
                await cascadeMatches(Array.from(gemsToClear));
            } else if (gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE) {
                const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
                const otherGem = hypercube === gem1 ? gem2 : gem1;
                let gemsToClear = new Set([hypercube]);
                if (otherGem.special !== SPECIAL_TYPES.HYPERCUBE) {
                    const targetColorIndex = otherGem.colorIndex;
                    for(let r=0; r<GRID_SIZE; r++) {
                        for(let c=0; c<GRID_SIZE; c++) {
                            if(board[r][c] && board[r][c].colorIndex === targetColorIndex) {
                                gemsToClear.add(board[r][c]);
                            }
                        }
                    }
                }
                moves++;
                updateMoves();
                await cascadeMatches(Array.from(gemsToClear));
            } else {
                await swapGems(gem1, gem2);
                const matchInfo = findMatchesAndSpecial(gem1, gem2);
                if (matchInfo.allMatches.length > 0) {
                    moves++;
                    updateMoves();
                    await cascadeMatches(matchInfo.allMatches, matchInfo.specialToCreate);
                } else {
                    await swapGems(gem1, gem2);
                }
            }
            
            if (gameOverModal.classList.contains('hidden')) {
                await moveCigarette();
                if (checkGameOver()) {
                    isAnimating = false;
                    return;
                }
                spawnHeartIfNeeded();
            }
            
            isAnimating = false;
        }
        
        async function cascadeMatches(initialMatches, specialToCreate = null) {
            let gemsToClear = new Set(initialMatches);
            let processedSpecials = new Set();
            
            while(true) {
                let newGemsFromExplosion = new Set();
                let foundNewExplosion = false;
                for(const gem of gemsToClear) {
                    if(gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                        foundNewExplosion = true;
                        processedSpecials.add(gem);
                        getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                    }
                }
                if(!foundNewExplosion) break;
                newGemsFromExplosion.forEach(g => gemsToClear.add(g));
            }

            const savedAHeart = await handleMatches(Array.from(gemsToClear), specialToCreate);
            if (savedAHeart) {
                await showFact();
            }

            await sleep(150);
            await shiftAndRefill();
            
            const nextMatches = findMatches(board);
            if (nextMatches.length > 0) {
                await cascadeMatches(nextMatches);
            } else {
                 await moveHearts();
            }
        }

        function getSpecialEffectGems(gem) {
            let affected = new Set();
            if (gem.special === SPECIAL_TYPES.H_BEAM) {
                for(let c=0; c<GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); }
            } else if (gem.special === SPECIAL_TYPES.V_BEAM) {
                for(let r=0; r<GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); }
            } else if (gem.special === SPECIAL_TYPES.BOMB) {
                for(let r = gem.row - 1; r <= gem.row + 1; r++) {
                    for(let c = gem.col - 1; c <= gem.col + 1; c++) {
                        if(r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[r][c]) {
                            affected.add(board[r][c]);
                        }
                    }
                }
            }
            return affected;
        }

        function swapGems(gem1, gem2) {
            const r1 = gem1.row, c1 = gem1.col;
            const r2 = gem2.row, c2 = gem2.col;
            board[r1][c1] = gem2;
            board[r2][c2] = gem1;
            gem1.row = r2; gem1.col = c2;
            gem2.row = r1; gem2.col = c1;
            const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, 150, easing.easeInOutQuad);
            const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, 150, easing.easeInOutQuad);
            return Promise.all([p1, p2]);
        }
        
        function findMatches(currentBoard) {
            const matches = new Set();
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE - 2; c++) {
                    const gem1 = currentBoard[r][c];
                    const gem2 = currentBoard[r][c+1];
                    const gem3 = currentBoard[r][c+2];
                    if (gem1 && gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                        matches.add(gem1); matches.add(gem2); matches.add(gem3);
                    }
                }
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE - 2; r++) {
                     const gem1 = currentBoard[r][c];
                    const gem2 = currentBoard[r+1][c];
                    const gem3 = currentBoard[r+2][c];
                    if (gem1 && gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                        matches.add(gem1); matches.add(gem2); matches.add(gem3);
                    }
                }
            }
            return Array.from(matches);
        }

        function findMatchesAndSpecial(gem1, gem2) {
            let allMatches = new Set();
            let specialToCreate = null;
            
            const checkLine = (line) => {
                let matches = [];
                for(let i=0; i<line.length - 2; i++) {
                    if(line[i] && line[i+1] && line[i+2] && line[i].colorIndex === line[i+1].colorIndex && line[i+1].colorIndex === line[i+2].colorIndex) {
                        let len = 3;
                        while(i+len < line.length && line[i].colorIndex === line[i+len].colorIndex) len++;
                        let currentMatch = [];
                        for(let j=0; j<len; j++) currentMatch.push(line[i+j]);
                        matches.push(currentMatch);
                        i += len - 1;
                    }
                }
                return matches;
            }

            const hMatches1 = checkLine(board[gem1.row]);
            const vMatches1 = checkLine(board.map(r => r[gem1.col]));
            const hMatches2 = checkLine(board[gem2.row]);
            const vMatches2 = checkLine(board.map(r => r[gem2.col]));
            
            const allFoundMatches = [...hMatches1, ...vMatches1, ...hMatches2, ...vMatches2];
            allFoundMatches.forEach(m => m.forEach(g => allMatches.add(g)));

            const hMatches = [...hMatches1, ...hMatches2];
            const vMatches = [...vMatches1, ...vMatches2];

            let bestMatch = {len: 0, match: null, type: null, isCross: false};

            for(const match of allFoundMatches) {
                if(match.includes(gem1) || match.includes(gem2)) {
                    if (match.length >= 5) {
                        bestMatch = { len: match.length, match, type: (match[0].row === match[1].row) ? 'h' : 'v', isCross: false };
                        break;
                    }
                    if (match.length === 4 && bestMatch.len < 4) {
                        bestMatch = { len: 4, match, type: (match[0].row === match[1].row) ? 'h' : 'v', isCross: false };
                    }
                }
            }
            
            const intersection = hMatches.flat().filter(gem => vMatches.flat().includes(gem));
            if (intersection.length > 0 && allMatches.size >= 5) {
                bestMatch = { len: 5, match: intersection, type: 'cross', isCross: true };
            }


            if (bestMatch.len >= 5 && !bestMatch.isCross) {
                specialToCreate = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: -1 };
            } else if (bestMatch.isCross) {
                 specialToCreate = { special: SPECIAL_TYPES.BOMB, colorIndex: gem1.colorIndex };
            } else if (bestMatch.len === 4) {
                specialToCreate = { special: bestMatch.type === 'h' ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: gem1.colorIndex };
            }
            
            if(specialToCreate && bestMatch.match) {
                 const creationGem = bestMatch.match.includes(gem1) ? gem1 : gem2;
                 specialToCreate.row = creationGem.row;
                 specialToCreate.col = creationGem.col;
            }

            return { allMatches: Array.from(allMatches), specialToCreate };
        }
        
        async function handleMatches(matches, specialToCreate) {
            const promises = [];
            let heartSaved = false;
            matches.forEach(gem => {
                if(specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) {
                    // Skip
                } else {
                    if (gem.isHeart) {
                        score++;
                        updateScore();
                        heartSaved = true;
                    }
                    for(let i=0; i<10; i++) {
                        particles.push({
                            x: gem.x + gemSize / 2,
                            y: gem.y + gemSize / 2,
                            vx: (Math.random() - 0.5) * 6,
                            vy: (Math.random() - 0.5) * 6,
                            size: Math.random() * 4 + 2,
                            color: GEM_COLORS[gem.colorIndex],
                            alpha: 1
                        });
                    }
                    const p = animate(gem, { scale: 0, alpha: 0 }, 200, easing.easeInQuad);
                    p.then(() => { board[gem.row][gem.col] = null; });
                    promises.push(p);
                }
            });
            await Promise.all(promises);

            if (specialToCreate) {
                const gem = board[specialToCreate.row][specialToCreate.col];
                gem.special = specialToCreate.special;
                gem.colorIndex = specialToCreate.colorIndex;
                gem.isHeart = false;
                await animate(gem, {scale: 1.5}, 150, easing.easeOutQuad).then(() => animate(gem, {scale: 1}, 150, easing.easeInQuad));
            }
            return heartSaved;
        }

        async function shiftAndRefill() {
            const shiftPromises = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                let emptySlots = 0;
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    if (board[r][c] === null) {
                        emptySlots++;
                    } else if (emptySlots > 0) {
                        const gem = board[r][c];
                        board[r + emptySlots][c] = gem;
                        board[r][c] = null;
                        gem.row += emptySlots;
                        shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300, easing.easeOutQuad));
                    }
                }
            }
            await Promise.all(shiftPromises);

            const refillPromises = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (board[r][c] === null) {
                        const newGem = {
                            colorIndex: Math.floor(Math.random() * GEM_COLORS.length),
                            isHeart: false, special: SPECIAL_TYPES.NONE,
                            row: r, col: c,
                            x: c * gemSize, y: (r - GRID_SIZE) * gemSize,
                            scale: 1, alpha: 1,
                        };
                        board[r][c] = newGem;
                        refillPromises.push(animate(newGem, { y: r * gemSize }, 400, easing.easeOutQuad));
                    }
                }
            }
            await Promise.all(refillPromises);
        }

        function spawnHeartIfNeeded(isFirst = false) {
             if (isFirst || (moves > 0 && moves % MOVES_PER_HEART_SPAWN === 0)) {
                let availableCols = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[GRID_SIZE - 1][c] && !board[GRID_SIZE - 1][c].isHeart && board[GRID_SIZE - 1][c].special === SPECIAL_TYPES.NONE) {
                        availableCols.push(c);
                    }
                }
                if (availableCols.length > 0) {
                    const col = availableCols[Math.floor(Math.random() * availableCols.length)];
                    const gem = board[GRID_SIZE - 1][col];
                    gem.isHeart = true;
                    gem.special = SPECIAL_TYPES.NONE;
                    animate(gem, {scale: 1.5}, 150, easing.easeOutQuad).then(() => animate(gem, {scale: 1}, 150, easing.easeInQuad));
                }
            }
        }

        async function moveHearts() {
            const movePromises = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const gem = board[r][c];
                    if (gem && gem.isHeart) {
                        const newRow = r - 1;
                        if (newRow < 0) continue;
                        const gemAbove = board[newRow][c];
                        
                        board[newRow][c] = gem;
                        board[r][c] = gemAbove;
                        
                        gem.row = newRow;
                        if (gemAbove) gemAbove.row = r;
                        
                        movePromises.push(animate(gem, { y: newRow * gemSize }, 200, easing.easeInOutQuad));
                        if (gemAbove) {
                           movePromises.push(animate(gemAbove, { y: r * gemSize }, 200, easing.easeInOutQuad));
                        }
                    }
                }
            }
            await Promise.all(movePromises);
        }

        async function moveCigarette() {
            let highestHeart = null;
            let minRow = GRID_SIZE;

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c] && board[r][c].isHeart) {
                        if (r < minRow) {
                            minRow = r;
                            highestHeart = board[r][c];
                        }
                    }
                }
            }

            if (highestHeart) {
                if (Math.random() < LUNGE_CHANCE && cigarette.level > 1) {
                    const originalCol = cigarette.col;
                    const targetCol = highestHeart.col;
                    
                    cigaretteEl.style.transition = 'left 0.1s ease-in';
                    cigaretteEl.style.left = `${targetCol * gemSize}px`;
                    await sleep(300);
                    cigaretteEl.style.transition = 'left 0.4s ease-out';
                    cigaretteEl.style.left = `${originalCol * gemSize}px`;
                    await sleep(400);
                }

                if (cigarette.col < highestHeart.col) {
                    cigarette.col++;
                } else if (cigarette.col > highestHeart.col) {
                    cigarette.col--;
                }
            }
            cigaretteEl.style.transition = 'left 0.3s ease-in-out';
            updateCigarettePosition();
        }

        function updateCigarettePosition() {
            cigaretteEl.style.left = `${cigarette.col * gemSize}px`;
        }
        
        function checkGameOver() {
            if(board[0][cigarette.col] && board[0][cigarette.col].isHeart) {
                showGameOver();
                return true;
            }
            return false;
        }

        // --- Giao di·ªán ng∆∞·ªùi d√πng v√† Ti·ªán √≠ch ---
        function updateScore() { 
            scoreEl.textContent = score;
            if (score === 5 && cigarette.level === 1) {
                cigarette.level = 2;
                cigaretteEl.classList.add('evolved');
            }
        }
        function updateMoves() { movesEl.textContent = moves; }

        function showGameOver() {
            isAnimating = true;
            finalScoreEl.textContent = score;
            gameOverModal.classList.remove('hidden');
            setTimeout(() => gameOverModal.querySelector('div').classList.add('scale-100'), 10);
        }

        async function showFact() {
            isPaused = true;
            let availableFacts = HEALTH_FACTS.filter(obj => !factsShown.includes(obj));
            if (availableFacts.length === 0) {
                factsShown = []; // Reset n·∫øu ƒë√£ hi·ªÉn th·ªã h·∫øt
                availableFacts = HEALTH_FACTS;
            }
            const factObject = availableFacts[Math.floor(Math.random() * availableFacts.length)];
            factsShown.push(factObject);
            factText.textContent = factObject.fact;
            adviceText.textContent = factObject.advice;
            factModal.classList.remove('hidden');
            await new Promise(resolve => {
                const listener = () => {
                    closeFactButton.removeEventListener('click', listener);
                    factModal.classList.add('hidden');
                    isPaused = false;
                    resolve();
                };
                closeFactButton.addEventListener('click', listener);
            });
        }
        
        closeFactButton.addEventListener('click', () => {
             factModal.classList.add('hidden');
             isPaused = false;
        });

        restartButton.addEventListener('click', () => {
            gameOverModal.classList.add('hidden');
            gameOverModal.querySelector('div').classList.remove('scale-100');
            init();
        });

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        
        // --- H·ªá th·ªëng Animation ---
        const easing = {
            easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t)
        };

        function animate(target, toProperties, duration, easeFunc = easing.easeInOutQuad) {
            return new Promise(resolve => {
                animations.push({
                    target,
                    toProperties,
                    duration,
                    onComplete: resolve,
                    startProperties: Object.keys(toProperties).reduce((acc, key) => {
                        acc[key] = target[key];
                        return acc;
                    }, {}),
                    startTime: Date.now(),
                    easeFunc
                });
            });
        }

        function handleAnimations() {
            const now = Date.now();
            for (let i = animations.length - 1; i >= 0; i--) {
                const anim = animations[i];
                const elapsed = now - anim.startTime;
                const progressLinear = Math.min(elapsed / anim.duration, 1);
                const progress = anim.easeFunc(progressLinear);

                for (const key in anim.toProperties) {
                    const start = anim.startProperties[key];
                    const to = anim.toProperties[key];
                    anim.target[key] = start + (to - start) * progress;
                }

                if (progressLinear === 1) {
                    anim.onComplete();
                    animations.splice(i, 1);
                }
            }
        }
        
        window.onload = init;
        window.onresize = init;

    </script>
</body>
</html>
