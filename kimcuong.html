<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Game Kim Cương: Bảo Vệ Trái Tim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #4a5568; /* gray-700 */
        }
        canvas {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .danger-zone {
            position: absolute;
            top: -10px;
            left: 0;
            right: 0;
            height: 50px;
            z-index: 10;
            pointer-events: none;
        }
        #cigarette-sprite {
            position: absolute;
            top: -50px;
            transition: left 0.3s ease-in-out;
            width: 120px;
            height: 120px;
            display: flex;
            justify-content: center;
            align-items: center;
            filter: drop-shadow(0 3px 5px rgba(0,0,0,0.5));
        }
        .cigarette-body {
            position: relative;
            width: 80px;
            height: 24px;
            transform: rotate(-20deg);
        }
        .cigar-main {
            position: absolute;
            left: 0;
            top: 0;
            width: 75%;
            height: 100%;
            background: linear-gradient(to bottom, #ffffff, #e2e8f0);
            border: 1px solid #94a3b8;
            border-right: none;
            border-radius: 4px 0 0 4px;
        }
        .cigar-ash {
            position: absolute;
            left: -6px;
            top: -2px;
            width: 12px;
            height: 28px;
            background: linear-gradient(to right, #475569, #94a3b8, #64748b);
            border-radius: 50%;
            box-shadow: 0 0 5px #f97316, 0 0 8px #f97316;
        }
        .cigar-filter {
            position: absolute;
            right: 0;
            top: 0;
            width: 25%;
            height: 100%;
            background: linear-gradient(to bottom, #f59e0b, #b45309);
            border: 1px solid #92400e;
            border-left: 2px solid #000;
            border-radius: 0 4px 4px 0;
        }
        .eye {
            position: absolute;
            z-index: 2;
            width: 10px;
            height: 10px;
            background-color: #ef4444;
            border-radius: 50%;
            box-shadow: 0 0 8px #ef4444, 0 0 12px #ef4444, 0 0 16px #ef4444;
            animation: eye-glow 1.5s infinite alternate;
        }
        .eye1 { top: 7px; left: 15px; }
        .eye2 { top: 7px; left: 35px; }
        @keyframes eye-glow {
            from { opacity: 0.7; transform: scale(1); }
            to { opacity: 1; transform: scale(1.1); }
        }
        .smoke {
            position: absolute;
            background: rgba(80, 80, 80, 0.4);
            border-radius: 50%;
            animation: smoke-rise 4s infinite;
            opacity: 0;
        }
        .smoke1 { width: 30px; height: 30px; left: 44px; bottom: 60px; animation-delay: 0s; }
        .smoke2 { width: 40px; height: 40px; left: 30px; bottom: 70px; animation-delay: 1s; }
        .smoke3 { width: 24px; height: 24px; left: 60px; bottom: 64px; animation-delay: 2s; }
        .smoke4, .smoke5 { display: none; }
        .evolved .smoke4 { display: block; width: 36px; height: 36px; left: 50px; bottom: 76px; animation-delay: 0.5s; }
        .evolved .smoke5 { display: block; width: 28px; height: 28px; left: 36px; bottom: 66px; animation-delay: 1.5s; }

        @keyframes smoke-rise {
            0% { transform: translateY(0) scale(1); opacity: 0.8; }
            100% { transform: translateY(-60px) scale(2.5); opacity: 0; }
        }
        .crack {
            position: absolute;
            z-index: 2;
            width: 3px;
            height: 15px;
            background: #ff4500;
            box-shadow: 0 0 4px #ff4500, 0 0 6px #ff4500, 0 0 8px #ff0000;
            border-radius: 2px;
            opacity: 0;
            transform: scale(0);
            transition: all 0.5s ease-out;
        }
        .crack1 { top: 5px; left: 25px; transform: rotate(25deg) scale(0); }
        .crack2 { top: 2px; left: 45px; transform: rotate(-35deg) scale(0); height: 18px; }
        .evolved .crack {
            opacity: 1;
            transform: rotate(25deg) scale(1);
        }
        .evolved .crack2 {
             transform: rotate(-35deg) scale(1);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-700 via-gray-800 to-gray-900 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-white mb-2" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">Bảo Vệ Trái Tim</h1>
        <p class="text-gray-300 mb-4" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">Mỗi trái tim được cứu là một thông điệp sức khỏe!</p>

        <div id="game-container" class="relative">
             <div class="danger-zone">
                <div id="cigarette-sprite">
                    <div class="smoke smoke1"></div>
                    <div class="smoke smoke2"></div>
                    <div class="smoke smoke3"></div>
                    <div class="smoke smoke4"></div>
                    <div class="smoke smoke5"></div>
                    <div class="cigarette-body">
                        <div class="cigar-main">
                           <div class="cigar-ash"></div>
                        </div>
                        <div class="cigar-filter"></div>
                        <div class="eye eye1"></div>
                        <div class="eye eye2"></div>
                        <div class="crack crack1"></div>
                        <div class="crack crack2"></div>
                    </div>
                </div>
             </div>
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="mt-4 p-4 bg-black/20 rounded-2xl shadow-lg flex justify-around items-center backdrop-blur-sm border border-white/10">
            <div>
                <p class="text-lg font-bold text-white/70">Trái tim đã cứu</p>
                <p id="score" class="text-3xl font-bold text-white">0</p>
            </div>
            <div>
                <p class="text-lg font-bold text-white/70">Nước đi</p>
                <p id="moves" class="text-3xl font-bold text-white">0</p>
            </div>
        </div>
    </div>

    <!-- Modal Game Over -->
    <div id="gameOverModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm">
        <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
            <h2 class="text-4xl font-bold text-red-800 mb-4">Nguy hiểm!</h2>
            <p class="text-lg text-gray-700 mb-2">Thuốc lá đã làm hại một trái tim.</p>
            <p class="text-xl text-gray-800 mb-6">Bạn đã bảo vệ được <span id="finalScore" class="font-bold text-pink-600">0</span> trái tim.</p>
            <button id="restartButton" class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-300">Chơi lại</button>
        </div>
    </div>
    
    <!-- Modal Thông điệp sức khỏe -->
    <div id="factModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm">
        <div class="bg-white rounded-2xl p-6 md:p-8 text-center shadow-2xl transform transition-all scale-95 max-w-md w-full">
            <h2 class="text-2xl md:text-3xl font-bold text-blue-700 mb-4">Sự Thật & Lời Khuyên</h2>
            <p id="factText" class="text-base md:text-lg text-gray-800 mb-3 text-left"></p>
            <p id="adviceText" class="text-base md:text-lg text-green-700 font-semibold mb-6 text-left"></p>
            <button id="closeFactButton" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">Đã hiểu</button>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const movesEl = document.getElementById('moves');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const cigaretteEl = document.getElementById('cigarette-sprite');
        const factModal = document.getElementById('factModal');
        const factText = document.getElementById('factText');
        const adviceText = document.getElementById('adviceText');
        const closeFactButton = document.getElementById('closeFactButton');

        // --- Dữ liệu tuyên truyền ---
        const HEALTH_FACTS = [
            { fact: "Hầu hết thuốc lá điện tử chứa Nicotine, một chất gây nghiện cao có trong thuốc lá truyền thống. Nicotine đặc biệt có hại cho sự phát triển não bộ của thanh thiếu niên. (Nguồn: CDC Hoa Kỳ)", advice: "Lời khuyên: Hãy bảo vệ tương lai của bạn bằng cách nói không với tất cả các sản phẩm chứa nicotine." },
            { fact: "Aerosol (khói) từ thuốc lá điện tử không phải là 'hơi nước' vô hại. Nó chứa các chất độc hại như kim loại nặng (niken, thiếc, chì) và các hợp chất hữu cơ dễ bay hơi. (Nguồn: WHO)", advice: "Lời khuyên: Đừng để những lời quảng cáo đánh lừa. Hít thở không khí trong lành luôn là lựa chọn tốt nhất cho lá phổi của bạn." },
            { fact: "Sử dụng thuốc lá điện tử có liên quan đến các bệnh phổi nghiêm trọng, bao gồm 'tổn thương phổi do thuốc lá điện tử' (EVALI), có thể gây tử vong. (Nguồn: CDC Hoa Kỳ)", advice: "Lời khuyên: Mỗi lần từ chối thuốc lá điện tử là một lần bạn bảo vệ lá phổi khỏi những tổn thương không thể phục hồi." },
            { fact: "Nicotine trong thuốc lá điện tử có thể làm tăng huyết áp và nhịp tim, làm tăng nguy cơ bị đau tim. (Nguồn: American Heart Association)", advice: "Lời khuyên: Giữ cho trái tim của bạn luôn khỏe mạnh bằng cách tránh xa nicotine dưới mọi hình thức." },
            { fact: "Hương liệu trong thuốc lá điện tử có thể chứa diacetyl, một hóa chất liên quan đến bệnh phổi nghiêm trọng được gọi là 'phổi bỏng ngô'. (Nguồn: American Lung Association)", advice: "Lời khuyên: Những mùi hương hấp dẫn có thể che giấu những hóa chất cực kỳ nguy hiểm. Hãy lựa chọn sức khỏe thay vì hương vị nhân tạo." },
            { fact: "Thanh thiếu niên sử dụng thuốc lá điện tử có khả năng chuyển sang hút thuốc lá truyền thống cao hơn so với những người không sử dụng. (Nguồn: National Academies of Sciences, Engineering, and Medicine)", advice: "Lời khuyên: Đừng mở cánh cửa đầu tiên dẫn đến nghiện ngập. Tránh xa thuốc lá điện tử là cách tốt nhất để không bao giờ trở thành người hút thuốc." },
            { fact: "Pin của thiết bị thuốc lá điện tử có thể bị lỗi và gây cháy nổ, dẫn đến thương tích nghiêm trọng. (Nguồn: FDA Hoa Kỳ)", advice: "Lời khuyên: Nguy cơ cháy nổ là có thật. Đừng đánh cược sự an toàn của bản thân và những người xung quanh." }
        ];
        let factsShown = [];

        // --- Cấu hình game ---
        const GRID_SIZE = 8;
        const GEM_COLORS = ['#FF3131', '#00FF7F', '#1E90FF', '#FF00FF', '#FF8C00', '#FFFF00'];
        const HEART_EMOJI = '💗';
        const MOVES_PER_HEART_SPAWN = 3; 
        const LUNGE_CHANCE = 0.25;
        const SPECIAL_TYPES = {
            NONE: 'none',
            H_BEAM: 'h_beam',
            V_BEAM: 'v_beam',
            BOMB: 'bomb',
            HYPERCUBE: 'hypercube'
        };

        let gemSize;
        let board = [];
        let selectedGem = null;
        let score = 0;
        let moves = 0;
        let isAnimating = false;
        let isPaused = false;
        let animations = [];
        let particles = [];
        let cigarette = { col: Math.floor(GRID_SIZE / 2), level: 1 };
        
        let startDragPos = { x: null, y: null };
        let startGem = null;
        let isDragging = false;


        // --- Khởi tạo và Thiết lập Game ---
        function init() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth;
            canvas.width = containerWidth;
            canvas.height = containerWidth;
            gemSize = canvas.width / GRID_SIZE;
            
            ctx.font = `${gemSize * 0.7}px sans-serif`;

            cigarette.col = Math.floor(GRID_SIZE / 2);
            cigarette.level = 1;
            cigaretteEl.classList.remove('evolved');
            updateCigarettePosition();

            board = [];
            score = 0;
            moves = 0;
            selectedGem = null;
            isAnimating = false;
            isPaused = false;
            animations = [];
            particles = [];
            factsShown = [];
            
            updateScore();
            updateMoves();
            createBoard();
            
            let matches = findMatches(board);
            while (matches.length > 0) {
                for (const gem of matches) {
                    let newColorIndex;
                    do {
                        newColorIndex = Math.floor(Math.random() * GEM_COLORS.length);
                    } while (newColorIndex === gem.colorIndex);
                    board[gem.row][gem.col].colorIndex = newColorIndex;
                }
                matches = findMatches(board);
            }
            
            spawnHeartIfNeeded(true);
            requestAnimationFrame(gameLoop);
        }

        function createBoard() {
            for (let row = 0; row < GRID_SIZE; row++) {
                board[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    board[row][col] = {
                        colorIndex: Math.floor(Math.random() * GEM_COLORS.length),
                        isHeart: false,
                        special: SPECIAL_TYPES.NONE,
                        row: row,
                        col: col,
                        x: col * gemSize,
                        y: row * gemSize,
                        scale: 1,
                        alpha: 1,
                    };
                }
            }
        }

        // --- Vòng lặp Game và Vẽ ---
        function gameLoop(time) {
            if (!isPaused) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                handleAnimations(time);
                drawBoard(time);
                drawParticles();
                drawSelection(time);
            }
            if(!gameOverModal.classList.contains('hidden')) {
                 // Dừng game loop khi thua
            } else {
                 requestAnimationFrame(gameLoop);
            }
        }

        function drawGem(x, y, size, color, special, isHeart, time) {
            const s = size * 0.85;
            const half = s / 2;
            const pulse = Math.sin(time / 150) * 0.2 + 0.8;

            ctx.save();
            ctx.translate(x, y);
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;

            if (isHeart) {
                const heartPulse = Math.sin(time / 300) * 0.15 + 0.9;
                const heartGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, half * heartPulse * 1.3);
                heartGlow.addColorStop(0, 'rgba(255, 182, 193, 0.8)');
                heartGlow.addColorStop(1, 'rgba(255, 182, 193, 0)');
                ctx.fillStyle = heartGlow;
                ctx.beginPath();
                ctx.arc(0, 0, half * 1.3, 0, Math.PI * 2);
                ctx.fill();
            }

            if (special === SPECIAL_TYPES.HYPERCUBE) {
                ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                ctx.shadowBlur = 20;
                for (let i = 0; i < 6; i++) {
                    ctx.fillStyle = GEM_COLORS[(i + Math.floor(time / 200)) % 6];
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    const angle1 = (i / 6) * 2 * Math.PI + (time / 1000);
                    const angle2 = ((i+1) / 6) * 2 * Math.PI + (time/1000);
                    ctx.arc(0,0, half, angle1, angle2);
                    ctx.closePath();
                    ctx.fill();
                }
                const pulseCore = Math.sin(time / 200) * 0.2 + 0.8;
                ctx.fillStyle = `rgba(255, 255, 255, ${pulseCore})`;
                ctx.beginPath();
                ctx.arc(0, 0, half * 0.3, 0, 2 * Math.PI);
                ctx.fill();

            } else {
                const shadeColor = (col, percent) => {
                    let f=parseInt(col.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
                    return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
                };

                const lightColor = shadeColor(color, 0.6);
                const darkColor = shadeColor(color, -0.6);

                const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, half);
                grad.addColorStop(0, lightColor);
                grad.addColorStop(1, color);
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(0, -half); ctx.lineTo(half, 0); ctx.lineTo(0, half); ctx.lineTo(-half, 0);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = darkColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.moveTo(-half * 0.8, -half * 0.2);
                ctx.lineTo(0, -half * 0.8);
                ctx.lineTo(half * 0.2, -half * 0.6);
                ctx.closePath();
                ctx.fill();

                ctx.save();
                if (special === SPECIAL_TYPES.H_BEAM || special === SPECIAL_TYPES.V_BEAM) {
                    const beamPulse = Math.sin(time / 250) * 2.0 + 3.0;
                    ctx.fillStyle = 'white';
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 20 * pulse;
                    if(special === SPECIAL_TYPES.H_BEAM) {
                        const beamWidth = half * 0.8 * beamPulse;
                        const beamHeight = half * 0.15;
                        const tipOffset = beamHeight * 2;
                        ctx.beginPath();
                        ctx.moveTo(-beamWidth / 2, 0);
                        ctx.lineTo(-beamWidth / 2 + tipOffset, -beamHeight / 2);
                        ctx.lineTo(beamWidth / 2 - tipOffset, -beamHeight / 2);
                        ctx.lineTo(beamWidth / 2, 0);
                        ctx.lineTo(beamWidth / 2 - tipOffset, beamHeight / 2);
                        ctx.lineTo(-beamWidth / 2 + tipOffset, beamHeight / 2);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        const beamHeight = half * 0.8 * beamPulse;
                        const beamWidth = half * 0.15;
                        const tipOffset = beamWidth * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -beamHeight / 2);
                        ctx.lineTo(beamWidth / 2, -beamHeight / 2 + tipOffset);
                        ctx.lineTo(beamWidth / 2, beamHeight / 2 - tipOffset);
                        ctx.lineTo(0, beamHeight / 2);
                        ctx.lineTo(-beamWidth / 2, beamHeight / 2 - tipOffset);
                        ctx.lineTo(-beamWidth / 2, -beamHeight / 2 + tipOffset);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else if (special === SPECIAL_TYPES.BOMB) {
                    ctx.scale(pulse, pulse);
                    ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(0, 0, half * 0.6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.fillStyle = `hsl(${time / 10 % 60}, 100%, 50%)`;
                    ctx.shadowColor = `hsl(${time / 10 % 60}, 100%, 50%)`;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, -half * 0.5, size * 0.05, 0, 2 * Math.PI);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            ctx.restore();
        }

        function drawBoard(time) {
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const gem = board[row][col];
                    if (gem) {
                        const centerX = gem.x + gemSize / 2;
                        const centerY = gem.y + gemSize / 2;
                        
                        ctx.save();
                        ctx.globalAlpha = gem.alpha;
                        ctx.translate(centerX, centerY);
                        ctx.scale(gem.scale, gem.scale);
                        ctx.translate(-centerX, -centerY);
                        
                        const color = gem.special === SPECIAL_TYPES.HYPERCUBE ? null : GEM_COLORS[gem.colorIndex];
                        drawGem(centerX, centerY, gemSize, color, gem.special, gem.isHeart, time);
                        
                        if (gem.isHeart) {
                            const heartPulse = Math.sin(time / 300) * 0.75 + 1.25;
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.scale(heartPulse, heartPulse);
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'rgba(0,0,0,0)';
                            ctx.font = `${gemSize * 0.6}px sans-serif`;
                            ctx.fillText(HEART_EMOJI, 0, 0);
                            ctx.restore();
                        }
                        ctx.restore();
                    }
                }
            }
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.02;
                if (p.alpha <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function drawSelection(time) {
            if (selectedGem) {
                const pulse = Math.sin(time / 100) * 0.5 + 0.5;
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
            }
        }

        // --- Xử lý sự kiện người dùng (CƠ CHẾ LƯỚT) ---
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function handleDragStart(e) {
            e.preventDefault();
            if (isAnimating || isPaused) return;
            const pos = getEventPos(e);
            const col = Math.floor(pos.x / gemSize);
            const row = Math.floor(pos.y / gemSize);

            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                isDragging = true;
                startDragPos = pos;
                startGem = board[row][col];
                selectedGem = startGem;
            }
        }

        function handleDragMove(e) {
            e.preventDefault();
            if (!isDragging || isAnimating || isPaused) return;
            
            const pos = getEventPos(e);
            const deltaX = pos.x - startDragPos.x;
            const deltaY = pos.y - startDragPos.y;
            
            if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) {
                let endGem = null;
                if (Math.abs(deltaX) > Math.abs(deltaY)) { // Lướt ngang
                    const endCol = startGem.col + (deltaX > 0 ? 1 : -1);
                    if (endCol >= 0 && endCol < GRID_SIZE) {
                        endGem = board[startGem.row][endCol];
                    }
                } else { // Lướt dọc
                    const endRow = startGem.row + (deltaY > 0 ? 1 : -1);
                     if (endRow >= 0 && endRow < GRID_SIZE) {
                        endGem = board[endRow][startGem.col];
                    }
                }

                if (endGem) {
                    isDragging = false;
                    selectedGem = null;
                    processSwap(startGem, endGem);
                }
            }
        }

        function handleDragEnd(e) {
            isDragging = false;
            startGem = null;
            selectedGem = null;
        }

        canvas.addEventListener('mousedown', handleDragStart);
        canvas.addEventListener('mousemove', handleDragMove);
        canvas.addEventListener('mouseup', handleDragEnd);
        canvas.addEventListener('mouseleave', handleDragEnd);
        canvas.addEventListener('touchstart', handleDragStart, { passive: false });
        canvas.addEventListener('touchmove', handleDragMove, { passive: false });
        canvas.addEventListener('touchend', handleDragEnd);

        // --- Logic Game Chính ---
        async function processSwap(gem1, gem2) {
            isAnimating = true;
            selectedGem = null;

            const isGem1Beam = gem1.special === SPECIAL_TYPES.H_BEAM || gem1.special === SPECIAL_TYPES.V_BEAM;
            const isGem2Beam = gem2.special === SPECIAL_TYPES.H_BEAM || gem2.special === SPECIAL_TYPES.V_BEAM;

            if (isGem1Beam && isGem2Beam) {
                let gemsToClear = new Set([gem1, gem2]);
                for(let c=0; c<GRID_SIZE; c++) { if(board[gem1.row][c]) gemsToClear.add(board[gem1.row][c]); }
                for(let r=0; r<GRID_SIZE; r++) { if(board[r][gem2.col]) gemsToClear.add(board[r][gem2.col]); }
                moves++;
                updateMoves();
                await cascadeMatches(Array.from(gemsToClear));
            } else if (gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE) {
                const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
                const otherGem = hypercube === gem1 ? gem2 : gem1;
                let gemsToClear = new Set([hypercube]);
                if (otherGem.special !== SPECIAL_TYPES.HYPERCUBE) {
                    const targetColorIndex = otherGem.colorIndex;
                    for(let r=0; r<GRID_SIZE; r++) {
                        for(let c=0; c<GRID_SIZE; c++) {
                            if(board[r][c] && board[r][c].colorIndex === targetColorIndex) {
                                gemsToClear.add(board[r][c]);
                            }
                        }
                    }
                }
                moves++;
                updateMoves();
                await cascadeMatches(Array.from(gemsToClear));
            } else {
                await swapGems(gem1, gem2);
                const matchInfo = findMatchesAndSpecial(gem1, gem2);
                if (matchInfo.allMatches.length > 0) {
                    moves++;
                    updateMoves();
                    await cascadeMatches(matchInfo.allMatches, matchInfo.specialToCreate);
                } else {
                    await swapGems(gem1, gem2);
                }
            }
            
            if (gameOverModal.classList.contains('hidden')) {
                await moveCigarette();
                if (checkGameOver()) {
                    isAnimating = false;
                    return;
                }
                spawnHeartIfNeeded();
            }
            
            isAnimating = false;
        }
        
        async function cascadeMatches(initialMatches, specialToCreate = null) {
            let gemsToClear = new Set(initialMatches);
            let processedSpecials = new Set();
            
            while(true) {
                let newGemsFromExplosion = new Set();
                let foundNewExplosion = false;
                for(const gem of gemsToClear) {
                    if(gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                        foundNewExplosion = true;
                        processedSpecials.add(gem);
                        getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                    }
                }
                if(!foundNewExplosion) break;
                newGemsFromExplosion.forEach(g => gemsToClear.add(g));
            }

            const savedAHeart = await handleMatches(Array.from(gemsToClear), specialToCreate);
            if (savedAHeart) {
                await showFact();
            }

            await sleep(150);
            await shiftAndRefill();
            
            const nextMatches = findMatches(board);
            if (nextMatches.length > 0) {
                await cascadeMatches(nextMatches);
            } else {
                 await moveHearts();
            }
        }

        function getSpecialEffectGems(gem) {
            let affected = new Set();
            if (gem.special === SPECIAL_TYPES.H_BEAM) {
                for(let c=0; c<GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); }
            } else if (gem.special === SPECIAL_TYPES.V_BEAM) {
                for(let r=0; r<GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); }
            } else if (gem.special === SPECIAL_TYPES.BOMB) {
                for(let r = gem.row - 1; r <= gem.row + 1; r++) {
                    for(let c = gem.col - 1; c <= gem.col + 1; c++) {
                        if(r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[r][c]) {
                            affected.add(board[r][c]);
                        }
                    }
                }
            }
            return affected;
        }

        function swapGems(gem1, gem2) {
            const r1 = gem1.row, c1 = gem1.col;
            const r2 = gem2.row, c2 = gem2.col;
            board[r1][c1] = gem2;
            board[r2][c2] = gem1;
            gem1.row = r2; gem1.col = c2;
            gem2.row = r1; gem2.col = c1;
            const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, 150, easing.easeInOutQuad);
            const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, 150, easing.easeInOutQuad);
            return Promise.all([p1, p2]);
        }
        
        function findMatches(currentBoard) {
            const matches = new Set();
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE - 2; c++) {
                    const gem1 = currentBoard[r][c];
                    const gem2 = currentBoard[r][c+1];
                    const gem3 = currentBoard[r][c+2];
                    if (gem1 && gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                        matches.add(gem1); matches.add(gem2); matches.add(gem3);
                    }
                }
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE - 2; r++) {
                     const gem1 = currentBoard[r][c];
                    const gem2 = currentBoard[r+1][c];
                    const gem3 = currentBoard[r+2][c];
                    if (gem1 && gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                        matches.add(gem1); matches.add(gem2); matches.add(gem3);
                    }
                }
            }
            return Array.from(matches);
        }

        function findMatchesAndSpecial(gem1, gem2) {
            let allMatches = new Set();
            let specialToCreate = null;
            
            const checkLine = (line) => {
                let matches = [];
                for(let i=0; i<line.length - 2; i++) {
                    if(line[i] && line[i+1] && line[i+2] && line[i].colorIndex === line[i+1].colorIndex && line[i+1].colorIndex === line[i+2].colorIndex) {
                        let len = 3;
                        while(i+len < line.length && line[i].colorIndex === line[i+len].colorIndex) len++;
                        let currentMatch = [];
                        for(let j=0; j<len; j++) currentMatch.push(line[i+j]);
                        matches.push(currentMatch);
                        i += len - 1;
                    }
                }
                return matches;
            }

            const hMatches1 = checkLine(board[gem1.row]);
            const vMatches1 = checkLine(board.map(r => r[gem1.col]));
            const hMatches2 = checkLine(board[gem2.row]);
            const vMatches2 = checkLine(board.map(r => r[gem2.col]));
            
            const allFoundMatches = [...hMatches1, ...vMatches1, ...hMatches2, ...vMatches2];
            allFoundMatches.forEach(m => m.forEach(g => allMatches.add(g)));

            const hMatches = [...hMatches1, ...hMatches2];
            const vMatches = [...vMatches1, ...vMatches2];

            let bestMatch = {len: 0, match: null, type: null, isCross: false};

            for(const match of allFoundMatches) {
                if(match.includes(gem1) || match.includes(gem2)) {
                    if (match.length >= 5) {
                        bestMatch = { len: match.length, match, type: (match[0].row === match[1].row) ? 'h' : 'v', isCross: false };
                        break;
                    }
                    if (match.length === 4 && bestMatch.len < 4) {
                        bestMatch = { len: 4, match, type: (match[0].row === match[1].row) ? 'h' : 'v', isCross: false };
                    }
                }
            }
            
            const intersection = hMatches.flat().filter(gem => vMatches.flat().includes(gem));
            if (intersection.length > 0 && allMatches.size >= 5) {
                bestMatch = { len: 5, match: intersection, type: 'cross', isCross: true };
            }


            if (bestMatch.len >= 5 && !bestMatch.isCross) {
                specialToCreate = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: -1 };
            } else if (bestMatch.isCross) {
                 specialToCreate = { special: SPECIAL_TYPES.BOMB, colorIndex: gem1.colorIndex };
            } else if (bestMatch.len === 4) {
                specialToCreate = { special: bestMatch.type === 'h' ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: gem1.colorIndex };
            }
            
            if(specialToCreate && bestMatch.match) {
                 const creationGem = bestMatch.match.includes(gem1) ? gem1 : gem2;
                 specialToCreate.row = creationGem.row;
                 specialToCreate.col = creationGem.col;
            }

            return { allMatches: Array.from(allMatches), specialToCreate };
        }
        
        async function handleMatches(matches, specialToCreate) {
            const promises = [];
            let heartSaved = false;
            matches.forEach(gem => {
                if(specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) {
                    // Skip
                } else {
                    if (gem.isHeart) {
                        score++;
                        updateScore();
                        heartSaved = true;
                    }
                    for(let i=0; i<10; i++) {
                        particles.push({
                            x: gem.x + gemSize / 2,
                            y: gem.y + gemSize / 2,
                            vx: (Math.random() - 0.5) * 6,
                            vy: (Math.random() - 0.5) * 6,
                            size: Math.random() * 4 + 2,
                            color: GEM_COLORS[gem.colorIndex],
                            alpha: 1
                        });
                    }
                    const p = animate(gem, { scale: 0, alpha: 0 }, 200, easing.easeInQuad);
                    p.then(() => { board[gem.row][gem.col] = null; });
                    promises.push(p);
                }
            });
            await Promise.all(promises);

            if (specialToCreate) {
                const gem = board[specialToCreate.row][specialToCreate.col];
                gem.special = specialToCreate.special;
                gem.colorIndex = specialToCreate.colorIndex;
                gem.isHeart = false;
                await animate(gem, {scale: 1.5}, 150, easing.easeOutQuad).then(() => animate(gem, {scale: 1}, 150, easing.easeInQuad));
            }
            return heartSaved;
        }

        async function shiftAndRefill() {
            const shiftPromises = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                let emptySlots = 0;
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    if (board[r][c] === null) {
                        emptySlots++;
                    } else if (emptySlots > 0) {
                        const gem = board[r][c];
                        board[r + emptySlots][c] = gem;
                        board[r][c] = null;
                        gem.row += emptySlots;
                        shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300, easing.easeOutQuad));
                    }
                }
            }
            await Promise.all(shiftPromises);

            const refillPromises = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (board[r][c] === null) {
                        const newGem = {
                            colorIndex: Math.floor(Math.random() * GEM_COLORS.length),
                            isHeart: false, special: SPECIAL_TYPES.NONE,
                            row: r, col: c,
                            x: c * gemSize, y: (r - GRID_SIZE) * gemSize,
                            scale: 1, alpha: 1,
                        };
                        board[r][c] = newGem;
                        refillPromises.push(animate(newGem, { y: r * gemSize }, 400, easing.easeOutQuad));
                    }
                }
            }
            await Promise.all(refillPromises);
        }

        function spawnHeartIfNeeded(isFirst = false) {
             if (isFirst || (moves > 0 && moves % MOVES_PER_HEART_SPAWN === 0)) {
                let availableCols = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[GRID_SIZE - 1][c] && !board[GRID_SIZE - 1][c].isHeart && board[GRID_SIZE - 1][c].special === SPECIAL_TYPES.NONE) {
                        availableCols.push(c);
                    }
                }
                if (availableCols.length > 0) {
                    const col = availableCols[Math.floor(Math.random() * availableCols.length)];
                    const gem = board[GRID_SIZE - 1][col];
                    gem.isHeart = true;
                    gem.special = SPECIAL_TYPES.NONE;
                    animate(gem, {scale: 1.5}, 150, easing.easeOutQuad).then(() => animate(gem, {scale: 1}, 150, easing.easeInQuad));
                }
            }
        }

        async function moveHearts() {
            const movePromises = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const gem = board[r][c];
                    if (gem && gem.isHeart) {
                        const newRow = r - 1;
                        if (newRow < 0) continue;
                        const gemAbove = board[newRow][c];
                        
                        board[newRow][c] = gem;
                        board[r][c] = gemAbove;
                        
                        gem.row = newRow;
                        if (gemAbove) gemAbove.row = r;
                        
                        movePromises.push(animate(gem, { y: newRow * gemSize }, 200, easing.easeInOutQuad));
                        if (gemAbove) {
                           movePromises.push(animate(gemAbove, { y: r * gemSize }, 200, easing.easeInOutQuad));
                        }
                    }
                }
            }
            await Promise.all(movePromises);
        }

        async function moveCigarette() {
            let highestHeart = null;
            let minRow = GRID_SIZE;

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c] && board[r][c].isHeart) {
                        if (r < minRow) {
                            minRow = r;
                            highestHeart = board[r][c];
                        }
                    }
                }
            }

            if (highestHeart) {
                if (Math.random() < LUNGE_CHANCE && cigarette.level > 1) {
                    const originalCol = cigarette.col;
                    const targetCol = highestHeart.col;
                    
                    cigaretteEl.style.transition = 'left 0.1s ease-in';
                    cigaretteEl.style.left = `${targetCol * gemSize}px`;
                    await sleep(300);
                    cigaretteEl.style.transition = 'left 0.4s ease-out';
                    cigaretteEl.style.left = `${originalCol * gemSize}px`;
                    await sleep(400);
                }

                if (cigarette.col < highestHeart.col) {
                    cigarette.col++;
                } else if (cigarette.col > highestHeart.col) {
                    cigarette.col--;
                }
            }
            cigaretteEl.style.transition = 'left 0.3s ease-in-out';
            updateCigarettePosition();
        }

        function updateCigarettePosition() {
            cigaretteEl.style.left = `${cigarette.col * gemSize}px`;
        }
        
        function checkGameOver() {
            if(board[0][cigarette.col] && board[0][cigarette.col].isHeart) {
                showGameOver();
                return true;
            }
            return false;
        }

        // --- Giao diện người dùng và Tiện ích ---
        function updateScore() { 
            scoreEl.textContent = score;
            if (score === 5 && cigarette.level === 1) {
                cigarette.level = 2;
                cigaretteEl.classList.add('evolved');
            }
        }
        function updateMoves() { movesEl.textContent = moves; }

        function showGameOver() {
            isAnimating = true;
            finalScoreEl.textContent = score;
            gameOverModal.classList.remove('hidden');
            setTimeout(() => gameOverModal.querySelector('div').classList.add('scale-100'), 10);
        }

        async function showFact() {
            isPaused = true;
            let availableFacts = HEALTH_FACTS.filter(obj => !factsShown.includes(obj));
            if (availableFacts.length === 0) {
                factsShown = []; // Reset nếu đã hiển thị hết
                availableFacts = HEALTH_FACTS;
            }
            const factObject = availableFacts[Math.floor(Math.random() * availableFacts.length)];
            factsShown.push(factObject);
            factText.textContent = factObject.fact;
            adviceText.textContent = factObject.advice;
            factModal.classList.remove('hidden');
            await new Promise(resolve => {
                const listener = () => {
                    closeFactButton.removeEventListener('click', listener);
                    factModal.classList.add('hidden');
                    isPaused = false;
                    resolve();
                };
                closeFactButton.addEventListener('click', listener);
            });
        }
        
        closeFactButton.addEventListener('click', () => {
             factModal.classList.add('hidden');
             isPaused = false;
        });

        restartButton.addEventListener('click', () => {
            gameOverModal.classList.add('hidden');
            gameOverModal.querySelector('div').classList.remove('scale-100');
            init();
        });

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        
        // --- Hệ thống Animation ---
        const easing = {
            easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t)
        };

        function animate(target, toProperties, duration, easeFunc = easing.easeInOutQuad) {
            return new Promise(resolve => {
                animations.push({
                    target,
                    toProperties,
                    duration,
                    onComplete: resolve,
                    startProperties: Object.keys(toProperties).reduce((acc, key) => {
                        acc[key] = target[key];
                        return acc;
                    }, {}),
                    startTime: Date.now(),
                    easeFunc
                });
            });
        }

        function handleAnimations() {
            const now = Date.now();
            for (let i = animations.length - 1; i >= 0; i--) {
                const anim = animations[i];
                const elapsed = now - anim.startTime;
                const progressLinear = Math.min(elapsed / anim.duration, 1);
                const progress = anim.easeFunc(progressLinear);

                for (const key in anim.toProperties) {
                    const start = anim.startProperties[key];
                    const to = anim.toProperties[key];
                    anim.target[key] = start + (to - start) * progress;
                }

                if (progressLinear === 1) {
                    anim.onComplete();
                    animations.splice(i, 1);
                }
            }
        }
        
        window.onload = init;
        window.onresize = init;

    </script>
</body>
</html>
