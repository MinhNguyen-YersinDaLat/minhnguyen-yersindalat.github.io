<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Game Kim C∆∞∆°ng: B·∫£o V·ªá Tr√°i Tim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #fecaca;
        }
        canvas {
            background-color: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1), 0 6px 6px rgba(0,0,0,0.15);
        }
        .danger-zone {
            position: absolute;
            top: -10px;
            left: 0;
            right: 0;
            height: 50px;
            z-index: 10;
            pointer-events: none;
        }
        #cigarette-sprite {
            position: absolute;
            top: -15px;
            transition: left 0.3s ease-in-out;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .cigarette-body {
            position: relative;
            font-size: 2.25rem; /* 36px */
            line-height: 2.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .eye {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: #ef4444; /* red-500 */
            border-radius: 50%;
            box-shadow: 0 0 5px #ef4444, 0 0 8px #ef4444;
            animation: eye-glow 1.5s infinite alternate;
        }
        .eye1 { top: 12px; left: 10px; }
        .eye2 { top: 12px; left: 20px; }
        @keyframes eye-glow {
            from { opacity: 0.7; box-shadow: 0 0 3px #ef4444, 0 0 5px #ef4444; }
            to { opacity: 1; box-shadow: 0 0 5px #ef4444, 0 0 8px #ef4444; }
        }
        .smoke {
            position: absolute;
            background: rgba(80, 80, 80, 0.4);
            border-radius: 50%;
            animation: smoke-rise 4s infinite;
            opacity: 0;
        }
        .smoke1 { width: 15px; height: 15px; left: 22px; bottom: 30px; animation-delay: 0s; }
        .smoke2 { width: 20px; height: 20px; left: 15px; bottom: 35px; animation-delay: 1s; }
        .smoke3 { width: 12px; height: 12px; left: 30px; bottom: 32px; animation-delay: 2s; }
        @keyframes smoke-rise {
            0% { transform: translateY(0) scale(1); opacity: 0.8; }
            100% { transform: translateY(-40px) scale(2.5); opacity: 0; }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-red-200 via-gray-200 to-red-300 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-red-900 mb-2" style="text-shadow: 1px 1px 2px rgba(255,255,255,0.5);">B·∫£o V·ªá Tr√°i Tim</h1>
        <p class="text-red-800 mb-4">M·ªói tr√°i tim ƒë∆∞·ª£c c·ª©u l√† m·ªôt th√¥ng ƒëi·ªáp s·ª©c kh·ªèe!</p>

        <div id="game-container" class="relative">
             <div class="danger-zone">
                <div id="cigarette-sprite">
                    <div class="smoke smoke1"></div>
                    <div class="smoke smoke2"></div>
                    <div class="smoke smoke3"></div>
                    <div class="cigarette-body">
                        <div class="eye eye1"></div>
                        <div class="eye eye2"></div>
                        üö¨
                    </div>
                </div>
             </div>
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="mt-4 p-4 bg-white/60 rounded-xl shadow-lg flex justify-around items-center backdrop-blur-sm">
            <div>
                <p class="text-lg font-bold text-red-800">Tr√°i tim ƒë√£ c·ª©u</p>
                <p id="score" class="text-3xl font-bold text-pink-600">0</p>
            </div>
            <div>
                <p class="text-lg font-bold text-red-800">N∆∞·ªõc ƒëi</p>
                <p id="moves" class="text-3xl font-bold text-pink-600">0</p>
            </div>
        </div>
    </div>

    <!-- Modal Game Over -->
    <div id="gameOverModal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50">
        <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
            <h2 class="text-4xl font-bold text-red-800 mb-4">Nguy hi·ªÉm!</h2>
            <p class="text-lg text-gray-700 mb-2">Thu·ªëc l√° ƒë√£ l√†m h·∫°i m·ªôt tr√°i tim.</p>
            <p class="text-xl text-gray-800 mb-6">B·∫°n ƒë√£ b·∫£o v·ªá ƒë∆∞·ª£c <span id="finalScore" class="font-bold text-pink-600">0</span> tr√°i tim.</p>
            <button id="restartButton" class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-300">Ch∆°i l·∫°i</button>
        </div>
    </div>
    
    <!-- Modal Th√¥ng ƒëi·ªáp s·ª©c kh·ªèe -->
    <div id="factModal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white rounded-2xl p-6 md:p-8 text-center shadow-2xl transform transition-all scale-95 max-w-md w-full">
            <h2 class="text-2xl md:text-3xl font-bold text-blue-700 mb-4">S·ª± Th·∫≠t & L·ªùi Khuy√™n</h2>
            <p id="factText" class="text-base md:text-lg text-gray-800 mb-3 text-left"></p>
            <p id="adviceText" class="text-base md:text-lg text-green-700 font-semibold mb-6 text-left"></p>
            <button id="closeFactButton" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">ƒê√£ hi·ªÉu</button>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const movesEl = document.getElementById('moves');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const cigaretteEl = document.getElementById('cigarette-sprite');
        const factModal = document.getElementById('factModal');
        const factText = document.getElementById('factText');
        const adviceText = document.getElementById('adviceText');
        const closeFactButton = document.getElementById('closeFactButton');

        // --- D·ªØ li·ªáu tuy√™n truy·ªÅn ---
        const HEALTH_FACTS = [
            { fact: "H·∫ßu h·∫øt thu·ªëc l√° ƒëi·ªán t·ª≠ ch·ª©a Nicotine, m·ªôt ch·∫•t g√¢y nghi·ªán cao c√≥ trong thu·ªëc l√° truy·ªÅn th·ªëng. Nicotine ƒë·∫∑c bi·ªát c√≥ h·∫°i cho s·ª± ph√°t tri·ªÉn n√£o b·ªô c·ªßa thanh thi·∫øu ni√™n. (Ngu·ªìn: CDC Hoa K·ª≥)", advice: "L·ªùi khuy√™n: H√£y b·∫£o v·ªá t∆∞∆°ng lai c·ªßa b·∫°n b·∫±ng c√°ch n√≥i kh√¥ng v·ªõi t·∫•t c·∫£ c√°c s·∫£n ph·∫©m ch·ª©a nicotine." },
            { fact: "Aerosol (kh√≥i) t·ª´ thu·ªëc l√° ƒëi·ªán t·ª≠ kh√¥ng ph·∫£i l√† 'h∆°i n∆∞·ªõc' v√¥ h·∫°i. N√≥ ch·ª©a c√°c ch·∫•t ƒë·ªôc h·∫°i nh∆∞ kim lo·∫°i n·∫∑ng (niken, thi·∫øc, ch√¨) v√† c√°c h·ª£p ch·∫•t h·ªØu c∆° d·ªÖ bay h∆°i. (Ngu·ªìn: WHO)", advice: "L·ªùi khuy√™n: ƒê·ª´ng ƒë·ªÉ nh·ªØng l·ªùi qu·∫£ng c√°o ƒë√°nh l·ª´a. H√≠t th·ªü kh√¥ng kh√≠ trong l√†nh lu√¥n l√† l·ª±a ch·ªçn t·ªët nh·∫•t cho l√° ph·ªïi c·ªßa b·∫°n." },
            { fact: "S·ª≠ d·ª•ng thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ li√™n quan ƒë·∫øn c√°c b·ªánh ph·ªïi nghi√™m tr·ªçng, bao g·ªìm 't·ªïn th∆∞∆°ng ph·ªïi do thu·ªëc l√° ƒëi·ªán t·ª≠' (EVALI), c√≥ th·ªÉ g√¢y t·ª≠ vong. (Ngu·ªìn: CDC Hoa K·ª≥)", advice: "L·ªùi khuy√™n: M·ªói l·∫ßn t·ª´ ch·ªëi thu·ªëc l√° ƒëi·ªán t·ª≠ l√† m·ªôt l·∫ßn b·∫°n b·∫£o v·ªá l√° ph·ªïi kh·ªèi nh·ªØng t·ªïn th∆∞∆°ng kh√¥ng th·ªÉ ph·ª•c h·ªìi." },
            { fact: "Nicotine trong thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ th·ªÉ l√†m tƒÉng huy·∫øt √°p v√† nh·ªãp tim, l√†m tƒÉng nguy c∆° b·ªã ƒëau tim. (Ngu·ªìn: American Heart Association)", advice: "L·ªùi khuy√™n: Gi·ªØ cho tr√°i tim c·ªßa b·∫°n lu√¥n kh·ªèe m·∫°nh b·∫±ng c√°ch tr√°nh xa nicotine d∆∞·ªõi m·ªçi h√¨nh th·ª©c." },
            { fact: "H∆∞∆°ng li·ªáu trong thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ th·ªÉ ch·ª©a diacetyl, m·ªôt h√≥a ch·∫•t li√™n quan ƒë·∫øn b·ªánh ph·ªïi nghi√™m tr·ªçng ƒë∆∞·ª£c g·ªçi l√† 'ph·ªïi b·ªèng ng√¥'. (Ngu·ªìn: American Lung Association)", advice: "L·ªùi khuy√™n: Nh·ªØng m√πi h∆∞∆°ng h·∫•p d·∫´n c√≥ th·ªÉ che gi·∫•u nh·ªØng h√≥a ch·∫•t c·ª±c k·ª≥ nguy hi·ªÉm. H√£y l·ª±a ch·ªçn s·ª©c kh·ªèe thay v√¨ h∆∞∆°ng v·ªã nh√¢n t·∫°o." },
            { fact: "Thanh thi·∫øu ni√™n s·ª≠ d·ª•ng thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ kh·∫£ nƒÉng chuy·ªÉn sang h√∫t thu·ªëc l√° truy·ªÅn th·ªëng cao h∆°n so v·ªõi nh·ªØng ng∆∞·ªùi kh√¥ng s·ª≠ d·ª•ng. (Ngu·ªìn: National Academies of Sciences, Engineering, and Medicine)", advice: "L·ªùi khuy√™n: ƒê·ª´ng m·ªü c√°nh c·ª≠a ƒë·∫ßu ti√™n d·∫´n ƒë·∫øn nghi·ªán ng·∫≠p. Tr√°nh xa thu·ªëc l√° ƒëi·ªán t·ª≠ l√† c√°ch t·ªët nh·∫•t ƒë·ªÉ kh√¥ng bao gi·ªù tr·ªü th√†nh ng∆∞·ªùi h√∫t thu·ªëc." },
            { fact: "Pin c·ªßa thi·∫øt b·ªã thu·ªëc l√° ƒëi·ªán t·ª≠ c√≥ th·ªÉ b·ªã l·ªói v√† g√¢y ch√°y n·ªï, d·∫´n ƒë·∫øn th∆∞∆°ng t√≠ch nghi√™m tr·ªçng. (Ngu·ªìn: FDA Hoa K·ª≥)", advice: "L·ªùi khuy√™n: Nguy c∆° ch√°y n·ªï l√† c√≥ th·∫≠t. ƒê·ª´ng ƒë√°nh c∆∞·ª£c s·ª± an to√†n c·ªßa b·∫£n th√¢n v√† nh·ªØng ng∆∞·ªùi xung quanh." }
        ];
        let factsShown = [];

        // --- C·∫•u h√¨nh game ---
        const GRID_SIZE = 8;
        const GEM_COLORS = ['#FF5A5A', '#52E862', '#4BA2FF', '#C355F4', '#FFB44B', '#F8DE4F'];
        const HEART_EMOJI = 'üíó';
        const MOVES_PER_HEART_SPAWN = 3; 
        const SPECIAL_TYPES = {
            NONE: 'none',
            H_BEAM: 'h_beam',
            V_BEAM: 'v_beam',
            BOMB: 'bomb',
            HYPERCUBE: 'hypercube'
        };

        let gemSize;
        let board = [];
        let selectedGem = null;
        let score = 0;
        let moves = 0;
        let isAnimating = false;
        let isPaused = false;
        let animations = [];
        let cigarette = { col: Math.floor(GRID_SIZE / 2) };
        
        // Bi·∫øn cho c∆° ch·∫ø l∆∞·ªõt
        let startDragPos = { x: null, y: null };
        let startGem = null;
        let isDragging = false;


        // --- Kh·ªüi t·∫°o v√† Thi·∫øt l·∫≠p Game ---
        function init() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth;
            canvas.width = containerWidth;
            canvas.height = containerWidth;
            gemSize = canvas.width / GRID_SIZE;
            
            ctx.font = `${gemSize * 0.7}px sans-serif`;

            cigarette.col = Math.floor(GRID_SIZE / 2);
            updateCigarettePosition();

            board = [];
            score = 0;
            moves = 0;
            selectedGem = null;
            isAnimating = false;
            isPaused = false;
            animations = [];
            factsShown = [];
            
            updateScore();
            updateMoves();
            createBoard();
            
            let matches = findMatches(board);
            while (matches.length > 0) {
                for (const gem of matches) {
                    let newColorIndex;
                    do {
                        newColorIndex = Math.floor(Math.random() * GEM_COLORS.length);
                    } while (newColorIndex === gem.colorIndex);
                    board[gem.row][gem.col].colorIndex = newColorIndex;
                }
                matches = findMatches(board);
            }
            
            spawnHeartIfNeeded(true);
            requestAnimationFrame(gameLoop);
        }

        function createBoard() {
            for (let row = 0; row < GRID_SIZE; row++) {
                board[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    board[row][col] = {
                        colorIndex: Math.floor(Math.random() * GEM_COLORS.length),
                        isHeart: false,
                        special: SPECIAL_TYPES.NONE,
                        row: row,
                        col: col,
                        x: col * gemSize,
                        y: row * gemSize,
                        scale: 1,
                        alpha: 1,
                    };
                }
            }
        }

        // --- V√≤ng l·∫∑p Game v√† V·∫Ω ---
        function gameLoop(time) {
            if (!isPaused) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                handleAnimations(time);
                drawBoard(time);
                drawSelection();
            }
            if(!gameOverModal.classList.contains('hidden')) {
                 // D·ª´ng game loop khi thua
            } else {
                 requestAnimationFrame(gameLoop);
            }
        }

        function drawGem(x, y, size, color, special, time) {
            const s = size * 0.8;
            const half = s / 2;
            ctx.save();
            ctx.translate(x, y);
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;

            if (special === SPECIAL_TYPES.HYPERCUBE) {
                for (let i = 0; i < 6; i++) {
                    ctx.fillStyle = GEM_COLORS[(i + Math.floor(time / 200)) % 6];
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    const angle1 = (i / 6) * 2 * Math.PI + (time / 1000);
                    const angle2 = ((i+1) / 6) * 2 * Math.PI + (time/1000);
                    ctx.arc(0,0, half, angle1, angle2);
                    ctx.closePath();
                    ctx.fill();
                }
            } else {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(0, -half); ctx.lineTo(half, 0); ctx.lineTo(0, half); ctx.lineTo(-half, 0);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(0, -half); ctx.lineTo(half, 0); ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.moveTo(-half, 0); ctx.lineTo(0, half); ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();

                const pulse = Math.sin(time / 150) * 0.2 + 0.8;
                ctx.globalAlpha = pulse;
                if (special === SPECIAL_TYPES.H_BEAM) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(-half * 0.7, -half * 0.15, half * 1.4, half * 0.3);
                } else if (special === SPECIAL_TYPES.V_BEAM) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(-half * 0.15, -half * 0.7, half * 0.3, half * 1.4);
                } else if (special === SPECIAL_TYPES.BOMB) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, half * 0.6, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }

        function drawBoard(time) {
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const gem = board[row][col];
                    if (gem) {
                        const centerX = gem.x + gemSize / 2;
                        const centerY = gem.y + gemSize / 2;
                        
                        ctx.save();
                        ctx.globalAlpha = gem.alpha;
                        ctx.translate(centerX, centerY);
                        ctx.scale(gem.scale, gem.scale);
                        ctx.translate(-centerX, -centerY);
                        
                        const color = gem.special === SPECIAL_TYPES.HYPERCUBE ? null : GEM_COLORS[gem.colorIndex];
                        drawGem(centerX, centerY, gemSize, color, gem.special, time);
                        
                        if (gem.isHeart) {
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'rgba(0,0,0,0)';
                            ctx.fillText(HEART_EMOJI, centerX, centerY + gemSize * 0.05);
                        }
                        ctx.restore();
                    }
                }
            }
        }

        function drawSelection() {
            if (selectedGem) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 4;
                ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
            }
        }

        // --- X·ª≠ l√Ω s·ª± ki·ªán ng∆∞·ªùi d√πng (C∆† CH·∫æ L∆Ø·ªöT) ---
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function handleDragStart(e) {
            e.preventDefault();
            if (isAnimating || isPaused) return;
            const pos = getEventPos(e);
            const col = Math.floor(pos.x / gemSize);
            const row = Math.floor(pos.y / gemSize);

            if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                isDragging = true;
                startDragPos = pos;
                startGem = board[row][col];
                selectedGem = startGem;
            }
        }

        function handleDragMove(e) {
            e.preventDefault();
            if (!isDragging || isAnimating || isPaused) return;
            
            const pos = getEventPos(e);
            const deltaX = pos.x - startDragPos.x;
            const deltaY = pos.y - startDragPos.y;
            
            if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) {
                let endGem = null;
                if (Math.abs(deltaX) > Math.abs(deltaY)) { // L∆∞·ªõt ngang
                    const endCol = startGem.col + (deltaX > 0 ? 1 : -1);
                    if (endCol >= 0 && endCol < GRID_SIZE) {
                        endGem = board[startGem.row][endCol];
                    }
                } else { // L∆∞·ªõt d·ªçc
                    const endRow = startGem.row + (deltaY > 0 ? 1 : -1);
                     if (endRow >= 0 && endRow < GRID_SIZE) {
                        endGem = board[endRow][startGem.col];
                    }
                }

                if (endGem) {
                    isDragging = false;
                    selectedGem = null;
                    processSwap(startGem, endGem);
                }
            }
        }

        function handleDragEnd(e) {
            isDragging = false;
            startGem = null;
            selectedGem = null;
        }

        canvas.addEventListener('mousedown', handleDragStart);
        canvas.addEventListener('mousemove', handleDragMove);
        canvas.addEventListener('mouseup', handleDragEnd);
        canvas.addEventListener('mouseleave', handleDragEnd);
        canvas.addEventListener('touchstart', handleDragStart, { passive: false });
        canvas.addEventListener('touchmove', handleDragMove, { passive: false });
        canvas.addEventListener('touchend', handleDragEnd);

        // --- Logic Game Ch√≠nh ---
        async function processSwap(gem1, gem2) {
            isAnimating = true;
            selectedGem = null;

            const isGem1Beam = gem1.special === SPECIAL_TYPES.H_BEAM || gem1.special === SPECIAL_TYPES.V_BEAM;
            const isGem2Beam = gem2.special === SPECIAL_TYPES.H_BEAM || gem2.special === SPECIAL_TYPES.V_BEAM;

            if (isGem1Beam && isGem2Beam) {
                let gemsToClear = new Set([gem1, gem2]);
                for(let c=0; c<GRID_SIZE; c++) { if(board[gem1.row][c]) gemsToClear.add(board[gem1.row][c]); }
                for(let r=0; r<GRID_SIZE; r++) { if(board[r][gem2.col]) gemsToClear.add(board[r][gem2.col]); }
                moves++;
                updateMoves();
                await cascadeMatches(Array.from(gemsToClear));
            } else if (gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE) {
                const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
                const otherGem = hypercube === gem1 ? gem2 : gem1;
                let gemsToClear = new Set([hypercube]);
                if (otherGem.special !== SPECIAL_TYPES.HYPERCUBE) {
                    const targetColorIndex = otherGem.colorIndex;
                    for(let r=0; r<GRID_SIZE; r++) {
                        for(let c=0; c<GRID_SIZE; c++) {
                            if(board[r][c] && board[r][c].colorIndex === targetColorIndex) {
                                gemsToClear.add(board[r][c]);
                            }
                        }
                    }
                }
                moves++;
                updateMoves();
                await cascadeMatches(Array.from(gemsToClear));
            } else {
                await swapGems(gem1, gem2);
                const matchInfo = findMatchesAndSpecial(gem1, gem2);
                if (matchInfo.allMatches.length > 0) {
                    moves++;
                    updateMoves();
                    await cascadeMatches(matchInfo.allMatches, matchInfo.specialToCreate);
                } else {
                    await swapGems(gem1, gem2);
                }
            }
            
            if (gameOverModal.classList.contains('hidden')) {
                await sleep(200);
                moveCigarette();
                await sleep(300);
                if (checkGameOver()) {
                    isAnimating = false;
                    return;
                }
                spawnHeartIfNeeded();
            }
            
            isAnimating = false;
        }
        
        async function cascadeMatches(initialMatches, specialToCreate = null) {
            let gemsToClear = new Set(initialMatches);
            let processedSpecials = new Set();
            
            while(true) {
                let newGemsFromExplosion = new Set();
                let foundNewExplosion = false;
                for(const gem of gemsToClear) {
                    if(gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                        foundNewExplosion = true;
                        processedSpecials.add(gem);
                        getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                    }
                }
                if(!foundNewExplosion) break;
                newGemsFromExplosion.forEach(g => gemsToClear.add(g));
            }

            const savedAHeart = await handleMatches(Array.from(gemsToClear), specialToCreate);
            if (savedAHeart) {
                await showFact();
            }

            await sleep(150);
            await shiftAndRefill();
            
            const nextMatches = findMatches(board);
            if (nextMatches.length > 0) {
                await cascadeMatches(nextMatches);
            } else {
                 await moveHearts();
            }
        }

        function getSpecialEffectGems(gem) {
            let affected = new Set();
            if (gem.special === SPECIAL_TYPES.H_BEAM) {
                for(let c=0; c<GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); }
            } else if (gem.special === SPECIAL_TYPES.V_BEAM) {
                for(let r=0; r<GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); }
            } else if (gem.special === SPECIAL_TYPES.BOMB) {
                for(let r = gem.row - 1; r <= gem.row + 1; r++) {
                    for(let c = gem.col - 1; c <= gem.col + 1; c++) {
                        if(r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && board[r][c]) {
                            affected.add(board[r][c]);
                        }
                    }
                }
            }
            return affected;
        }

        function swapGems(gem1, gem2) {
            const r1 = gem1.row, c1 = gem1.col;
            const r2 = gem2.row, c2 = gem2.col;
            board[r1][c1] = gem2;
            board[r2][c2] = gem1;
            gem1.row = r2; gem1.col = c2;
            gem2.row = r1; gem2.col = c1;
            const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, 150);
            const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, 150);
            return Promise.all([p1, p2]);
        }
        
        function findMatches(currentBoard) {
            const matches = new Set();
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE - 2; c++) {
                    const gem1 = currentBoard[r][c];
                    const gem2 = currentBoard[r][c+1];
                    const gem3 = currentBoard[r][c+2];
                    if (gem1 && gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                        matches.add(gem1); matches.add(gem2); matches.add(gem3);
                    }
                }
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE - 2; r++) {
                     const gem1 = currentBoard[r][c];
                    const gem2 = currentBoard[r+1][c];
                    const gem3 = currentBoard[r+2][c];
                    if (gem1 && gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                        matches.add(gem1); matches.add(gem2); matches.add(gem3);
                    }
                }
            }
            return Array.from(matches);
        }

        function findMatchesAndSpecial(gem1, gem2) {
            let allMatches = new Set();
            let specialToCreate = null;
            
            const checkLine = (line) => {
                let matches = [];
                for(let i=0; i<line.length - 2; i++) {
                    if(line[i] && line[i+1] && line[i+2] && line[i].colorIndex === line[i+1].colorIndex && line[i+1].colorIndex === line[i+2].colorIndex) {
                        let len = 3;
                        while(i+len < line.length && line[i].colorIndex === line[i+len].colorIndex) len++;
                        let currentMatch = [];
                        for(let j=0; j<len; j++) currentMatch.push(line[i+j]);
                        matches.push(currentMatch);
                        i += len - 1;
                    }
                }
                return matches;
            }

            const hMatches1 = checkLine(board[gem1.row]);
            const vMatches1 = checkLine(board.map(r => r[gem1.col]));
            const hMatches2 = checkLine(board[gem2.row]);
            const vMatches2 = checkLine(board.map(r => r[gem2.col]));
            
            const allFoundMatches = [...hMatches1, ...vMatches1, ...hMatches2, ...vMatches2];
            allFoundMatches.forEach(m => m.forEach(g => allMatches.add(g)));

            const hMatches = [...hMatches1, ...hMatches2];
            const vMatches = [...vMatches1, ...vMatches2];

            let bestMatch = {len: 0, match: null, type: null, isCross: false};

            for(const match of allFoundMatches) {
                if(match.includes(gem1) || match.includes(gem2)) {
                    if (match.length >= 5) {
                        bestMatch = { len: match.length, match, type: (match[0].row === match[1].row) ? 'h' : 'v', isCross: false };
                        break;
                    }
                    if (match.length === 4 && bestMatch.len < 4) {
                        bestMatch = { len: 4, match, type: (match[0].row === match[1].row) ? 'h' : 'v', isCross: false };
                    }
                }
            }
            
            const intersection = hMatches.flat().filter(gem => vMatches.flat().includes(gem));
            if (intersection.length > 0 && allMatches.size >= 5) {
                bestMatch = { len: 5, match: intersection, type: 'cross', isCross: true };
            }


            if (bestMatch.len >= 5 && !bestMatch.isCross) {
                specialToCreate = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: -1 };
            } else if (bestMatch.isCross) {
                 specialToCreate = { special: SPECIAL_TYPES.BOMB, colorIndex: gem1.colorIndex };
            } else if (bestMatch.len === 4) {
                specialToCreate = { special: bestMatch.type === 'h' ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: gem1.colorIndex };
            }
            
            if(specialToCreate && bestMatch.match) {
                 const creationGem = bestMatch.match.includes(gem1) ? gem1 : gem2;
                 specialToCreate.row = creationGem.row;
                 specialToCreate.col = creationGem.col;
            }

            return { allMatches: Array.from(allMatches), specialToCreate };
        }
        
        async function handleMatches(matches, specialToCreate) {
            const promises = [];
            let heartSaved = false;
            matches.forEach(gem => {
                if(specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) {
                    // Skip
                } else {
                    if (gem.isHeart) {
                        score++;
                        updateScore();
                        heartSaved = true;
                    }
                    const p = animate(gem, { scale: 0, alpha: 0 }, 200);
                    p.then(() => { board[gem.row][gem.col] = null; });
                    promises.push(p);
                }
            });
            await Promise.all(promises);

            if (specialToCreate) {
                const gem = board[specialToCreate.row][specialToCreate.col];
                gem.special = specialToCreate.special;
                gem.colorIndex = specialToCreate.colorIndex;
                gem.isHeart = false;
                await animate(gem, {scale: 1.5}, 150).then(() => animate(gem, {scale: 1}, 150));
            }
            return heartSaved;
        }

        async function shiftAndRefill() {
            const shiftPromises = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                let emptySlots = 0;
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    if (board[r][c] === null) {
                        emptySlots++;
                    } else if (emptySlots > 0) {
                        const gem = board[r][c];
                        board[r + emptySlots][c] = gem;
                        board[r][c] = null;
                        gem.row += emptySlots;
                        shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300));
                    }
                }
            }
            await Promise.all(shiftPromises);

            const refillPromises = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (board[r][c] === null) {
                        const newGem = {
                            colorIndex: Math.floor(Math.random() * GEM_COLORS.length),
                            isHeart: false, special: SPECIAL_TYPES.NONE,
                            row: r, col: c,
                            x: c * gemSize, y: (r - GRID_SIZE) * gemSize,
                            scale: 1, alpha: 1,
                        };
                        board[r][c] = newGem;
                        refillPromises.push(animate(newGem, { y: r * gemSize }, 400));
                    }
                }
            }
            await Promise.all(refillPromises);
        }

        function spawnHeartIfNeeded(isFirst = false) {
             if (isFirst || (moves > 0 && moves % MOVES_PER_HEART_SPAWN === 0)) {
                let availableCols = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[GRID_SIZE - 1][c] && !board[GRID_SIZE - 1][c].isHeart) {
                        availableCols.push(c);
                    }
                }
                if (availableCols.length > 0) {
                    const col = availableCols[Math.floor(Math.random() * availableCols.length)];
                    const gem = board[GRID_SIZE - 1][col];
                    gem.isHeart = true;
                    gem.special = SPECIAL_TYPES.NONE;
                    animate(gem, {scale: 1.5}, 150).then(() => animate(gem, {scale: 1}, 150));
                }
            }
        }

        async function moveHearts() {
            const movePromises = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const gem = board[r][c];
                    if (gem && gem.isHeart) {
                        const newRow = r - 1;
                        if (newRow < 0) continue;
                        const gemAbove = board[newRow][c];
                        
                        board[newRow][c] = gem;
                        board[r][c] = gemAbove;
                        
                        gem.row = newRow;
                        if (gemAbove) gemAbove.row = r;
                        
                        movePromises.push(animate(gem, { y: newRow * gemSize }, 200));
                        if (gemAbove) {
                           movePromises.push(animate(gemAbove, { y: r * gemSize }, 200));
                        }
                    }
                }
            }
            await Promise.all(movePromises);
        }

        function moveCigarette() {
            let highestHeart = null;
            let minRow = GRID_SIZE;

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c] && board[r][c].isHeart) {
                        if (r < minRow) {
                            minRow = r;
                            highestHeart = board[r][c];
                        }
                    }
                }
            }

            if (highestHeart) {
                if (cigarette.col < highestHeart.col) {
                    cigarette.col++;
                } else if (cigarette.col > highestHeart.col) {
                    cigarette.col--;
                }
            }
            updateCigarettePosition();
        }

        function updateCigarettePosition() {
            cigaretteEl.style.left = `${cigarette.col * gemSize}px`;
        }
        
        function checkGameOver() {
            if(board[0][cigarette.col] && board[0][cigarette.col].isHeart) {
                showGameOver();
                return true;
            }
            return false;
        }

        // --- Giao di·ªán ng∆∞·ªùi d√πng v√† Ti·ªán √≠ch ---
        function updateScore() { scoreEl.textContent = score; }
        function updateMoves() { movesEl.textContent = moves; }

        function showGameOver() {
            isAnimating = true;
            finalScoreEl.textContent = score;
            gameOverModal.classList.remove('hidden');
            setTimeout(() => gameOverModal.querySelector('div').classList.add('scale-100'), 10);
        }

        async function showFact() {
            isPaused = true;
            let availableFacts = HEALTH_FACTS.filter(obj => !factsShown.includes(obj));
            if (availableFacts.length === 0) {
                factsShown = []; // Reset n·∫øu ƒë√£ hi·ªÉn th·ªã h·∫øt
                availableFacts = HEALTH_FACTS;
            }
            const factObject = availableFacts[Math.floor(Math.random() * availableFacts.length)];
            factsShown.push(factObject);
            factText.textContent = factObject.fact;
            adviceText.textContent = factObject.advice;
            factModal.classList.remove('hidden');
            await new Promise(resolve => {
                const listener = () => {
                    closeFactButton.removeEventListener('click', listener);
                    factModal.classList.add('hidden');
                    isPaused = false;
                    resolve();
                };
                closeFactButton.addEventListener('click', listener);
            });
        }
        
        closeFactButton.addEventListener('click', () => {
             factModal.classList.add('hidden');
             isPaused = false;
        });

        restartButton.addEventListener('click', () => {
            gameOverModal.classList.add('hidden');
            gameOverModal.querySelector('div').classList.remove('scale-100');
            init();
        });

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        // --- H·ªá th·ªëng Animation ---
        function animate(target, toProperties, duration) {
            return new Promise(resolve => {
                animations.push({
                    target,
                    toProperties,
                    duration,
                    onComplete: resolve,
                    startProperties: Object.keys(toProperties).reduce((acc, key) => {
                        acc[key] = target[key];
                        return acc;
                    }, {}),
                    startTime: Date.now()
                });
            });
        }

        function handleAnimations() {
            const now = Date.now();
            for (let i = animations.length - 1; i >= 0; i--) {
                const anim = animations[i];
                const elapsed = now - anim.startTime;
                const progress = Math.min(elapsed / anim.duration, 1);

                for (const key in anim.toProperties) {
                    const start = anim.startProperties[key];
                    const to = anim.toProperties[key];
                    anim.target[key] = start + (to - start) * progress;
                }

                if (progress === 1) {
                    anim.onComplete();
                    animations.splice(i, 1);
                }
            }
        }
        
        window.onload = init;
        window.onresize = init;

    </script>
</body>
</html>
