<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Prince & Princess — Giao diện tinh chỉnh</title>
<style>
:root{
  --bg-top:#e9faff; --bg-bot:#fff7fb; --panel:#ffffff; --accent:#ff7a9a;
  --maxw:1200px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,var(--bg-top),var(--bg-bot));color:#122}

.app-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: linear-gradient(180deg, #d4f1ff, #ffe6fa);
  padding: 20px;
}
.app-frame {
  background: white;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
  position: relative;
  padding: 20px;
}
.app{min-height:auto;display:flex;align-items:center;justify-content:center;padding:0}

.container{width:100%;max-width:var(--maxw);display:flex;flex-direction:column;gap:12px}
.topbar{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:12px;background:linear-gradient(180deg,#fff,#fffefc);box-shadow:0 10px 36px rgba(10,30,60,0.06)}
.controls{display:flex;gap:8px;align-items:center}
.title{font-weight:800}
button{padding:8px 12px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);background:white;cursor:pointer; transition: all 0.2s;}
button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
button.primary{background:linear-gradient(90deg,#ffd1e8,#fff3d6);font-weight:700}
.badge{background:#fff6f9;padding:6px 10px;border-radius:999px;border:1px solid rgba(0,0,0,0.04)}

.card{background:var(--panel);border-radius:12px;overflow:hidden;box-shadow:0 30px 80px rgba(10,30,60,0.06)}
.header{display:flex;justify-content:space-between;align-items:center;padding:12px 18px;border-bottom:1px solid rgba(0,0,0,0.04); min-height: 50px;}
.stage{padding:18px;display:flex;justify-content:center;align-items:center}
.play-area{width:92%;max-width:1000px;height:70vh;min-height:520px;border-radius:12px;background:linear-gradient(180deg,#eaffff,#fff7fb);position:relative;overflow:hidden;border:1px solid rgba(0,0,0,0.03)}
.graph-wrap{position:absolute;left:6%;right:6%;top:6%;bottom:14%;border-radius:10px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center}

/* z-index layering */
svg.axes, svg.points{position:absolute;inset:0;width:100%;height:100%}
canvas.path{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:20}
canvas.fire{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:30}
.castle{position:absolute;left:2%;top:2%;bottom:18%;width:16%;background:linear-gradient(180deg,#cdb3ff,#b39dff);clip-path:polygon(0 0,72% 0,100% 20%,100% 100%,0 100%);opacity:0.95; z-index:1}
.cloud{position:absolute;background:rgba(255,255,255,0.95);border-radius:999px;box-shadow:0 10px 30px rgba(0,0,0,0.04); z-index:2}
.char{position:absolute;width:72px;height:72px;display:flex;align-items:center;justify-content:center;font-size:40px;z-index:40;pointer-events:none;transition:transform .26s,left .18s,top .18s}

.cloud.c1{left:8%;top:6%;width:120px;height:56px}
.cloud.c2{left:36%;top:4%;width:190px;height:72px}
.cloud.c3{left:62%;top:12%;width:150px;height:64px}

.coin-glow{animation:twinkle 1.6s infinite}
@keyframes twinkle{0%{transform:scale(.98);opacity:.9}50%{transform:scale(1.06);opacity:1}100%{transform:scale(.98);opacity:.9}}
svg text.coord{font-size:13px;fill:#111;pointer-events:none}

.char.zoom{transform:scale(1.12)}
.char.jump{transition:transform .18s cubic-bezier(.2,.9,.3,1)}
.char.tumble{animation:tumble 1s forwards}
@keyframes tumble{0%{transform:translateY(0) rotate(0)}100%{transform:translateY(520px) rotate(720deg);opacity:0}}

.overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:200;pointer-events:none}
.panel{background:rgba(255,255,255,0.98);padding:18px;border-radius:12px;pointer-events:auto;box-shadow:0 20px 60px rgba(0,0,0,0.14);text-align:center;opacity:0;transform:translateY(10px);transition:opacity .26s,transform .26s}
.overlay.show .panel{opacity:1;transform:translateY(0)}

.pregame{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:250;background:linear-gradient(180deg,rgba(0,0,0,0.28),rgba(0,0,0,0.36));}
.pregame-card{width:92%;max-width:820px;background:white;border-radius:12px;padding:24px;box-shadow:0 30px 80px rgba(0,0,0,0.32);text-align:center}

/* Giao diện Pregame được cân chỉnh */
.pregame-section { margin-bottom: 20px; }
.pregame-section h3 { margin-bottom: 10px; font-weight: 600; color: #333; }
.char-option {
    display: inline-block;
    font-size: 36px;
    padding: 5px 12px;
    border: 2px solid #eee;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
}
.char-option.selected {
    border-color: var(--accent);
    background: #fff0f5;
    transform: scale(1.1);
}
.rule-selector button.selected {
    background: #d7ffd9;
    border-color: #8eff93;
}
.emoji-frame { position: absolute; top: -15px; right: -15px; bottom: -15px; left: -15px; pointer-events: none; }
.emoji-frame span { position: absolute; font-size: clamp(20px, 2.5vw, 30px); animation: floatAndRotate 6s infinite alternate; opacity: 0; }
@keyframes floatAndRotate { from { transform: translateY(5px) rotate(-15deg) scale(0.9); opacity: 0.7; } to { transform: translateY(-10px) rotate(10deg) scale(1.1); opacity: 1; } }

@media (max-width:900px){
  .char{width:56px;height:56px;font-size:30px}
  .pregame-card{padding:12px}
  .app-frame { padding: 10px; }
}
</style>
</head>
<body>
  <div class="app-wrapper">
    <div class="app-frame" id="appFrame">
      <div class="emoji-frame" id="emojiFrame" aria-hidden="true"></div>
      <div class="app">
        <div class="container">
          <div class="topbar">
            <div class="title">🎮 Prince & Princess — Học + Giải</div>
            <div class="controls">
              <div class="badge" id="levelBadge">Màn 0 / 5</div>
              <button id="btnStart" class="primary">🎯 Bắt đầu</button>
              <button id="btnRestart">🔄 Chơi lại</button>
              <button id="btnHint">💡 Gợi ý</button>
              <button id="btnFS">🖥️ Fullscreen</button>
            </div>
          </div>
          <div class="card">
            <div class="header">
              <div>Trạng thái: <span id="status">Chưa bắt đầu</span></div>
              <div>Luật chơi: <span id="ruleDisplay"></span></div>
            </div>
            <div class="stage">
              <div class="play-area" id="playArea">
                <div class="castle" aria-hidden="true"></div>
                <div class="cloud c1" aria-hidden="true"></div>
                <div class="cloud c2" aria-hidden="true"></div>
                <div class="cloud c3" aria-hidden="true"></div>
                <div class="graph-wrap" id="graphWrap">
                  <svg class="axes" id="axesSvg" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet"></svg>
                  <svg class="points" id="pointsSvg" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg"></svg>
                  <canvas id="pathCanvas" class="path"></canvas>
                  <canvas id="fireCanvas" class="fire"></canvas>
                  <div id="playerCharEl" class="char" aria-hidden="true">🤴</div>
                  <div id="rescueCharEl" class="char" aria-hidden="true">👸</div>
                </div>
            </div>
            </div>
            <div class="card-footer" style="padding:10px 18px;border-top:1px solid rgba(0,0,0,0.04);display:flex;justify-content:space-between; color: #555; font-size: 14px;">
              <span>Phím: ← → di chuyển, Enter chọn.</span>
              <span>Mục tiêu: Đến giải cứu nhân vật.</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="pregame" id="pregame">
    <div class="pregame-card">
        <div class="pregame-section char-selector">
            <h3>1. Chọn nhân vật của bạn</h3>
            <div id="selectPrince" class="char-option selected">🤴</div>
            <div id="selectPrincess" class="char-option">👸</div>
        </div>
        <div class="pregame-section">
            <h3>2. Xác định quy luật của đồ thị</h3>
            <div style="width:100%;height:200px;display:flex;align-items:center;justify-content:center;margin-bottom:12px;">
                <svg id="previewSvg" viewBox="0 0 800 300" style="width:95%;height:100%;border-radius:8px;background:linear-gradient(180deg,#f9feff,#fff7fa)"></svg>
            </div>
            <div class="rule-selector" style="display:flex;gap:10px;justify-content:center">
                <button id="chooseInc">📈 Đồng biến</button>
                <button id="chooseDec">📉 Nghịch biến</button>
            </div>
        </div>
      <button id="enterGame" class="primary" style="margin-top:12px; padding: 12px 24px; font-size: 16px;">▶ Bắt đầu giải cứu</button>
    </div>
  </div>

  <div class="overlay" id="resultPanel" aria-hidden="true" style="display:none">
    <div class="panel">
      <h2 id="resultTitle">Kết quả</h2>
      <p id="resultText"></p>
      <div style="margin-top:12px">
        <button id="btnOk">✅ OK</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // DOM Elements
  const emojiFrame = document.getElementById('emojiFrame');
  const pregame = document.getElementById('pregame'), previewSvg = document.getElementById('previewSvg');
  const chooseInc = document.getElementById('chooseInc'), chooseDec = document.getElementById('chooseDec'), enterGame = document.getElementById('enterGame');
  const selectPrince = document.getElementById('selectPrince'), selectPrincess = document.getElementById('selectPrincess');
  const btnStart = document.getElementById('btnStart'), btnRestart = document.getElementById('btnRestart'), btnHint = document.getElementById('btnHint'), btnFS = document.getElementById('btnFS');
  const pointsSvg = document.getElementById('pointsSvg'), axesSvg = document.getElementById('axesSvg');
  const pathCanvas = document.getElementById('pathCanvas'), fireCanvas = document.getElementById('fireCanvas');
  const playerCharEl = document.getElementById('playerCharEl'), rescueCharEl = document.getElementById('rescueCharEl');
  const resultPanel = document.getElementById('resultPanel'), resultTitle = document.getElementById('resultTitle'), resultText = document.getElementById('resultText');
  const btnOk = document.getElementById('btnOk'), levelBadge = document.getElementById('levelBadge'), statusEl = document.getElementById('status'), ruleDisplay = document.getElementById('ruleDisplay');

  // State and Config
  const MAX_LEVELS = 5;
  let level = 0;
  const F_MIN = 1, F_MAX = 12;
  const POINTS_MIN = 7, POINTS_MAX = 11;
  let N = 7;
  let points = [];
  let chosenMode = null;
  let previewKind = '';
  let passedPregame = false;
  let playerChar = '🤴', rescueChar = '👸';
  let playerIdx = 0, rescueIdx = 0, currentIdx = null;
  let started = false, focusIdx = null;
  let pathCtx = null, fireCtx = null;
  let pathSelected = [];

    const coordHelper = {
        vbW: 1000, vbH: 600, ml: 100, mr: 80, mt: 40, mb: 60, iw: 0, ih: 0, canvasRect: null,
        updateDimensions(rect) { this.iw = this.vbW - this.ml - this.mr; this.ih = this.vbH - this.mt - this.mb; this.canvasRect = rect; },
        pointToViewBox(p) { const x = this.ml + (p.x - 1) / (N - 1) * this.iw; const y = (this.mt + this.ih) - (p.fx - F_MIN) / (F_MAX - F_MIN) * this.ih; return { x, y }; },
        viewBoxToPixel(vbPos) { if (!this.canvasRect || this.canvasRect.width === 0) return { x: 0, y: 0 }; const x = (vbPos.x / this.vbW) * this.canvasRect.width; const y = (vbPos.y / this.vbH) * this.canvasRect.height; return { x, y }; },
        pointToPixel(p) { const vbPos = this.pointToViewBox(p); return this.viewBoxToPixel(vbPos); }
    };

  let audioCtx = null, masterGain = null, patTimer = null;
  function initAudio(){
    if(audioCtx) return;
    try{
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.12;
        masterGain.connect(audioCtx.destination);
        const seq = [440,660,880,660,440,330,0,440]; let i = 0;
        patTimer = setInterval(()=> {
            const n = seq[i % seq.length];
            if(n > 0){
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'square'; o.frequency.setValueAtTime(n,audioCtx.currentTime);
                g.gain.setValueAtTime(0.001,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.12,audioCtx.currentTime+0.02);
                g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.18);
                o.connect(g); g.connect(masterGain); o.start(); o.stop(audioCtx.currentTime+0.16);
            }
            i++;
        }, 190);
    } catch(e) { console.warn('Audio disabled', e); }
  }
  function sfx(freq=880,dur=0.08,type='sine'){ if(!audioCtx) return; const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type=type; o.frequency.setValueAtTime(freq,audioCtx.currentTime); g.gain.setValueAtTime(0.001,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.12,audioCtx.currentTime+0.02); g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur); o.connect(g); g.connect(masterGain); o.start(); o.stop(audioCtx.currentTime+dur+0.02); }
  const playSelect = ()=> sfx(880,0.05,'sine');
  const playWrong = ()=> sfx(160,0.3,'sawtooth');
  const playWin = ()=> { sfx(1100,0.45,'sine'); setTimeout(()=>sfx(1400,0.32,'sine'),140); };

  const rand = (a,b)=> a + Math.floor(Math.random()*(b-a+1));

  function populateEmojiFrame() {
    const emojis = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐒'];
    const frame = document.getElementById('appFrame');
    if (!frame) return;
    const frameWidth = frame.offsetWidth;
    const frameHeight = frame.offsetHeight;
    const circumference = (frameWidth + frameHeight) * 2;
    const emojiCount = Math.floor(circumference / 60);
    emojiFrame.innerHTML = '';

    for (let i = 0; i < emojiCount; i++) {
        const span = document.createElement('span');
        span.textContent = emojis[i % emojis.length];
        const p = i / emojiCount;

        let x, y;
        if (p < frameWidth / circumference) {
            x = p * circumference; y = 0;
        } else if (p < (frameWidth + frameHeight) / circumference) {
            x = frameWidth; y = (p * circumference) - frameWidth;
        } else if (p < (frameWidth * 2 + frameHeight) / circumference) {
            x = frameWidth - ((p * circumference) - frameWidth - frameHeight); y = frameHeight;
        } else {
            x = 0; y = frameHeight - ((p * circumference) - frameWidth * 2 - frameHeight);
        }
        span.style.left = `${x-15}px`; span.style.top = `${y-15}px`;
        span.style.animationDelay = `${Math.random() * -6}s`;
        emojiFrame.appendChild(span);
    }
  }

  function genPreviewCurve(kind='increasing'){
    const M = 15; const pts = []; let pathDef = '';
    const svgContent = `<defs><linearGradient id="g1" x1="0" x2="1"><stop offset="0" stop-color="#6ea7ff"/><stop offset="1" stop-color="#ff9fcb"/></linearGradient></defs><rect x="0" y="0" width="800" height="300" fill="transparent"></rect><line x1="60" y1="260" x2="740" y2="260" stroke="#ddd" stroke-width="2"/><line x1="60" y1="40" x2="60" y2="260" stroke="#eee" stroke-width="2"/>`;
    for(let i=0; i<M; i++){
        const t = i/(M-1);
        const base = (kind === 'increasing') ? (0.2 + 0.75*t + 0.12*Math.sin(t*Math.PI*2) + (Math.random()-0.5)*0.06) : (0.2 + 0.75*(1-t) + 0.12*Math.sin((1-t)*Math.PI*2) + (Math.random()-0.5)*0.06);
        pts.push({x: 60 + t*(680), y: 40 + (1-base)*(220)});
    }
    pathDef = catmullRom2bezier(pts);
    previewSvg.innerHTML = svgContent + `<path d="${pathDef}" fill="none" stroke="url(#g1)" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"></path>`;
  }
  function catmullRom2bezier(points){ if(points.length < 2) return ''; let d = ''; for(let i=0;i<points.length;i++){ const p0 = points[i-1] || points[i]; const p1 = points[i]; const p2 = points[i+1] || p1; const p3 = points[i+2] || p2; if(i === 0) d += `M ${p1.x} ${p1.y} `; if(typeof p2 === 'undefined') break; const bp1x = p1.x + (p2.x - p0.x)/6; const bp1y = p1.y + (p2.y - p0.y)/6; const bp2x = p2.x - (p3.x - p1.x)/6; const bp2y = p2.y - (p3.y - p1.y)/6; d += `C ${bp1x} ${bp1y}, ${bp2x} ${bp2y}, ${p2.x} ${p2.y} `; } return d; }

  function genPointsForLevel(lvl){
    N = rand(POINTS_MIN, POINTS_MAX);
    let fx = [];
    let arr = [];
    for(let i=0;i<N;i++){ const t = i/(N-1); const base = (chosenMode === 'increasing') ? (1 + 2.5*t + 0.7*Math.sin(t*Math.PI*1.2) + (Math.random()-0.5)*0.6) : (1 + 2.5*(1-t) + 0.7*Math.sin((1-t)*Math.PI*1.2) + (Math.random()-0.5)*0.6); arr.push(base); }
    const mn_arr = Math.min(...arr), mx_arr = Math.max(...arr);
    fx = arr.map(v => (v - mn_arr) / (mx_arr - mn_arr));

    const minFx = Math.min(...fx), maxFx = Math.max(...fx);
    if (maxFx > minFx) {
        fx = fx.map(v => Math.round(F_MIN + (v - minFx) / (maxFx - minFx) * (F_MAX - F_MIN)));
    }

    for(let i=1;i<fx.length;i++) if(fx[i]===fx[i-1]) fx[i] = Math.min(F_MAX, fx[i]+1);

    const trapCount = Math.min(2 + level, Math.max(2, Math.floor(N / 2.5)));
    const traps = new Set();
    while(traps.size < trapCount && traps.size < N - 2){ const idx = rand(1, N-2); traps.add(idx); }

    traps.forEach(idx => {
        const deviation = rand(2,5);
        if(chosenMode === 'increasing') fx[idx] -= deviation; else fx[idx] += deviation;
    });

    for(let i=0;i<N;i++) fx[i] = Math.max(F_MIN, Math.min(F_MAX, fx[i]));
    points = [];
    for(let i=0;i<N;i++) points.push({x:i+1, fx:fx[i], idx:i, trap: traps.has(i)});
 }

  function renderAxes(){ const { vbW, vbH, ml, mt, iw, ih } = coordHelper; axesSvg.setAttribute('viewBox', `0 0 ${vbW} ${vbH}`); let s = `<rect x="${ml}" y="${mt}" width="${iw}" height="${ih}" fill="rgba(255,255,255,0.02)"/>`; for(let i=0;i<N;i++){ const x = ml + (i/(N-1))*iw; s += `<line x1="${x}" y1="${mt}" x2="${x}" y2="${mt+ih}" stroke="rgba(0,0,0,0.04)" stroke-width="1"/>`; s += `<text x="${x}" y="${mt+ih+26}" font-size="13" fill="#333" text-anchor="middle">${i+1}</text>`; } const steps = 6; for(let j=0;j<=steps;j++){ const y = mt + (j/steps)*ih; s += `<line x1="${ml}" y1="${y}" x2="${ml+iw}" y2="${y}" stroke="rgba(0,0,0,0.03)" stroke-width="1"/>`; const v = (F_MAX - (j/steps)*(F_MAX - F_MIN)).toFixed(0); s += `<text x="${ml-8}" y="${y+6}" font-size="12" fill="#333" text-anchor="end">${v}</text>`; } axesSvg.innerHTML = s; }
  function drawAll(){ pointsSvg.innerHTML = ''; for(const p of points){ const v = coordHelper.pointToViewBox(p); const g = document.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('transform', `translate(${v.x}, ${v.y})`); g.setAttribute('data-idx', p.idx); g.style.cursor = 'pointer'; const glow = document.createElementNS('http://www.w3.org/2000/svg','circle'); glow.setAttribute('r', 22); glow.setAttribute('fill', p.trap ? 'rgba(255,120,130,0.14)' : 'rgba(255,220,90,0.16)'); glow.setAttribute('class','coin-glow'); g.appendChild(glow); const coin = document.createElementNS('http://www.w3.org/2000/svg','circle'); coin.setAttribute('r', 14); coin.setAttribute('fill', '#ffd54a'); coin.setAttribute('stroke','#e69b00'); coin.setAttribute('stroke-width','2'); g.appendChild(coin); const shine = document.createElementNS('http://www.w3.org/2000/svg','ellipse'); shine.setAttribute('cx',-4); shine.setAttribute('cy',-6); shine.setAttribute('rx',4); shine.setAttribute('ry',2); shine.setAttribute('fill','rgba(255,255,255,0.85)'); g.appendChild(shine); const txt = document.createElementNS('http://www.w3.org/2000/svg','text'); txt.setAttribute('x','0'); txt.setAttribute('y','38'); txt.setAttribute('class','coord'); txt.setAttribute('text-anchor','middle'); txt.textContent = `(${p.x}, ${p.fx})`; g.appendChild(txt); g.addEventListener('click', ()=> onPointClick(p.idx)); pointsSvg.appendChild(g); } positionChars(); drawPath(); }
  function resizeAll(){ const rect = pointsSvg.getBoundingClientRect(); coordHelper.updateDimensions(rect); pathCanvas.width = rect.width; pathCanvas.height = rect.height; pathCanvas.style.width = rect.width + 'px'; pathCanvas.style.height = rect.height + 'px'; fireCanvas.width = rect.width; fireCanvas.height = rect.height; fireCanvas.style.width = rect.width + 'px'; fireCanvas.style.height = rect.height + 'px'; pathCtx = pathCanvas.getContext('2d'); fireCtx = fireCanvas.getContext('2d'); if(points.length) { renderAxes(); drawAll(); } requestAnimationFrame(positionChars); setTimeout(populateEmojiFrame, 100); }
  function drawPath(){ if(!pathCtx) return; pathCtx.clearRect(0,0,pathCanvas.width,pathCanvas.height); if(pathSelected.length < 1) return; const pts = pathSelected.map(i => coordHelper.pointToPixel(points[i])); for(let layer=0; layer<6; layer++){ pathCtx.beginPath(); pathCtx.lineWidth = 8 - layer; const colors = ['#ff6b6b','#ff9f43','#ffd166','#32ff7e','#4ea8ff','#b56bff']; pathCtx.strokeStyle = colors[layer % colors.length]; pathCtx.globalAlpha = 0.12 + layer*0.12; pathCtx.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length;i++){ const a = pts[i-1], b = pts[i]; const cx = (a.x + b.x)/2, cy = (a.y + b.y)/2; pathCtx.quadraticCurveTo(a.x, a.y, cx, cy); } pathCtx.stroke(); } pathCtx.globalAlpha = 1; }
  function positionChars(){ if(points.length && coordHelper.canvasRect?.width > 0){ const p_pos = coordHelper.pointToPixel(points[playerIdx]); playerCharEl.style.left = (p_pos.x - playerCharEl.offsetWidth/2) + 'px'; playerCharEl.style.top = (p_pos.y - playerCharEl.offsetHeight - 6) + 'px'; const q_pos = coordHelper.pointToPixel(points[rescueIdx]); rescueCharEl.style.left = (q_pos.x - rescueCharEl.offsetWidth/2) + 'px'; rescueCharEl.style.top = (q_pos.y - rescueCharEl.offsetHeight - 6) + 'px'; } }
  function animatePrinceTo(idx, cb){ const startIdx = currentIdx; const {x: sx, y: sy} = coordHelper.pointToPixel(points[startIdx]); const {x: ex, y: ey} = coordHelper.pointToPixel(points[idx]); const ctrlY = Math.min(sy,ey) - 120; const startTime = performance.now(), dur = 540; playerCharEl.classList.add('zoom', 'jump'); function tick(t){ const p = Math.min(1,(t-startTime)/dur); const cx = (sx + ex)/2; const x = (1-p)*(1-p)*sx + 2*(1-p)*p*cx + p*p*ex; const y = (1-p)*(1-p)*sy + 2*(1-p)*p*ctrlY + p*p*ey; playerCharEl.style.left = (x - playerCharEl.offsetWidth/2) + 'px'; playerCharEl.style.top = (y - playerCharEl.offsetHeight - 6) + 'px'; pathCtx.save(); const grd = pathCtx.createLinearGradient(sx,sy,x,y); grd.addColorStop(0,'#ff6b6b'); grd.addColorStop(.25,'#ff9f43'); grd.addColorStop(.5,'#ffd166'); grd.addColorStop(.75,'#4ee18f'); grd.addColorStop(1,'#6ea7ff'); pathCtx.lineWidth = 6; pathCtx.strokeStyle = grd; pathCtx.beginPath(); pathCtx.moveTo(sx,sy); pathCtx.quadraticCurveTo(cx, ctrlY, x, y); pathCtx.stroke(); pathCtx.restore(); if(p < 1) { requestAnimationFrame(tick); } else { playerCharEl.classList.remove('zoom', 'jump'); currentIdx = idx; pathSelected.push(idx); drawPath(); if(Math.abs(idx - rescueIdx) <= 2) princessWave(); if(cb) cb(); } } requestAnimationFrame(tick); }
  function princessWave(){ rescueCharEl.animate([{transform:'translateY(0) scale(1)'},{transform:'translateY(-12px) scale(1.06)'},{transform:'translateY(0) scale(1)'}], {duration:600}); }
  function fireworks(){ if(!fireCtx) return; const c = fireCanvas, ctx = fireCtx; ctx.clearRect(0,0,c.width,c.height); const {x: cx, y: cy} = coordHelper.pointToPixel(points[rescueIdx]); let parts = []; for(let i=0;i<160;i++){ const a=Math.random()*Math.PI*2, s=1+Math.random()*5; parts.push({x:cx,y:cy,vx:Math.cos(a)*s,vy:Math.sin(a)*s,age:0,life:60+Math.random()*60,color:`hsl(${Math.floor(Math.random()*360)} 80% 60%)`}); } let raf; function loop(){ ctx.clearRect(0,0,c.width,c.height); parts.forEach(p=>{ p.age++; p.x+=p.vx; p.y+=p.vy+0.02*p.age; p.vx*=0.995; p.vy*=0.995; ctx.globalAlpha=Math.max(0,1-p.age/p.life); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y, Math.max(1,3-p.age/30),0,Math.PI*2); ctx.fill(); }); parts = parts.filter(p=>p.age<p.life); if(parts.length) raf = requestAnimationFrame(loop); } loop(); setTimeout(()=>{ if(raf) cancelAnimationFrame(raf); ctx.clearRect(0,0,c.width,c.height); }, 3800); }
  function allowedNexts(curr){ const cur = points[curr]; return chosenMode === 'increasing' ? points.filter(p => p.x > cur.x && p.fx > cur.fx).map(p=>p.idx) : points.filter(p => p.x > cur.x && p.fx < cur.fx).map(p=>p.idx); }

  function onPointClick(idx){
    if(!started || idx === currentIdx) return;
    const allowed = allowedNexts(currentIdx);
    if (!allowed.includes(idx)) {
        playWrong();
        animatePrinceTo(idx, ()=> { playerCharEl.classList.add('tumble'); showResult(false, 'Bạn đã chọn một bước đi không hợp lệ!'); });
        return;
    }
    playSelect();
    animatePrinceTo(idx, ()=> {
        if(idx === rescueIdx) { playWin(); showResult(true, `Bạn đã giải cứu ${rescueChar}!`); fireworks(); }
        else if (allowedNexts(idx).length === 0) { showResult(false, 'Hết đường đi hợp lệ từ điểm này!'); }
        else { statusEl.textContent = 'Chọn tiếp'; }
    });
  }

  function showResult(win, message){ started = false; if(win) resultTitle.textContent = '🎉 Thắng'; else resultTitle.textContent = '💥 Thua'; resultText.textContent = message; resultPanel.style.display = 'flex'; setTimeout(()=> resultPanel.classList.add('show'), 20); statusEl.textContent = win ? 'Thắng — bấm OK để xem lại' : 'Thua — bấm OK để xem lại'; }
  function hideResult(){ resultPanel.classList.remove('show'); setTimeout(()=> resultPanel.style.display = 'none', 260); }
  btnOk.addEventListener('click', ()=> { hideResult(); });
  function showHint(){ if(!started) return; const allowed = allowedNexts(currentIdx); if(allowed.length === 0){ statusEl.textContent = 'Không có bước hợp lệ'; return; } allowed.forEach(idx => { const g = Array.from(pointsSvg.querySelectorAll('g')).find(el => parseInt(el.getAttribute('data-idx'),10) === idx); if(g) g.animate([{transform:g.getAttribute('transform')+' scale(1)'},{transform:g.getAttribute('transform')+' scale(1.18)'},{transform:g.getAttribute('transform')+' scale(1)'}], {duration:900, iterations:2}); }); }

  function startRandomLevel(){ if(!passedPregame){ openPregame(); return; } updateCharacterVisuals(); hideResult(); if(level >= MAX_LEVELS) level = 0; level++; levelBadge.textContent = `Màn ${level} / ${MAX_LEVELS}`; initAudio(); statusEl.textContent = 'Đang tạo màn...'; genPointsForLevel(level); playerIdx = 0; rescueIdx = N-1; currentIdx = playerIdx; pathSelected = [playerIdx]; started = true; focusIdx = null; playerCharEl.classList.remove('tumble'); ruleDisplay.textContent = chosenMode === 'increasing' ? 'Điểm sau cao hơn điểm trước' : 'Điểm sau thấp hơn điểm trước'; resizeAll(); statusEl.textContent = 'Chọn ngôi sao hợp lệ để đi tiếp'; }
  function resetAll(){ passedPregame = false; hideResult(); chosenMode = null; level = 0; levelBadge.textContent = `Màn 0 / ${MAX_LEVELS}`; points = []; pointsSvg.innerHTML = ''; pathCtx && pathCtx.clearRect(0,0,pathCanvas.width,pathCanvas.height); fireCtx && fireCtx.clearRect(0,0,fireCanvas.width,fireCanvas.height); playerCharEl.style.left='-9999px'; rescueCharEl.style.left='-9999px'; playerCharEl.classList.remove('tumble'); statusEl.textContent = 'Chưa bắt đầu'; openPregame(); boot(); }

  window.addEventListener('resize', resizeAll);
  window.addEventListener('keydown', (e)=> { if(!started) return; const groups = Array.from(pointsSvg.querySelectorAll('g')); if(e.key === 'ArrowLeft' || e.key === 'ArrowRight'){ if(focusIdx === null) focusIdx = currentIdx; const ids = points.map(p=>p.idx); let pos = ids.indexOf(focusIdx); pos = e.key === 'ArrowLeft' ? Math.max(0,pos-1) : Math.min(ids.length-1,pos+1); focusIdx = ids[pos]; groups.forEach(g=> g.querySelector('circle:nth-child(2)').setAttribute('stroke-width','2')); const g = groups.find(g => parseInt(g.getAttribute('data-idx'),10) === focusIdx); if(g) g.querySelector('circle:nth-child(2)').setAttribute('stroke-width','4'); } else if(e.key === 'Enter'){ if(focusIdx !== null) onPointClick(focusIdx); } });

  selectPrince.addEventListener('click', () => { playerChar = '🤴'; rescueChar = '👸'; selectPrince.classList.add('selected'); selectPrincess.classList.remove('selected'); });
  selectPrincess.addEventListener('click', () => { playerChar = '👸'; rescueChar = '🤴'; selectPrincess.classList.add('selected'); selectPrince.classList.remove('selected'); });

  function updateRuleButtons(selectedBtn) { [chooseInc, chooseDec].forEach(btn => btn.classList.remove('selected')); selectedBtn.classList.add('selected'); }
  chooseInc.addEventListener('click', ()=> { chosenMode = 'increasing'; updateRuleButtons(chooseInc); });
  chooseDec.addEventListener('click', ()=> { chosenMode = 'decreasing'; updateRuleButtons(chooseDec); });

  enterGame.addEventListener('click', ()=> {
    if(!chosenMode){ alert('Vui lòng chọn một quy luật trước.'); return; }
    const isCorrectChoice = (previewKind === chosenMode);
    if (isCorrectChoice) {
        passedPregame = true; pregame.style.display = 'none'; startRandomLevel();
    } else {
        passedPregame = false; showResult(false, 'Bạn đã nhận định sai ở màn học! Trò chơi kết thúc.'); pregame.style.display = 'none';
    }
  });

  function openPregame(){ passedPregame = false; pregame.style.display = 'flex'; }
  function updateCharacterVisuals() { playerCharEl.textContent = playerChar; rescueCharEl.textContent = rescueChar; }
  btnStart.addEventListener('click', ()=> { if(passedPregame) { startRandomLevel(); } else { openPregame(); } });
  btnRestart.addEventListener('click', ()=> { resetAll(); });
  btnHint.addEventListener('click', showHint);
  btnFS.addEventListener('click', ()=> { const el=document.documentElement; if(!document.fullscreenElement) el.requestFullscreen(); else document.exitFullscreen(); });

  function boot(){
    const kinds = ['increasing', 'decreasing'];
    previewKind = kinds[Math.floor(Math.random() * kinds.length)];
    genPreviewCurve(previewKind);
    resizeAll();
    resultPanel.style.display = 'none';
    pathCtx = pathCanvas.getContext('2d');
    fireCtx = fireCanvas.getContext('2d');
    openPregame();
  }
  window.addEventListener('load', boot);
  document.addEventListener('click', ()=> { try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){} }, {once:true});
})();
</script>
</body>
</html>
