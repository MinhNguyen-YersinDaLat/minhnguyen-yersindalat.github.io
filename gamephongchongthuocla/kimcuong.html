<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Game Kim Cương: Cân Bằng Cuộc Sống</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/4a2129a3a2.js" crossorigin="anonymous"></script>

    <style>
        /* --- General Styles --- */
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            animation: vignette-pulse 8s infinite alternate ease-in-out;
            background-color: #0c0a09; /* Darker base for neon */
        }
        @keyframes vignette-pulse {
            from { background: radial-gradient(ellipse at center, #1a1111 50%, #000000 100%); }
            to { background: radial-gradient(ellipse at center, #110a0a 40%, #000000 100%); }
        }
        canvas {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        /* --- Character / Monster Styles --- */
        #character-container {
            position: absolute;
            top: -95px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
            z-index: 20;
        }
        .character-aura {
            position: absolute;
            width: 250px;
            height: 150px;
            background: radial-gradient(ellipse at center, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0) 70%);
            border-radius: 50%;
            animation: aura-pulse 4s infinite alternate ease-in-out;
            z-index: -1;
        }
        @keyframes aura-pulse {
            from { transform: scale(1); opacity: 0.7; }
            to { transform: scale(1.2); opacity: 0.4; }
        }
        #cigarette-svg {
            width: 240px; 
            height: 120px; 
            filter: drop-shadow(0 5px 20px rgba(0, 0, 0, 0.8));
            animation: idle-spasm 6s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        #character-container.coughing #cigarette-svg { animation: cough-shake 0.5s ease-in-out; }
        @keyframes cough-shake {
            0%, 100% { transform: translate(0, 0); } 20% { transform: translate(-8px, 5px) rotate(-3deg); } 40% { transform: translate(8px, -5px) rotate(3deg); } 60% { transform: translate(-5px, 3px) rotate(-2deg); } 80% { transform: translate(5px, -3px) rotate(2deg); }
        }
        @keyframes idle-spasm {
            0%, 100% { transform: translate(0, 0) rotate(0); } 10% { transform: translate(-2px, 2px) rotate(-1deg); } 20% { transform: translate(2px, -2px) rotate(1deg); } 30% { transform: translate(-3px, 0px) rotate(-1.5deg); } 40% { transform: translate(3px, 1px) rotate(1.5deg); } 50% { transform: translate(0, 0) rotate(0); } 70% { transform: translate(0, 0) rotate(0); } 72% { transform: translate(5px, -5px) rotate(3deg); } 74% { transform: translate(0, 0) rotate(0); }
        }
        .cigarette-body-shape { fill: url(#paper-gradient); } .filter-shape { fill: #6b3520; } .ash-shape { fill: #333; } .ember-shape { fill: #ff4500; filter: url(#emberGlow); animation: ember-flicker 1.5s infinite alternate; }
        @keyframes ember-flicker { from { opacity: 0.9; } to { opacity: 1; } }
        .eye-socket { fill: #1a0000; } .eye-ball { fill: #dc143c; } .eye-pupil { fill: #000; transition: transform 0.1s linear; } .eye-vein { stroke: #8b0000; stroke-width: 0.5; fill: none; } .mouth { fill: #1a1a1a; transition: d 0.3s ease-in-out; } .crack { fill: none; stroke: #4e2a1d; stroke-width: 1.2; } .stain { fill: #704214; opacity: 0.6; } .spark { fill: #ffdd00; animation: spark-fly 1.5s infinite linear; }
        @keyframes spark-fly { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(-30px, var(--y-end)) scale(0); opacity: 0; } }
        .smoke-container { position: absolute; left: -120px; top: 50%; transform: translateY(-50%); width: 200px; height: 200px; pointer-events: none; filter: url(#smokeFilter); }
        .smoke-wisp { position: absolute; background: white; border-radius: 50%; animation: wisp-rise 12s infinite linear; opacity: 0; }
        @keyframes wisp-rise { 0% { transform: translate(0, 0) scale(0.5); opacity: 0; } 15% { opacity: 0.8; } 100% { transform: translate(-120px, var(--y-end)) scale(2.5); opacity: 0; } }
        .smoke-wisp:nth-child(1) { width: 60px; height: 60px; animation-delay: 0s; --y-end: -80px; } .smoke-wisp:nth-child(2) { width: 80px; height: 80px; animation-delay: 4s; --y-end: 50px; } .smoke-wisp:nth-child(3) { width: 50px; height: 50px; animation-delay: 8s; --y-end: -20px; }
        #threat-bubble { position: absolute; bottom: 100%; left: 50%; margin-bottom: 10px; background-color: #110d0d; color: #ff4500; padding: 15px 22px; border-radius: 12px; border: 2px solid #ff4500; font-size: 1.3rem; font-family: 'Metal Mania', cursive; letter-spacing: 1px; opacity: 0; transform: translateY(20px) scale(0.9) translateX(-50%); transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); white-space: nowrap; box-shadow: 0 0 25px rgba(255, 69, 0, 0.7); }
        #threat-bubble.visible { opacity: 1; transform: translateY(0) scale(1) translateX(-50%); }
        #monster-name { position: absolute; top: 50%; left: 230px; transform: translateY(-50%); white-space: nowrap; }

        /* --- UI & Game Elements --- */
        #game-title { animation: sparkle 5s infinite linear; }
        @keyframes sparkle { 0% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); } 50% { text-shadow: 2px 2px 8px rgba(236, 72, 153, 0.5); } 100% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); } }
        #custom-cursor { position: fixed; width: 20px; height: 20px; border: 2px solid #ff4500; border-radius: 50%; pointer-events: none; transform: translate(-50%, -50%); z-index: 9999; transition: transform 0.1s ease-out; }
        
        progress {
            vertical-align: baseline;
            appearance: none;
        }
        progress::-webkit-progress-bar {
            background-color: rgba(0,0,0,0.3);
            border-radius: 9999px;
        }
        progress::-webkit-progress-value {
            background: linear-gradient(to right, #ef4444, #f87171);
            border-radius: 9999px;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px #ef4444;
        }
        progress::-moz-progress-bar {
            background: linear-gradient(to right, #ef4444, #f87171);
            border-radius: 9999px;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px #ef4444;
        }

        /* --- Screens & Modals --- */
        #start-screen { position: fixed; inset: 0; background-color: rgba(0,0,0,0.8); backdrop-filter: blur(10px); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; text-align: center; padding: 1rem; }
        .tutorial-icon { height: 60px; margin: 0 auto 0.5rem auto; display: flex; align-items: center; justify-content: center; }
        .tutorial-gem-container { width: 50px; height: 50px; position: relative; }
        .tutorial-gem { width: 100%; height: 100%; transform: rotate(45deg); border-radius: 8px; position: relative; overflow: hidden; border: 2px solid rgba(255,255,255,0.5); box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), inset -2px -2px 5px rgba(0,0,0,0.3); }
        .tutorial-gem-bomb { background: radial-gradient(circle, #6bb5ff, #1E90FF); }
        .tutorial-gem-bomb::after { content: ''; position: absolute; top: 50%; left: 50%; width: 60%; height: 60%; background-color: rgba(255, 255, 255, 0.9); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px white; }
        .tutorial-gem-beam { background: radial-gradient(circle, #ff7b7b, #FF3131); }
        .tutorial-gem-beam::after { content: ''; position: absolute; top: 50%; left: 50%; width: 100%; height: 25%; background-color: white; transform: translate(-50%, -50%); box-shadow: 0 0 10px white; }
        .tutorial-gem-hypercube { background: conic-gradient(from 0deg, #FF3131, #FFFF00, #00FF7F, #1E90FF, #FF00FF, #FF8C00, #FF3131); animation: spin 4s linear infinite; }
        @keyframes spin { from { transform: rotate(45deg); } to { transform: rotate(405deg); } }

        /* --- UI Buttons --- */
        .ui-button { position: fixed; z-index: 101; width: 44px; height: 44px; background: rgba(10, 20, 30, 0.5); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 50%; color: rgba(236, 72, 153, 0.7); display: flex; align-items: center; justify-content: center; cursor: pointer; backdrop-filter: blur(5px); transition: all 0.3s ease; box-shadow: 0 0 15px rgba(236, 72, 153, 0.2), inset 0 0 5px rgba(236, 72, 153, 0.1); }
        .ui-button:hover { background: rgba(20, 40, 60, 0.7); color: white; border-color: rgba(236, 72, 153, 0.8); box-shadow: 0 0 25px rgba(236, 72, 153, 0.5), inset 0 0 10px rgba(236, 72, 153, 0.2); transform: scale(1.1); }
        #fullscreen-btn { top: 1rem; right: 1rem; }
        #back-to-menu-btn { bottom: 1rem; right: 1rem; }

        /* --- Copyright --- */
        #copyright {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 13px;
            padding: 6px 0;
            font-family: 'Roboto', Arial, Helvetica, sans-serif;
            z-index: 9999;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.85);
            background: transparent;
            opacity: 0;
            animation: fadeIn 2s ease forwards;
        }
        @keyframes fadeIn { to { opacity: 1; } }

        /* --- Balance Mode UI (REWORKED) --- */
        #balance-mode-screen {
            height: 100vh;
            width: 100vw;
            padding: 1rem;
        }
        .info-panel {
            background: rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 1rem;
            padding: 1rem;
            color: white;
            animation: fadeInPanel 1s ease forwards;
            overflow-y: auto;
        }
        @keyframes fadeInPanel { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .info-panel h2 {
            font-weight: bold;
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
            text-align: center;
            position: sticky;
            top: 0;
            background: rgba(0,0,0,0.5);
            padding: 0.5rem 0;
            z-index: 10;
        }
        .info-panel ul { list-style: none; padding: 0; }
        .info-panel li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            opacity: 0;
            transform: translateX(-20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .info-panel li.visible {
            opacity: 1;
            transform: translateX(0);
        }
        .info-panel .icon { width: 24px; text-align: center; flex-shrink: 0; }
        
        #balance-three-columns {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            height: 100%;
        }

        #balance-center-column {
             height: 100%;
        }

        #balance-scale-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            margin: 0 auto;
            height: 320px;
        }
        #balance-game-board {
            width: 100%;
            max-width: 450px;
            margin-top: -290px;
        }
        #balance-mode-stats {
             margin-top: 1rem;
        }

        /* --- New Energy Core Styles --- */
        @keyframes plasma-swirl {
            0% { transform: rotate(0deg) scale(1.2); opacity: 0.6; }
            50% { transform: rotate(180deg) scale(1.5); opacity: 0.8; }
            100% { transform: rotate(360deg) scale(1.2); opacity: 0.6; }
        }

        @keyframes plasma-pulse {
            from { filter: brightness(1) drop-shadow(0 0 5px currentColor); }
            to { filter: brightness(1.5) drop-shadow(0 0 15px currentColor); }
        }

        #balance-chain {
            height: 8px; /* Dải hologram mỏng hơn */
            background: linear-gradient(90deg, transparent, #00d9ff, #00d9ff, transparent);
            border-radius: 4px;
            box-shadow: 0 0 15px #00d9ff, 0 0 25px #00d9ff, inset 0 0 2px white;
            position: relative;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #balance-pivot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #fff, #00d9ff);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #fff, 0 0 20px #00d9ff;
            border: 2px solid white;
        }
        .balance-tube-wrapper {
            position: absolute;
            top: 30px; 
            width: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .balance-tube-wrapper.left { left: 0; }
        .balance-tube-wrapper.right { right: 0; }
        
        .balance-tube { /* Vỏ bọc Lõi Năng Lượng */
            width: 100%;
            height: 250px;
            border: 2px solid rgba(0, 217, 255, 0.5);
            border-top: 4px solid #00d9ff;
            border-radius: 12px;
            background: linear-gradient(rgba(0,0,0,0.2), rgba(0,0,0,0.5));
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 15px rgba(0, 217, 255, 0.2), 0 0 10px rgba(0, 217, 255, 0.3);
        }
        .balance-liquid { /* Khối Plasma */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            transition: height 0.3s ease-out;
            background: transparent;
            overflow: hidden;
            animation: plasma-pulse 2s infinite alternate ease-in-out;
        }

        .balance-liquid::before, .balance-liquid::after {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            border-radius: 40%;
            animation: plasma-swirl 10s infinite linear;
        }
        
        .balance-liquid.study { 
            color: #ff4b2b;
        }
        .balance-liquid.play { 
            color: #1cb5e0;
        }

        .balance-liquid.study::before { background: radial-gradient(circle at center, rgba(255, 75, 43, 0.7) 0%, rgba(255, 0, 0, 0) 60%); }
        .balance-liquid.study::after { background: radial-gradient(circle at center, rgba(255, 65, 108, 0.7) 0%, rgba(255, 0, 0, 0) 60%); animation-direction: reverse; animation-duration: 8s; }
        .balance-liquid.play::before { background: radial-gradient(circle at center, rgba(28, 181, 224, 0.7) 0%, rgba(0, 123, 255, 0) 60%); }
        .balance-liquid.play::after { background: radial-gradient(circle at center, rgba(0, 217, 255, 0.7) 0%, rgba(0, 123, 255, 0) 60%); animation-direction: reverse; animation-duration: 8s; }
        
        .tube-label {
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 0 0 5px #000, 0 0 8px #000;
            color: white;
        }
        .tube-percentage {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 0 5px black, 0 0 10px black;
            pointer-events: none;
            z-index: 2;
        }
        .danger-icon {
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%) scale(0);
            font-size: 3rem;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            text-shadow: 0 0 10px white;
        }
        .danger-icon.visible {
            transform: translateX(-50%) scale(1);
            opacity: 1;
        }
        .warning-study .balance-tube { animation: shake-horizontal 0.8s cubic-bezier(.455,.030,.515,.955) both; border-color: #ff4b2b;}
        .warning-play .balance-tube { animation: shake-horizontal 0.8s cubic-bezier(.455,.030,.515,.955) both; border-color: #1cb5e0;}
        
        @keyframes flash-warning {
            50% { box-shadow: inset 0 0 25px rgba(255,255,255,0.8), 0 0 20px rgba(255,255,255,0.7), 0 0 30px rgba(255,255,0,0.5); border-color: #FFFF00; }
        }
        .flash-warning-effect {
            animation: flash-warning 0.6s ease-in-out;
        }

        @keyframes shake-horizontal { 0%,100%{transform:translateX(0)} 10%,30%,50%,70%{transform:translateX(-8px)} 20%,40%,60%,80%{transform:translateX(8px)} }

        #balance-message {
            text-align: center;
            padding: 0.5rem 1rem;
            margin-bottom: 1rem;
            font-size: clamp(1.1rem, 3vw, 1.5rem);
            font-weight: bold;
            color: #f8fafc;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #67e8f9, 0 0 20px #67e8f9, 0 0 25px #67e8f9;
            white-space: normal;
        }

        #balance-mode-stats {
            display: flex;
            gap: 2rem;
            background-color: rgba(0,0,0,0.3);
            padding: 0.5rem 1.5rem;
            border-radius: 9999px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            margin: 0 auto; /* Center horizontally */
        }
        #balance-mode-stats .stat-item span {
            font-size: 1.8rem;
            font-weight: bold;
        }

        .locked-button {
            background-color: #4a5568 !important; /* gray-700 */
            cursor: not-allowed;
            opacity: 0.6;
        }
        .locked-button:hover {
            transform: scale(1);
        }

    </style>
</head>
<body class="bg-gradient-to-br from-gray-700 via-gray-800 to-gray-900 flex items-center justify-center min-h-screen p-4">

<audio id="bg-music" src="nhackimcuong.mp3" loop></audio>
    
<button id="fullscreen-btn" class="ui-button" title="Toàn màn hình" aria-label="Chế độ toàn màn hình">
    <svg id="fullscreen-icon-open" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
    <svg id="fullscreen-icon-close" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
</button>
<button id="back-to-menu-btn" class="ui-button hidden" title="Về màn hình chính" aria-label="Về màn hình chính">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
</button>

<div id="start-screen">
    <h1 class="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-4" id="game-title-start">Bảo Vệ Trái Tim</h1>
    <p class="text-gray-200 italic text-xl md:text-2xl mb-8 max-w-2xl">Quái vật thuốc lá đang đến gần. Hãy dùng trí tuệ của bạn để ghép các viên kim cương, cứu lấy những trái tim và đẩy lùi mối đe dọa!</p>
    <div id="start-buttons" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-x-6 gap-y-8 items-start max-w-5xl w-full">
        <div class="flex flex-col items-center">
            <button id="easy-mode-btn" class="w-full bg-green-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform">Dễ (1 Màn)</button>
            <p class="text-gray-400 text-sm mt-2 px-4">Trải nghiệm cốt truyện.</p>
        </div>
        <div class="flex flex-col items-center">
            <button id="hard-mode-btn" class="w-full bg-red-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform flex items-center justify-center gap-2">Khó (3 Màn) <i id="hard-lock-icon" class="fas fa-lock"></i></button>
            <p class="text-gray-400 text-sm mt-2 px-4">Thử thách cao hơn.</p>
        </div>
        <div class="flex flex-col items-center">
            <button id="free-mode-btn" class="w-full bg-blue-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform flex items-center justify-center gap-2">Tự Do <i id="free-lock-icon" class="fas fa-lock"></i></button>
            <p class="text-gray-400 text-sm mt-2 px-4">Chơi không giới hạn.</p>
            <p id="free-mode-highscore" class="text-yellow-400 text-sm mt-1"></p>
        </div>
        <div class="flex flex-col items-center">
            <button id="balance-mode-btn" class="w-full bg-purple-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform flex items-center justify-center gap-2">Cân Bằng <i id="balance-lock-icon" class="fas fa-lock"></i></button>
            <p class="text-gray-400 text-sm mt-2 px-4">Học &amp; Chơi.</p>
        </div>
        <div class="col-span-1 sm:col-span-2 lg:col-span-4 flex justify-center mt-4">
             <button id="tutorial-start-btn" class="bg-yellow-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform">HƯỚNG DẪN</button>
        </div>
    </div>
</div>

<div id="tutorial-modal" role="dialog" aria-modal="true" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm" aria-labelledby="tutorial-modal-title">
    <div class="bg-gray-800 border border-gray-700 rounded-2xl p-6 md:p-8 shadow-2xl max-w-md w-full text-white text-center">
        <div id="tutorial-step-1" class="tutorial-step">
            <h2 class="text-3xl font-bold text-pink-400 mb-4" id="tutorial-modal-title">Mục Tiêu: Cứu Trái Tim!</h2>
            <div class="tutorial-icon text-5xl">💗</div>
            <p class="text-lg mb-4">Mỗi vài nước đi, một viên kim cương <strong>Trái Tim</strong> sẽ xuất hiện ở hàng dưới cùng.</p>
            <p class="text-lg mb-6">Hãy đưa nó lên <strong>hàng trên cùng</strong> để cứu trái tim và ghi điểm. Đừng để quái vật thuốc lá chạm tới!</p>
            <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Tiếp theo</button>
        </div>
        <div id="tutorial-step-2" class="tutorial-step hidden">
             <h2 class="text-3xl font-bold text-yellow-400 mb-4">Sức Mạnh Đặc Biệt</h2>
             <p class="text-lg mb-4">Ghép 4 hoặc 5 viên kim cương để tạo ra các loại đặc biệt:</p>
             <div class="flex justify-around items-start text-center mb-6 space-x-2">
                <div class="flex-1"><div class="tutorial-icon"><div class="tutorial-gem-container"><div class="tutorial-gem tutorial-gem-bomb"></div></div></div><p class="font-bold">Bom</p><p class="text-sm text-gray-300">(Ghép 5 viên hình chữ L hoặc T)</p></div>
                <div class="flex-1"><div class="tutorial-icon"><div class="tutorial-gem-container"><div class="tutorial-gem tutorial-gem-beam"></div></div></div><p class="font-bold">Tia Sáng</p><p class="text-sm text-gray-300">(Ghép 4 viên)</p></div>
                <div class="flex-1"><div class="tutorial-icon"><div class="tutorial-gem-container"><div class="tutorial-gem tutorial-gem-hypercube"></div></div></div><p class="font-bold">Siêu Khối</p><p class="text-sm text-gray-300">(Ghép 5 viên thẳng hàng)</p></div>
             </div>
             <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Tiếp theo</button>
        </div>
        <div id="tutorial-step-3" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-red-500 mb-4">Mối Đe Dọa</h2>
            <div class="tutorial-icon text-5xl">🚬</div>
            <p class="text-lg mb-4"><strong>Quái vật thuốc lá</strong> sẽ di chuyển và cố gắng "ăn" những trái tim ở hàng trên cùng.</p>
            <p class="text-lg mb-6">Hãy ngăn chặn nó bằng cách hoàn thành mục tiêu để qua màn!</p>
            <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Tiếp theo</button>
        </div>
        <div id="tutorial-step-4" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-green-400 mb-4">Hoàn Thành Mục Tiêu</h2>
            <p class="text-lg mb-4">Thu thập đủ số lượng kim cương màu và cứu trái tim theo yêu cầu trên <strong>Bảng Mục Tiêu</strong> để gây sát thương lên quái vật.</p>
            <div class="p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10 mb-6 mx-auto max-w-xs">
                <h2 class="text-xl font-bold text-white/80 mb-2">Mục Tiêu</h2>
                <progress class="w-full h-5 rounded-full overflow-hidden border border-white/10 mb-4" value="40" max="100"></progress>
                <div class="flex items-center justify-between p-2 rounded-lg bg-black/20"><div class="w-6 h-6 rounded-full border-2 border-white/20" style="background-color: #FF3131"></div><span class="font-bold text-white">15</span></div>
            </div>
            <p class="text-lg mb-6">Thanh tiến trình sẽ đầy dần. Khi hoàn thành tất cả mục tiêu, bạn sẽ chiến thắng màn chơi!</p>
            <button id="tutorial-finish-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform hover:scale-105">Bắt đầu chơi!</button>
        </div>
        
        <!-- Hướng dẫn cho màn chơi Cân Bằng -->
        <div id="tutorial-step-balance" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-purple-400 mb-4">Luật Chơi Cân Bằng</h2>
            <p class="text-lg mb-4">Giữ 2 thanh <strong class="text-red-400">Học Tập</strong> và <strong class="text-blue-400">Giải Trí</strong> không bị cạn (0%) hoặc đầy (100%).</p>
            <p class="text-lg mb-6">Cứ sau vài giây, một thanh sẽ <strong class="text-yellow-400">TỰ ĐỘNG TĂNG LÊN!</strong></p>
            <div class="space-y-4 text-left p-4 bg-black/20 rounded-lg mb-6">
                <div class="flex items-center gap-4">
                    <div class="w-10 h-10 shrink-0"><div class="tutorial-gem" style="background-color: #1E90FF"></div></div>
                    <div>Để <strong class="text-red-400">GIẢM</strong> thanh Học Tập, hãy ăn kim cương <strong class="text-blue-400">XANH</strong>.</div>
                </div>
                <div class="flex items-center gap-4">
                    <div class="w-10 h-10 shrink-0"><div class="tutorial-gem" style="background-color: #FF3131"></div></div>
                    <div>Để <strong class="text-blue-400">GIẢM</strong> thanh Giải Trí, hãy ăn kim cương <strong class="text-red-400">ĐỎ</strong>.</div>
                </div>
            </div>
            <button id="balance-tutorial-finish-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-full hover:bg-purple-700 transition-transform hover:scale-105">Vào Chơi Thôi!</button>
        </div>

    </div>
</div>

<div id="custom-cursor"></div>

<!-- Màn hình chơi chính (Story/Free mode) -->
<div id="game-ui" class="w-full max-w-7xl mx-auto flex-col md:flex-row md:items-start justify-center gap-4 md:gap-8 hidden">
    <!-- Cột mục tiêu (Trái) -->
    <div id="objective-panel" class="w-full md:w-1/4 order-3 md:order-1 mt-4 md:mt-0">
        <div class="title-container text-center md:text-left mb-4">
            <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-2" id="game-title">Bảo Vệ Trái Tim</h1>
            <p class="text-gray-200 italic text-lg md:text-xl" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">Tiêu diệt quái vật thuốc lá!</p>
        </div>
        <div class="p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <h2 class="text-xl font-bold text-white/80 mb-2">Mục Tiêu</h2>
            <progress id="health-bar" class="w-full h-5 rounded-full overflow-hidden border border-white/10 mb-4" value="0" max="100"></progress>
            <div class="space-y-2" id="quest-list"></div>
        </div>
    </div>

    <!-- Cột chơi game (Giữa) - Sẽ được sao chép vào Balance Mode -->
    <div class="w-full max-w-md text-center order-2 md:order-2">
        <div class="relative" id="game-container">
            <div id="character-container">
                <div class="character-aura"></div>
                <svg id="cigarette-svg" viewBox="0 0 200 100">
                    <defs>
                        <filter id="smokeFilter"><feTurbulence type="fractalNoise" baseFrequency="0.02 0.05" numOctaves="3" result="turbulence" /><feDisplacementMap in2="turbulence" in="SourceGraphic" scale="15" xChannelSelector="R" yChannelSelector="G" /></filter>
                        <filter id="emberGlow"><feGaussianBlur stdDeviation="3.5" result="coloredBlur" /><feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge></filter>
                        <radialGradient id="paper-gradient"><stop offset="0%" stop-color="#d2b48c" /><stop offset="100%" stop-color="#c8a97e" /></radialGradient>
                    </defs>
                    <path class="filter-shape" d="M160,30 L180,28 Q192,30 190,50 Q188,70 180,72 L160,70 Z" /><path class="cigarette-body-shape" d="M20,30 L160,30 L160,70 L20,70 Q10,70 10,50 Q10,30 20,30 Z" /><path class="stain" d="M110,40 C 120,35 130,45 125,55 C 120,60 110,55 110,40 Z" /><path class="stain" d="M70,60 C 75,55 85,58 80,68 Z" /><path class="crack" d="M140,45 C 145,50, 145,55, 150,60" /><path class="crack" d="M100,35 C 105,45, 95,55, 100,65" /><path class="crack" d="M40,35 L 45,65" /><path class="crack" d="M155,35 L 158,65" /><path class="ash-shape" d="M20,30 Q10,30 10,50 Q10,70 20,70 L30,70 Q25,50 30,30 Z" /><path d="M28 40 L 32 38 M28 50 L 33 50 M28 60 L 32 62" stroke="#a0522d" stroke-width="1" /><path class="ember-shape" d="M25,35 Q20,50 25,65 L20,65 Q15,50 20,35 Z" /><g id="sparks"><circle class="spark" cx="22" cy="40" r="1.5" style="animation-delay: 0s; --y-end: -20px;"></circle><circle class="spark" cx="20" cy="50" r="1" style="animation-delay: 0.5s; --y-end: 0px;"></circle><circle class="spark" cx="22" cy="60" r="1.5" style="animation-delay: 1s; --y-end: 20px;"></circle></g><g id="face"><g id="eye1_group"><circle class="eye-socket" cx="55" cy="50" r="12" /><circle class="eye-ball" cx="55" cy="50" r="11" /><path class="eye-vein" d="M50,50 C 52,47 55,47 57,50" /><path class="eye-vein" d="M57,50 C 59,53 62,53 85,50" /><circle class="eye-pupil" id="pupil1" cx="55" cy="50" r="5" /></g><g id="eye2_group"><circle class="eye-socket" cx="80" cy="50" r="12" /><circle class="eye-ball" cx="80" cy="50" r="11" /><path class="eye-vein" d="M75,50 C 77,47 80,47 82,50" /><path class="eye-vein" d="M82,50 C 84,53 87,53 85,50" /><circle class="eye-pupil" id="pupil2" cx="80" cy="50" r="5" /></g><path class="mouth" id="mouth-path" d="M60 65 L 64 63 L 68 65 L 72 63 L 76 65" /></g>
                </svg>
                <div class="smoke-container"><div class="smoke-wisp"></div><div class="smoke-wisp"></div><div class="smoke-wisp"></div></div>
                <div id="threat-bubble"><p id="threat-text"></p></div>
                <div id="monster-name" class="text-center"><p class="text-lg font-bold text-red-400" style="text-shadow: 0 0 8px rgba(255, 0, 0, 0.7);">Quái vật thuốc lá</p></div>
            </div>
            <canvas id="gameCanvas" role="img" aria-label="Bảng chơi Kim Cương: cứu trái tim bằng cách ghép 3 viên"></canvas>
            
        </div>
    </div>
    
    <!-- Cột thông số (Phải) -->
    <div id="story-mode-stats" class="w-full md:w-1/4 order-1 md:order-3 flex flex-row md:flex-col justify-around md:justify-start gap-2 md:gap-6 mb-4 md:mb-0">
        <div class="flex-1 md:flex-auto p-2 md:p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10"><p class="text-base md:text-lg font-bold text-white/70">Cấp Độ</p><p class="text-3xl md:text-4xl font-bold text-white" id="level">1</p></div>
        <div class="flex-1 md:flex-auto p-2 md:p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10"><p class="text-base md:text-lg font-bold text-white/70">Nước đi</p><p class="text-3xl md:text-4xl font-bold text-white" id="moves">0</p></div>
        <div class="flex-1 md:flex-auto p-2 md:p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10"><p class="text-base md:text-lg font-bold text-white/70">Đã cứu</p><p class="text-3xl md:text-4xl font-bold text-white" id="score">0</p></div>
    </div>
</div>

<!-- Màn hình chơi Cân Bằng (thiết kế mới) -->
<div id="balance-mode-screen" class="w-full h-screen flex-col items-center justify-center gap-4 hidden p-4">
    <div id="balance-message">
        Hãy cân bằng học tập và giải trí – Đừng để áp lực đẩy bạn đến thuốc lá.
    </div>
    <div id="balance-three-columns" class="w-full flex-grow">
        <!-- Cột thông tin bên trái -->
        <div class="info-panel w-full md:w-1/4 h-full hidden md:flex flex-col">
            <h2 class="text-red-400">TÁC HẠI THUỐC LÁ</h2>
            <ul id="facts-list" class="flex-grow space-y-2">
                <li><span class="icon text-red-500"><i class="fas fa-skull-crossbones"></i></span><span>Hơn 8 triệu người chết mỗi năm trên toàn cầu.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-lungs-virus"></i></span><span>Gây ung thư phổi, bệnh tim và đột quỵ.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-child"></i></span><span>Hút thuốc thụ động gây hại cho gia đình và bạn bè.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-wallet"></i></span><span>Tiêu tốn một khoản tiền lớn mỗi năm.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-smoking-ban"></i></span><span>Chứa hơn 7,000 hóa chất, hàng trăm chất độc hại.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-tooth"></i></span><span>Gây vàng răng, hôi miệng và các bệnh về nướu.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-running"></i></span><span>Làm giảm sức bền thể chất và khả năng vận động.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-brain"></i></span><span>Tăng nguy cơ mắc bệnh Alzheimer và suy giảm trí nhớ.</span></li>
            </ul>
        </div>

        <!-- Cột chơi game ở giữa -->
        <div id="balance-center-column" class="w-full md:w-1/2 h-full flex flex-col items-center justify-center">
            <div id="balance-scale-container">
                <div id="balance-chain">
                    <div id="balance-pivot"></div>
                </div>
                <div class="balance-tube-wrapper left">
                    <div class="danger-icon" id="study-danger-icon">📚</div>
                    <div class="balance-tube">
                        <div id="study-liquid" class="balance-liquid study"></div>
                        <div id="study-percentage" class="tube-percentage">50%</div>
                    </div>
                    <div class="tube-label">Học Tập</div>
                </div>
                <div class="balance-tube-wrapper right">
                     <div class="danger-icon" id="play-danger-icon">🎮</div>
                    <div class="balance-tube">
                        <div id="play-liquid" class="balance-liquid play"></div>
                        <div id="play-percentage" class="tube-percentage">50%</div>
                    </div>
                    <div class="tube-label">Giải Trí</div>
                </div>
            </div>
            <div id="balance-game-board" class="w-full max-w-md">
                <!-- Canvas sẽ được chuyển vào đây bằng JS -->
            </div>
            <div id="balance-mode-stats">
                <div class="stat-item">
                    <p>Level</p>
                    <span id="balance-level">1</span>
                </div>
                <div class="stat-item">
                    <p>Time</p>
                    <span id="balance-timer">60</span>
                </div>
            </div>
        </div>

        <!-- Cột thông tin bên phải -->
        <div class="info-panel w-full md:w-1/4 h-full hidden md:flex flex-col">
            <h2 class="text-cyan-400">LỐI SỐNG LÀNH MẠNH</h2>
            <ul id="skills-list" class="flex-grow space-y-2">
                <li><span class="icon text-cyan-500"><i class="fas fa-dumbbell"></i></span><span>Tập thể dục ít nhất 30 phút mỗi ngày.</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-book-open"></i></span><span>Đọc một chương sách để thư giãn và học hỏi.</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-users"></i></span><span>Gọi điện hoặc gặp gỡ bạn bè, người thân.</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-brain"></i></span><span>Học một kỹ năng mới: nhạc cụ, ngôn ngữ, vẽ...</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-leaf"></i></span><span>Đi dạo ngoài trời, hít thở không khí trong lành.</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-music"></i></span><span>Nghe một bản nhạc yêu thích để giảm căng thẳng.</span></li>
                 <li><span class="icon text-cyan-500"><i class="fas fa-utensils"></i></span><span>Thử nấu một món ăn mới, tốt cho sức khỏe.</span></li>
                 <li><span class="icon text-cyan-500"><i class="fas fa-bed"></i></span><span>Ngủ đủ 7-8 tiếng mỗi đêm để phục hồi năng lượng.</span></li>
            </ul>
        </div>
    </div>
</div>


<!-- Game Modals -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="winModal" role="dialog" aria-modal="true" tabindex="-1" aria-labelledby="winModalTitle">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95"><h2 class="text-4xl font-bold text-green-600 mb-4" id="winModalTitle">Qua Màn!</h2><p class="text-lg text-gray-700 mb-6" id="win-level-text"></p><button class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-300" id="nextLevelButton">Tiếp tục</button></div>
</div>

<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="gameOverModal" role="dialog" aria-modal="true" tabindex="-1" aria-labelledby="gameOverModalTitle">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95"><h2 class="text-4xl font-bold text-red-800 mb-4" id="gameOverModalTitle">Thất Bại!</h2><p class="text-lg text-gray-700 mb-2" id="gameOverReason">Mất cân bằng!</p><p class="text-xl text-gray-800 mb-8" id="gameOverMessageContainer"></p><div class="flex flex-col sm:flex-row gap-4 justify-center"><button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="gameOverHomeButton">Về Trang Chủ</button><button class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105" id="gameOverRestartButton">Chơi Lại</button></div></div>
</div>
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm" id="factModal" role="dialog" aria-modal="true" tabindex="-1" aria-labelledby="factModalTitle">
    <div class="bg-white rounded-2xl p-6 md:p-8 text-center shadow-2xl transform transition-all scale-95 max-w-md w-full"><h2 class="text-2xl md:text-3xl font-bold text-blue-700 mb-4" id="factModalTitle">Sự Thật & Lời Khuyên</h2><p class="text-base md:text-lg text-gray-800 mb-3 text-left" id="factText"></p><p class="text-base md:text-lg text-green-700 font-semibold mb-6 text-left" id="adviceText"></p><button class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300" id="closeFactButton">Đã hiểu</button></div>
</div>
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="finalWinModal" role="dialog" aria-modal="true" tabindex="-1">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95"><h2 class="text-4xl font-bold text-yellow-500 mb-4">CHIẾN THẮNG!</h2><p class="text-lg text-gray-700 mb-2">Bạn đã bảo vệ thành công những trái tim khỏi nanh vuốt của quái vật!</p><p class="text-xl text-gray-800 mb-6">Cảm ơn bạn đã trở thành người hùng!</p><div class="flex flex-col sm:flex-row gap-4 justify-center"><button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="restartGameButton">Chơi lại</button><button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="backToIndexButton">Về màn hình chính</button><button class="bg-yellow-500 text-white font-bold py-3 px-8 rounded-full hover:bg-yellow-600 transition-transform transform hover:scale-110 ring-4 ring-yellow-300 shadow-lg shadow-yellow-500/50" id="continueToNextGameButton">Tiếp tục</button></div></div>
</div>

<div id="copyright">
    © <span id="year"></span> Thầy Thái Minh Nguyên - Trường Tiểu học, THCS & THPT Yersin Đà Lạt. All rights reserved.
</div>

<script>
(function() {
    'use strict';

    // --- MODULE: CONSTANTS & CONFIGURATION ---
    const CONFIG = {
        GRID_SIZE: 8,
        GEM_COLORS: ['#FF3131', '#00FF7F', '#1E90FF', '#FF00FF', '#FF8C00', '#FFFF00'],
        HEART_EMOJI: '💗',
        MOVES_PER_HEART_SPAWN: 3,
        CIGARETTE_LUNGE_CHANCE: 0.25,
        THREAT_INTERVAL: 6000,
        ANIM_SWAP_SPEED: 150,
        ANIM_FALL_SPEED: 400,
        ANIM_CLEAR_SPEED: 200,
        ANIM_SPECIAL_PULSE_SPEED: 150,
        MAX_PARTICLES: 150, 
        HINT_TIMEOUT: 5000,
        FINAL_LEVEL: 1,
        COUGH_INTERVAL_MOVES: 10,
        COUGH_START_LEVEL: 2,
        WATCHDOG_TIMEOUT: 5000,
        BALANCE_MODE: {
            STUDY_GEM_INDEX: 0, // Index for red gem (Học Tập)
            PLAY_GEM_INDEX: 2,  // Index for blue gem (Giải Trí)
            POINTS_PER_GEM_REDUCTION: 8, // Điểm mỗi viên kim cương làm giảm thanh đối diện
            PASSIVE_INCREASE_INTERVAL: 2000, // Cứ 2 giây sẽ tăng một lần
            WARNING_THRESHOLD: 85,
            MAX_TILT_ANGLE: 10, // degrees
            INFO_PANEL_INTERVAL: 15000 // 15 giây
        }
    };

    const SPECIAL_TYPES = { NONE: 'none', H_BEAM: 'h_beam', V_BEAM: 'v_beam', BOMB: 'bomb', HYPERCUBE: 'hypercube' };

    const HEALTH_FACTS = [
        { fact: "Thuốc lá giết **hơn 7 triệu người/năm**, trong đó có khoảng **1,6 triệu người không hút thụ động**. (Nguồn: WHO)", advice: "Lời khuyên: Hãy tránh xa khói thuốc để bảo vệ bạn và những người xung quanh." },
        { fact: "Hút thuốc không thụ động (passive smoking) cũng gây ung thư phổi, bệnh tim và nhiều vấn đề sức khỏe nghiêm trọng. (Nguồn: CDC / IARC)", advice: "Lời khuyên: Đừng để khói thuốc xâm nhập không khí sống, giữ sạch môi trường cho phổi bạn." },
        { fact: "Hút thuốc gây tổn thương **gan, phổi, tim**, làm tăng nguy cơ mắc **COPD, nhồi máu cơ tim, đột quỵ** và nhiều loại ung thư. (Nguồn: CDC)", advice: "Lời khuyên: Mỗi hơi thuốc bạn hít vào là tổn hại cho cơ thể—ngưng ngay hôm nay để khỏe mạnh hơn." },
    ];
    
    const THREATS = [ "Ta nếm được nỗi sợ của ngươi.", "Mỗi tế bào của ngươi đang gào thét.", "Ta là cái chết chậm rãi ngươi tự chọn.", "Linh hồn ngươi... sẽ là làn khói tiếp theo.", "Không có lối thoát đâu." ];

    // --- MODULE: GAME STATE & DOM ELEMENTS ---
    let DOMElements;
    let gemSize, board = [], selectedGem = null, score = 0, moves = 0, isAnimating = false;
    let isPaused = false, animations = [], particles = [], particlePool = [], hintTimeout = null;
    let cigarette = { col: Math.floor(CONFIG.GRID_SIZE / 2), level: 1 };
    let currentLevel = 1, quest = {}, startDragPos = { x: null, y: null }, startGem = null;
    let isDragging = false, gemCache = {}, hintGems = [], isFreePlayMode = false;
    let resizeTimer = null, factsShown = [], threatInterval = null, currentModal = null, isTutorialOnly = false;
    let animationWatchdog = null, isPausedForFact = false;
    let gameMode = 'story'; // 'story', 'free', 'balance'
    let currentDifficulty = 'easy';
    let studyValue = 50, playValue = 50, balanceTimerInterval = null, balanceTimeLeft = 60, currentBalanceLevel = 1, balanceMovesMade = 0;
    let passiveIncreaseInterval = null, infoPanelInterval = null;


    // --- MODULE: AUDIO MANAGER ---
    const AudioManager = {
        isInitialized: false, isMusicStarted: false, sfxBus: null, sfx: {},
        async init() {
            if (this.isInitialized) return;
            await Tone.start();
            this.sfxBus = new Tone.Volume(-8).toDestination();
            this.sfx.select = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).connect(this.sfxBus);
            this.sfx.match = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.7 }).connect(this.sfxBus);
            this.sfx.bombKick = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).connect(this.sfxBus);
            this.sfx.bombNoise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).connect(this.sfxBus);
            const beamFilter = new Tone.AutoFilter("16n").connect(this.sfxBus).start();
            beamFilter.baseFrequency = 400; beamFilter.octaves = 3;
            this.sfx.beam = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0 } }).connect(beamFilter);
            this.sfx.unlock = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, release: 0.1 } }).connect(this.sfxBus);
            this.isInitialized = true;
        },
        startMusic() {
            if (!this.isMusicStarted) {
                const music = document.getElementById("bg-music");
                if (music && music.getAttribute('src')) {
                    music.volume = 0.2; 
                    music.play().catch(e => console.warn("Audio play failed, likely due to missing file:", e.message)); 
                    this.isMusicStarted = true; 
                }
            }
        },
        playSfx(type) {
            if (!this.isInitialized) return;
            const now = Tone.now();
            try {
                switch (type) {
                    case 'select': this.sfx.select.triggerAttackRelease('C7', '32n', now); break;
                    case 'match': this.sfx.match.triggerAttackRelease('G5', '8n', now); break;
                    case 'bomb': this.sfx.bombKick.triggerAttackRelease('C2', '8n', now); this.sfx.bombNoise.triggerAttackRelease('16n', now + 0.01); break;
                    case 'unlock': this.sfx.unlock.triggerAttackRelease('A6', '16n', now); break;
                    case 'beam': case 'hypercube': this.sfx.beam.triggerAttackRelease('8n', now); break;
                }
            } catch (e) { console.error('SFX error:', e); }
        }
    };

    // --- MODULE: UI & RENDERING ---
    function showModal(modalElement, focusElement) {
        currentModal = modalElement;
        modalElement.classList.remove('hidden');
        setTimeout(() => { 
            const innerDiv = modalElement.querySelector('div');
            if(innerDiv) innerDiv.classList.add('scale-100');
            if (focusElement) focusElement.focus(); 
            trapFocus(modalElement);
        }, 10);
    }

    function hideModal(modalElement) {
        if (modalElement) {
            releaseFocus(modalElement);
            const innerDiv = modalElement.querySelector('div');
            if(innerDiv) innerDiv.classList.remove('scale-100'); 
            setTimeout(() => modalElement.classList.add('hidden'), 200); 
        }
        currentModal = null;
    }
    
    function trapFocus(modal) {
      if (!modal) return;
      const focusables = modal.querySelectorAll('button, a, input, textarea, [tabindex]:not([tabindex="-1"])');
      if (!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      
      function keyHandler(e) {
        if (e.key === 'Tab') {
          if (e.shiftKey && document.activeElement === first) {
            e.preventDefault(); last.focus();
          } else if (!e.shiftKey && document.activeElement === last) {
            e.preventDefault(); first.focus();
          }
        }
      }
      modal._keyHandler = keyHandler;
      modal.addEventListener('keydown', keyHandler);
    }
    
    function releaseFocus(modal) {
      if (modal && modal._keyHandler) {
          modal.removeEventListener('keydown', modal._keyHandler);
          delete modal._keyHandler;
      }
    }

    function showThreat() {
        if (isPaused || !DOMElements.gameOverModal.classList.contains('hidden') || DOMElements.characterContainerEl.classList.contains('attacking')) return;
        DOMElements.threatText.textContent = THREATS[Math.floor(Math.random() * THREATS.length)];
        DOMElements.mouth.setAttribute('d', 'M58 68 L 64 60 L 70 68 L 76 60 L 82 68');
        DOMElements.characterContainerEl.classList.add('attacking');
        DOMElements.threatBubble.classList.add('visible');
        setTimeout(() => {
            DOMElements.threatBubble.classList.remove('visible');
            DOMElements.mouth.setAttribute('d', 'M60 65 L 64 63 L 68 65 L 72 63 L 76 65');
            DOMElements.characterContainerEl.classList.remove('attacking');
        }, 2000);
    }

    async function showFact() {
        isPaused = true;
        isPausedForFact = true;
        clearTimeout(hintTimeout);
        let availableFacts = HEALTH_FACTS.filter(obj => !factsShown.includes(obj));
        if (availableFacts.length === 0) factsShown = [];
        const factObject = availableFacts.length > 0 ? availableFacts[Math.floor(Math.random() * availableFacts.length)] : HEALTH_FACTS[0];
        factsShown.push(factObject);
        DOMElements.factText.innerHTML = factObject.fact.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        DOMElements.adviceText.innerHTML = factObject.advice.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        showModal(DOMElements.factModal, DOMElements.closeFactButton);
    }

    function showGameOver(reason = "Mất cân bằng!") {
        if (animationWatchdog) clearTimeout(animationWatchdog);
        isAnimating = true; isPaused = true; 
        if (threatInterval) clearInterval(threatInterval);
        if (balanceTimerInterval) clearInterval(balanceTimerInterval);
        if (passiveIncreaseInterval) clearInterval(passiveIncreaseInterval);
        if (infoPanelInterval) clearInterval(infoPanelInterval);

        if(gameMode === 'balance'){
            DOMElements.gameOverReason.textContent = reason;
            const timeSurvived = (60 + (currentBalanceLevel-1)*30) - balanceTimeLeft;
            DOMElements.gameOverMessageContainer.innerHTML = `Bạn đã cân bằng được ${timeSurvived} giây.`;
        } else {
            DOMElements.gameOverReason.textContent = "Thuốc lá đã làm hại một trái tim.";
            DOMElements.gameOverMessageContainer.innerHTML = `Bạn đã bảo vệ được <span class="font-bold text-pink-600">${score}</span> trái tim.`;
        }
        
        showModal(DOMElements.gameOverModal, DOMElements.gameOverModal.querySelector('#gameOverRestartButton'));
    }

    function updateQuestUI() {
        if (gameMode === 'balance') return;
        DOMElements.questList.innerHTML = '';
        for (const colorIdx in quest.targets) {
            const remaining = Math.max(0, quest.targets[colorIdx] - quest.collected[colorIdx]);
            const item = document.createElement('div');
            item.className = `flex items-center justify-between p-2 rounded-lg transition-all ${remaining === 0 ? 'bg-green-500/30' : 'bg-black/20'}`;
            item.innerHTML = `<div class="w-6 h-6 rounded-full border-2 border-white/20" style="background-color: ${CONFIG.GEM_COLORS[colorIdx]}"></div><span class="font-bold text-white">${remaining}</span>`;
            DOMElements.questList.appendChild(item);
        }
        const remainingHearts = Math.max(0, quest.heartsToSave - quest.heartsSaved);
        const heartItem = document.createElement('div');
        heartItem.className = `flex items-center justify-between p-2 rounded-lg transition-all ${remainingHearts === 0 ? 'bg-green-500/30' : 'bg-black/20'}`;
        heartItem.innerHTML = `<span class="text-2xl">${CONFIG.HEART_EMOJI}</span><span class="font-bold text-white">${remainingHearts}</span>`;
        DOMElements.questList.appendChild(heartItem);
    }

    function updateHealthBar() {
        const percentage = quest.maxDamage > 0 ? Math.min(100, (quest.totalDamage / quest.maxDamage) * 100) : 0;
        DOMElements.healthBar.value = percentage;
    }
    function updateScore() { DOMElements.scoreEl.textContent = score; }
    function updateMoves() { DOMElements.movesEl.textContent = moves; }

    function drawBoard(time) {
        const { ctx } = DOMElements;
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                const gem = board[row][col];
                if (!gem) continue;
                ctx.save();
                ctx.globalAlpha = gem.alpha;
                const centerX = gem.x + gemSize / 2, centerY = gem.y + gemSize / 2;
                ctx.translate(centerX, centerY); ctx.scale(gem.scale, gem.scale); ctx.translate(-centerX, -centerY);
                let cacheKey = gem.special === SPECIAL_TYPES.HYPERCUBE ? SPECIAL_TYPES.HYPERCUBE : (gem.special !== SPECIAL_TYPES.NONE ? `${gem.special}_${gem.colorIndex}` : CONFIG.GEM_COLORS[gem.colorIndex]);
                if (gemCache[cacheKey]) ctx.drawImage(gemCache[cacheKey], gem.x, gem.y, gemSize, gemSize);
                if (gem.isLocked) ctx.drawImage(gemCache['chain'], gem.x, gem.y, gemSize, gemSize);
                if (gem.isHeart) {
                    ctx.save();
                    ctx.translate(gem.x + gemSize / 2, gem.y + gemSize / 2); ctx.scale(Math.sin(time / 300) * 0.1 + 1.1, Math.sin(time / 300) * 0.1 + 1.1);
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0)'; ctx.font = `${gemSize * 0.6}px sans-serif`; ctx.fillText(CONFIG.HEART_EMOJI, 0, 0);
                    ctx.restore();
                }
                ctx.restore();
            }
        }
    }

    function drawHint(time) {
        if (hintGems.length === 2 && !isAnimating) {
            const [gem1, gem2] = hintGems;
            const pulse = (Math.sin(time / 200) + 1) / 2;
            const scale = 1 + 0.05 * pulse;
            const drawPulse = (gem) => {
                if (!gem) return;
                const { ctx } = DOMElements;
                ctx.save();
                const centerX = gem.x + gemSize / 2, centerY = gem.y + gemSize / 2;
                ctx.translate(centerX, centerY); ctx.scale(scale, scale); ctx.translate(-centerX, -centerY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`; ctx.lineWidth = 4;
                ctx.strokeRect(gem.x + 2, gem.y + 2, gemSize - 4, gemSize - 4);
                ctx.restore();
            };
            drawPulse(gem1); drawPulse(gem2);
        }
    }

    function drawParticles() {
        const { ctx } = DOMElements;
        for (let i = particlePool.length - 1; i >= 0; i--) {
            const p = particlePool[i];
            if (!p.active) continue;
            p.x += p.vx; p.y += p.vy; p.alpha -= 0.02;
            if (p.alpha <= 0) { p.active = false; } 
            else {
                ctx.save(); ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }
    }

    function drawSelection(time) {
        if (selectedGem) {
            const { ctx } = DOMElements;
            const pulse = Math.sin(time / 100) * 0.5 + 0.5;
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`; ctx.lineWidth = 4;
            ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
        }
    }

    async function preRenderGems() {
        gemCache = {}; const promises = []; const specials = Object.values(SPECIAL_TYPES); const size = Math.max(1, Math.round(gemSize));
        CONFIG.GEM_COLORS.forEach((col) => { const canvas = renderGemCanvas(col, size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[col] = img; })); } else { gemCache[col] = canvas; } });
        specials.forEach(special => {
            if (special === SPECIAL_TYPES.HYPERCUBE) { const canvas = renderHypercubeCanvas(size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[special] = img; })); } else { gemCache[special] = canvas; } } 
            else if (special !== SPECIAL_TYPES.NONE) { CONFIG.GEM_COLORS.forEach((col, idx) => { const canvas = renderSpecialCanvas(special, col, size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[`${special}_${idx}`] = img; })); } else { gemCache[`${special}_${idx}`] = canvas; } }); }
        });
        const chainCanvas = renderChainCanvas(size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(chainCanvas).then(img => { gemCache['chain'] = img; })); } else { gemCache['chain'] = canvas; }
        await Promise.all(promises);
    }
    
    function renderGemCanvas(color, size) {
        const offscreenCanvas = document.createElement('canvas'); offscreenCanvas.width = size; offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        offscreenCtx.shadowColor = 'rgba(0, 0, 0, 0.2)'; offscreenCtx.shadowBlur = 5; offscreenCtx.shadowOffsetX = 2; offscreenCtx.shadowOffsetY = 2;
        const shadeColor = (col, percent) => { let f = parseInt(col.slice(1), 16), t = percent < 0 ? 0 : 255, p = Math.abs(percent), R = f >> 16, G = (f >> 8) & 0xff, B = f & 0xff; const hex = (0x1000000 + (Math.round((t-R)*p)+R)*0x10000 + (Math.round((t-G)*p)+G)*0x100 + (Math.round((t-B)*p)+B)).toString(16).slice(1); return `#${hex.padStart(6,'0')}`; };
        const lightColor = shadeColor(color, 0.6), darkColor = shadeColor(color, -0.6);
        const grad = offscreenCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, half); grad.addColorStop(0, lightColor); grad.addColorStop(1, color);
        offscreenCtx.fillStyle = grad; offscreenCtx.beginPath(); offscreenCtx.moveTo(centerX, centerY - half); offscreenCtx.lineTo(centerX + half, centerY); offscreenCtx.lineTo(centerX, centerY + half); offscreenCtx.lineTo(centerX - half, centerY); offscreenCtx.closePath(); offscreenCtx.fill();
        offscreenCtx.strokeStyle = darkColor; offscreenCtx.lineWidth = 2; offscreenCtx.stroke();
        return offscreenCanvas;
    }

    function renderSpecialCanvas(special, color, size) {
        const canvas = renderGemCanvas(color, size); const ctx = canvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        ctx.fillStyle = 'white'; ctx.shadowColor = 'white'; ctx.shadowBlur = 10;
        if(special === SPECIAL_TYPES.H_BEAM) { ctx.fillRect(centerX - half, centerY - half * 0.1, s, half * 0.2); } 
        else if (special === SPECIAL_TYPES.V_BEAM) { ctx.fillRect(centerX - half * 0.1, centerY - half, half * 0.2, s); } 
        else if (special === SPECIAL_TYPES.BOMB) { ctx.fillStyle = `rgba(255, 255, 255, 0.8)`; ctx.beginPath(); ctx.arc(centerX, centerY, half * 0.6, 0, 2 * Math.PI); ctx.fill(); }
        return canvas;
    }

    function renderHypercubeCanvas(size) {
        const offscreenCanvas = document.createElement('canvas'); offscreenCanvas.width = size; offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        offscreenCtx.shadowColor = 'rgba(255, 255, 255, 0.7)'; offscreenCtx.shadowBlur = 10;
        for (let i = 0; i < 6; i++) { offscreenCtx.fillStyle = CONFIG.GEM_COLORS[i]; offscreenCtx.beginPath(); offscreenCtx.moveTo(centerX,centerY); const angle1 = (i / 6) * 2 * Math.PI, angle2 = ((i+1) / 6) * 2 * Math.PI; offscreenCtx.arc(centerX,centerY, half, angle1, angle2); offscreenCtx.closePath(); offscreenCtx.fill(); }
        return offscreenCanvas;
    }

    function renderChainCanvas(size) {
        const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d'); const p = size * 0.1, lw = size * 0.08;
        ctx.strokeStyle = 'rgba(200, 200, 220, 0.7)'; ctx.lineWidth = lw; ctx.lineCap = 'round'; ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 4;
        ctx.beginPath(); ctx.moveTo(p, p); ctx.lineTo(size - p, size - p); ctx.moveTo(size - p, p); ctx.lineTo(p, size - p); ctx.stroke();
        return canvas;
    }
    
    // --- MODULE: CORE GAME LOGIC ---
    async function handleSuccessfulMove() {
        if (gameMode === 'balance') {
            balanceMovesMade++;
            if (!hasPossibleMoves(board)) {
                await reshuffleBoard();
            }
            return;
        }

        if (DOMElements.gameOverModal.classList.contains('hidden') && DOMElements.winModal.classList.contains('hidden') && DOMElements.finalWinModal.classList.contains('hidden')) {
            await moveCigarette();
            if (checkGameOver()) return;
            spawnHeartIfNeeded();
            checkWinCondition();
            if (!hasPossibleMoves(board)) {
                await reshuffleBoard();
            }
        }
    }

    async function triggerSpecialCombo(gemA, gemB) {
        // This function is for combos that DO NOT involve a Hypercube.
        const gemsToClear = new Set([gemA, gemB]);
        const { row, col } = gemA; // The combo is centered on the gem that was moved.
        
        const typeA = gemA.special;
        const typeB = gemB.special;

        const isBomb = (type) => type === SPECIAL_TYPES.BOMB;
        const isBeam = (type) => type === SPECIAL_TYPES.H_BEAM || type === SPECIAL_TYPES.V_BEAM;

        // Bomb + Bomb
        if (isBomb(typeA) && isBomb(typeB)) {
            AudioManager.playSfx('bomb');
            for (let r = row - 2; r <= row + 2; r++) {
                for (let c = col - 2; c <= col + 2; c++) {
                    if (r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) {
                        gemsToClear.add(board[r][c]);
                    }
                }
            }
        }
        // Beam + Beam
        else if (isBeam(typeA) && isBeam(typeB)) {
             AudioManager.playSfx('beam');
             for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (board[row][c]) gemsToClear.add(board[row][c]); }
             for (let r = 0; r < CONFIG.GRID_SIZE; r++) { if (board[r][col]) gemsToClear.add(board[r][col]); }
        }
        // Bomb + Beam
        else if ((isBomb(typeA) && isBeam(typeB)) || (isBeam(typeA) && isBomb(typeB))) {
            AudioManager.playSfx('bomb');
            AudioManager.playSfx('beam');
            for (let r = row - 1; r <= row + 1; r++) {
                if (r >= 0 && r < CONFIG.GRID_SIZE) {
                    for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (board[r][c]) gemsToClear.add(board[r][c]); }
                }
            }
            for (let c = col - 1; c <= col + 1; c++) {
                if (c >= 0 && c < CONFIG.GRID_SIZE) {
                    for (let r = 0; r < CONFIG.GRID_SIZE; r++) { if (board[r][c]) gemsToClear.add(board[r][c]); }
                }
            }
        }

        if (gemsToClear.size > 2) {
            await cascadeMatches(Array.from(gemsToClear));
        }
    }

    async function processSwap(gem1, gem2) {
        if (isAnimating || isPaused || gem1.isLocked || gem2.isLocked) return;
        isAnimating = true; 
        selectedGem = null;
        
        if (animationWatchdog) clearTimeout(animationWatchdog);
        animationWatchdog = setTimeout(() => {
            console.error("WATCHDOG: Game logic took too long. Forcing state reset.");
            isAnimating = false; isPaused = false; resetHintTimer();
        }, CONFIG.WATCHDOG_TIMEOUT);

        try {
            const isHyperCombo = gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE;
            const isSpecialCombo = gem1.special !== SPECIAL_TYPES.NONE && gem2.special !== SPECIAL_TYPES.NONE;

            if (isHyperCombo) {
                moves++; 
                updateMoves();
                const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
                const otherGem = hypercube === gem1 ? gem2 : gem1;
                await triggerHypercube(hypercube, otherGem);
                await handleSuccessfulMove();
            } else if (isSpecialCombo) {
                moves++;
                updateMoves();
                await swapGems(gem1, gem2);
                await triggerSpecialCombo(gem1, gem2); // Combo happens at gem1's new location
                await handleSuccessfulMove();
            } else {
                const startPos1 = { row: gem1.row, col: gem1.col }, startPos2 = { row: gem2.row, col: gem2.col };
                await swapGems(gem1, gem2);
                const matchInfo = findMatchesAndSpecial(startPos1, startPos2);
                if (matchInfo.allMatches.length > 0) {
                    moves++; 
                    updateMoves();
                    await cascadeMatches(matchInfo.allMatches, matchInfo.specialToCreate);
                    await handleSuccessfulMove();
                } else {
                    await sleep(100);
                    await swapGems(gem1, gem2);
                }
            }
        } catch(error) { 
            console.error("Error during swap process:", error); 
        } finally {
            clearTimeout(animationWatchdog);
            isAnimating = false;
            resetHintTimer();
        }
    }

    async function cascadeMatches(initialMatches, specialToCreate = null) {
        try {
            let gemsToClear = new Set(initialMatches), processedSpecials = new Set();
            while (true) {
                let newGemsFromExplosion = new Set(), foundNewExplosion = false;
                for (const gem of gemsToClear) {
                    if (gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                        foundNewExplosion = true; processedSpecials.add(gem);
                        switch (gem.special) {
                            case SPECIAL_TYPES.H_BEAM: case SPECIAL_TYPES.V_BEAM: AudioManager.playSfx('beam'); break;
                            case SPECIAL_TYPES.BOMB: AudioManager.playSfx('bomb'); break;
                        }
                        getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                    }
                }
                if (!foundNewExplosion) break;
                newGemsFromExplosion.forEach(g => gemsToClear.add(g));
            }
            const savedAHeart = await handleMatches(Array.from(gemsToClear), specialToCreate);
            await sleep(150); await shiftAndRefill();
            if (savedAHeart) await showFact();
            const matchGroups = findMatches(board, true);
            if (matchGroups.length > 0) {
                await cascadeMatches([...new Set(matchGroups.flat())], findSpecialFromCascade(matchGroups));
            } else {
                if (gameMode !== 'balance' && await moveHearts()) {
                    const newMatchesFromHeartsGroups = findMatches(board, true);
                    if (newMatchesFromHeartsGroups.length > 0) {
                        await cascadeMatches([...new Set(newMatchesFromHeartsGroups.flat())], findSpecialFromCascade(newMatchesFromHeartsGroups));
                    }
                }
            }
        } catch (err) { console.error('Error in cascadeMatches:', err); if (!currentModal) { isAnimating = false; isPaused = false; resetHintTimer(); } }
    }

    async function handleMatches(matches, specialToCreate) {
        if (matches.length > 0) AudioManager.playSfx('match');
        const promises = []; let heartSaved = false; let collectedForQuest = {};
        let unlockedGems = new Set();
        matches.forEach(gem => {
            const neighbors = [{ r: gem.row - 1, c: gem.col }, { r: gem.row + 1, c: gem.col }, { r: gem.row, c: gem.col - 1 }, { r: gem.row, c: gem.col + 1 }];
            neighbors.forEach(n => { if (n.r >= 0 && n.r < CONFIG.GRID_SIZE && n.c >= 0 && n.c < CONFIG.GRID_SIZE) { const neighborGem = board[n.r][n.c]; if (neighborGem && neighborGem.isLocked) unlockedGems.add(neighborGem); } });
        });
        
        for (const gem of unlockedGems) {
            gem.isLocked = false;
            const unlockAnimation = async () => {
                await animate(gem, { scale: 1.2 }, 100);
                await animate(gem, { scale: 1 }, 100);
            };
            promises.push(unlockAnimation());
        }

        if (unlockedGems.size > 0) AudioManager.playSfx('unlock');
        
        let studyGemsCount = 0;
        let playGemsCount = 0;

        matches.forEach(gem => {
            if (!gem || !board[gem.row] || board[gem.row][gem.col] !== gem) return;
            if (specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) return;
            
            if (gameMode !== 'balance' && gem.isHeart) { 
                score++; quest.heartsSaved++; updateScore(); heartSaved = true; 
            }

            const colorIdx = gem.colorIndex;

            if (gameMode === 'balance') {
                if (colorIdx === CONFIG.BALANCE_MODE.STUDY_GEM_INDEX) studyGemsCount++;
                if (colorIdx === CONFIG.BALANCE_MODE.PLAY_GEM_INDEX) playGemsCount++;
            } else if (quest.targets[colorIdx] !== undefined) {
                collectedForQuest[colorIdx] = (collectedForQuest[colorIdx] || 0) + 1;
            }

            createParticleBurst(gem.x + gemSize / 2, gem.y + gemSize / 2, CONFIG.GEM_COLORS[gem.colorIndex]);
            promises.push(new Promise(async (resolve) => {
                if (gem) {
                    await animate(gem, { scale: 0, alpha: 0 }, CONFIG.ANIM_CLEAR_SPEED, easing.easeInQuad).catch(console.error);
                    if (board[gem.row] && board[gem.row][gem.col] === gem) board[gem.row][gem.col] = null;
                } resolve();
            }));
        });
        await Promise.all(promises);

        if (gameMode === 'balance') {
            // Logic mới: Ăn màu này, giảm thanh kia
            const reductionAmount = CONFIG.BALANCE_MODE.POINTS_PER_GEM_REDUCTION;
            studyValue -= playGemsCount * reductionAmount;
            playValue -= studyGemsCount * reductionAmount;

            updateBalanceBars();
        } else {
            updateQuestProgress(collectedForQuest);
        }

        if (specialToCreate) {
            let gem = board[specialToCreate.row] && board[specialToCreate.row][specialToCreate.col];
            if (!gem) {
                gem = { row: specialToCreate.row, col: specialToCreate.col, x: specialToCreate.col * gemSize, y: specialToCreate.row * gemSize, colorIndex: specialToCreate.colorIndex ?? Math.floor(Math.random() * CONFIG.GEM_COLORS.length), isHeart: false, isLocked: false, special: SPECIAL_TYPES.NONE, scale: 0, alpha: 1 };
                board[specialToCreate.row][specialToCreate.col] = gem;
            }
            gem.special = specialToCreate.special;
            if (specialToCreate.special !== SPECIAL_TYPES.HYPERCUBE) gem.colorIndex = specialToCreate.colorIndex;
            gem.isHeart = false;
            await animate(gem, { scale: 1.5 }, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad);
            await animate(gem, { scale: 1 }, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad);
        }
        return heartSaved;
    }

    function findMatches(currentBoard, returnGroups = false) { const matches = new Set(); const groups = []; for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE - 2;) { const gem = currentBoard[r][c]; if (gem) { let match = [gem]; for (let i = c + 1; i < CONFIG.GRID_SIZE; i++) { const nextGem = currentBoard[r][i]; if (nextGem && nextGem.colorIndex === gem.colorIndex) { match.push(nextGem); } else { break; } } if (match.length >= 3) { match.forEach(m => matches.add(m)); if (returnGroups) groups.push(match); } c += match.length > 1 ? match.length : 1; } else { c++; } } } for (let c = 0; c < CONFIG.GRID_SIZE; c++) { for (let r = 0; r < CONFIG.GRID_SIZE - 2;) { const gem = currentBoard[r][c]; if (gem) { let match = [gem]; for (let i = r + 1; i < CONFIG.GRID_SIZE; i++) { const nextGem = currentBoard[i][c]; if (nextGem && nextGem.colorIndex === gem.colorIndex) { match.push(nextGem); } else { break; } } if (match.length >= 3) { match.forEach(m => matches.add(m)); if (returnGroups) groups.push(match); } r += match.length > 1 ? match.length : 1; } else { r++; } } } return returnGroups ? groups : Array.from(matches); }
    function findSpecialFromCascade(matchGroups) { let bestSpecial = null; let bestRank = 0; let processedInGroups = new Set(); for (const group of matchGroups) { if (group.length >= 5) { const middleGem = group[Math.floor(group.length / 2)]; if (processedInGroups.has(middleGem)) continue; bestRank = 3; bestSpecial = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: middleGem.colorIndex, row: middleGem.row, col: middleGem.col }; group.forEach(g => processedInGroups.add(g)); return bestSpecial; } } for (let i = 0; i < matchGroups.length; i++) { for (let j = i + 1; j < matchGroups.length; j++) { const group1 = matchGroups[i]; const group2 = matchGroups[j]; const intersection = group1.find(gem1 => group2.some(gem2 => gem1 === gem2)); if (intersection && !processedInGroups.has(intersection)) { if (bestRank < 2) { bestRank = 2; bestSpecial = { special: SPECIAL_TYPES.BOMB, colorIndex: intersection.colorIndex, row: intersection.row, col: intersection.col }; group1.forEach(g => processedInGroups.add(g)); group2.forEach(g => processedInGroups.add(g)); } } } } if (bestRank < 2) { for (const group of matchGroups) { if (group.length === 4) { const gemToReplace = group[1]; if (processedInGroups.has(gemToReplace)) continue; if (bestRank < 1) { bestRank = 1; const isHorizontal = group[0].row === group[1].row; bestSpecial = { special: isHorizontal ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: gemToReplace.colorIndex, row: gemToReplace.row, col: gemToReplace.col }; group.forEach(g => processedInGroups.add(g)); } } } } return bestSpecial; }
    
    function findMatchesAndSpecial(startPos1, startPos2) {
        const allMatches = new Set();
        const checkLine = (line) => {
            const res = [];
            for (let i = 0; i < line.length - 2; i++) {
                const g = line[i];
                if (!g) continue;
                let len = 1;
                while (i + len < line.length && line[i + len] && line[i + len].colorIndex === g.colorIndex) len++;
                if (len >= 3) {
                    const matchGroup = line.slice(i, i + len);
                    res.push(matchGroup);
                    i += len - 1;
                }
            }
            return res;
        };
        const h1 = checkLine(board[startPos1.row] || []);
        const v1 = checkLine(board.map(r => r[startPos1.col]) || []);
        const h2 = checkLine(board[startPos2.row] || []);
        const v2 = checkLine(board.map(r => r[startPos2.col]) || []);
        const groups = [h1, v1, h2, v2];
        for (const gArr of groups) {
            for (const match of gArr) {
                for (const gem of match) {
                    allMatches.add(gem);
                }
            }
        }
        let specialToCreate = null;
        const matchesArray = Array.from(allMatches);
        let intersectionGem = null;
        const movedGem = board[startPos1.row][startPos1.col];
        const otherGem = board[startPos2.row][startPos2.col];
        const checkGems = [movedGem, otherGem];
        for (const gem of checkGems) {
            if (!gem || !matchesArray.includes(gem)) continue;
            const horizontalMatch = matchesArray.filter(g => g.row === gem.row && g.colorIndex === gem.colorIndex);
            const verticalMatch = matchesArray.filter(g => g.col === gem.col && g.colorIndex === gem.colorIndex);
            if (horizontalMatch.length >= 3 && verticalMatch.length >= 3) {
                intersectionGem = gem;
                break;
            }
        }
        if (intersectionGem) {
            specialToCreate = { special: SPECIAL_TYPES.BOMB, colorIndex: intersectionGem.colorIndex, row: intersectionGem.row, col: intersectionGem.col };
        } else {
            const allLineMatches = [...h1, ...v1, ...h2, ...v2].filter(match => match.some(g => g === movedGem || g === otherGem));
            allLineMatches.sort((a, b) => b.length - a.length);
            if (allLineMatches.length > 0) {
                const longestMatch = allLineMatches[0];
                const pivotGem = longestMatch.includes(movedGem) ? movedGem : otherGem;
                if (longestMatch.length >= 5) {
                    specialToCreate = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: pivotGem.colorIndex, row: pivotGem.row, col: pivotGem.col };
                } else if (longestMatch.length === 4) {
                    const isHorizontal = longestMatch[0].row === longestMatch[1].row;
                    specialToCreate = { special: isHorizontal ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: pivotGem.colorIndex, row: pivotGem.row, col: pivotGem.col };
                }
            }
        }
        return { allMatches: matchesArray, specialToCreate };
    }

    async function shiftAndRefill() { const shiftPromises = []; for (let c = 0; c < CONFIG.GRID_SIZE; c++) { let emptySlots = 0; for (let r = CONFIG.GRID_SIZE - 1; r >= 0; r--) { if (board[r][c] === null) { emptySlots++; } else if (emptySlots > 0) { const gem = board[r][c]; board[r + emptySlots][c] = gem; board[r][c] = null; gem.row += emptySlots; shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300, easing.easeOutQuad)); } } } await Promise.all(shiftPromises); const refillPromises = []; for (let c = 0; c < CONFIG.GRID_SIZE; c++) { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { if (board[r][c] === null) { const newGem = { colorIndex: Math.floor(Math.random() * CONFIG.GEM_COLORS.length), isHeart: false, isLocked: false, special: SPECIAL_TYPES.NONE, row: r, col: c, x: c * gemSize, y: (r - CONFIG.GRID_SIZE) * gemSize, scale: 1, alpha: 1, }; if (gameMode !== 'balance' && currentLevel >= 1 && isFreePlayMode && Math.random() < 0.05 * Math.min(currentLevel, 4)) { newGem.isLocked = true; } board[r][c] = newGem; refillPromises.push(animate(newGem, { y: r * gemSize }, CONFIG.ANIM_FALL_SPEED, easing.easeOutQuad)); } } } await Promise.all(refillPromises); }
    async function reshuffleBoard() { isAnimating = true; const promises = []; board.flat().forEach(gem => { if (gem) { promises.push(animate(gem, { alpha: 0, scale: 0 }, 300)); } }); await Promise.all(promises); let attempts = 0; do { createBoard(); attempts++; if (attempts > 100) { console.error("Could not generate a board with possible moves."); break; } } while (!hasPossibleMoves(board)); const refillPromises = []; board.flat().forEach(gem => { if (gem) { gem.alpha = 0; gem.scale = 0; refillPromises.push(animate(gem, { alpha: 1, scale: 1 }, 300)); } }); await Promise.all(refillPromises); isAnimating = false; resetHintTimer(); }
    
    function checkWinCondition() {
        const objectivesMet = quest.totalDamage >= quest.maxDamage && quest.heartsSaved >= quest.heartsToSave;
        if (objectivesMet) {
            if (isFreePlayMode) {
                goToNextLevel(true);
            } else {
                isAnimating = true;
                isPaused = true;
                if (threatInterval) clearInterval(threatInterval);

                // Save progress
                if (currentDifficulty === 'easy' && currentLevel === 1) {
                    localStorage.setItem('kimcuong_easy_completed', 'true');
                }
                if (currentDifficulty === 'hard' && currentLevel === 3) {
                    localStorage.setItem('kimcuong_hard_completed', 'true');
                }

                if (currentLevel >= CONFIG.FINAL_LEVEL) {
                    showModal(DOMElements.finalWinModal, DOMElements.restartGameButton);
                } else {
                    DOMElements.winLevelText.textContent = `Bạn đã hoàn thành màn ${currentLevel}!`;
                    showModal(DOMElements.winModal, DOMElements.nextLevelButton);
                }
            }
        }
    }
    
    function handlePointerStart(e) {
        e.preventDefault();
        if (isPausedForFact) {
            isPaused = false;
            isPausedForFact = false;
            resetHintTimer();
        }
        if (isAnimating || isPaused) return;
        resetHintTimer();
        hintGems = [];
        const pos = getEventPos(e);
        const col = Math.floor(pos.x / gemSize);
        const row = Math.floor(pos.y / gemSize);
        if (row < 0 || row >= CONFIG.GRID_SIZE || col < 0 || col >= CONFIG.GRID_SIZE) {
            selectedGem = null;
            return;
        }
        const clickedGem = board[row][col];
        if (clickedGem.isLocked) {
            AudioManager.playSfx('unlock');
            return;
        }
        isDragging = true;
        startDragPos = pos;
        startGem = clickedGem;
        if (selectedGem) {
            if (selectedGem === clickedGem) {
                selectedGem = null;
                return;
            }
            const isAdjacent = Math.abs(selectedGem.row - clickedGem.row) + Math.abs(selectedGem.col - clickedGem.col) === 1;
            if (isAdjacent) {
                processSwap(selectedGem, clickedGem);
            } else {
                AudioManager.playSfx('select');
                selectedGem = clickedGem;
            }
        } else {
            AudioManager.playSfx('select');
            selectedGem = clickedGem;
        }
    }
    
    function handlePointerMove(e) { e.preventDefault(); if (!isDragging || isAnimating || isPaused) return; const pos = getEventPos(e); const deltaX = pos.x - startDragPos.x; const deltaY = pos.y - startDragPos.y; if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) { let endGem = null; if (Math.abs(deltaX) > Math.abs(deltaY)) { const endCol = startGem.col + (deltaX > 0 ? 1 : -1); if (endCol >= 0 && endCol < CONFIG.GRID_SIZE) { endGem = board[startGem.row][endCol]; } } else { const endRow = startGem.row + (deltaY > 0 ? 1 : -1); if (endRow >= 0 && endRow < CONFIG.GRID_SIZE) { endGem = board[endRow][startGem.col]; } } if (endGem && !endGem.isLocked && startGem !== endGem) { isDragging = false; selectedGem = null; processSwap(startGem, endGem); } } }
    function handlePointerEnd(e) { isDragging = false; startGem = null; }
    const easing = { easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t, easeInQuad: t => t * t, easeOutQuad: t => t * (2 - t) }; function animate(target, toProperties, duration, easeFunc = easing.easeInOutQuad) { return new Promise(resolve => { const startProps = {}; const endProps = {}; for (const key in toProperties) { const cur = typeof target[key] === 'number' && !isNaN(target[key]) ? target[key] : 0; startProps[key] = cur; endProps[key] = Number(toProperties[key]); } animations.push({ target, startProperties: startProps, endProperties: endProps, duration, easeFunc, startTime: performance.now(), onComplete: resolve }); }); }
    function handleAnimations(time) { const now = performance.now(); for (let i = animations.length - 1; i >= 0; i--) { const anim = animations[i]; const elapsed = now - (anim.startTime || now); const duration = Number(anim.duration) || 0; const t = duration > 0 ? Math.min(elapsed / duration, 1) : 1; const progress = (typeof anim.easeFunc === 'function') ? anim.easeFunc(t) : t; if (t >= 1) { for (const key in anim.endProperties) { if (anim.target) anim.target[key] = anim.endProperties[key]; } try { if (anim.onComplete) anim.onComplete(); } catch (err) { console.error('Error in animation onComplete:', err); } animations.splice(i, 1); } else { for (const key in anim.endProperties) { if (anim.target) { const start = anim.startProperties[key] || 0; const end = anim.endProperties[key]; anim.target[key] = start + (end - start) * progress; } } } } }
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    function toggleFullScreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`); }); } else { if (document.exitFullscreen) { document.exitFullscreen(); } } }
    function updateFullscreenIcons() { const fullscreenIconOpen = document.getElementById('fullscreen-icon-open'); const fullscreenIconClose = document.getElementById('fullscreen-icon-close'); if (document.fullscreenElement) { fullscreenIconOpen.classList.add('hidden'); fullscreenIconClose.classList.remove('hidden'); } else { fullscreenIconOpen.classList.remove('hidden'); fullscreenIconClose.classList.add('hidden'); } }
    
    function trackPupil(pupilElement, e) {
        if (!DOMElements || !DOMElements.characterContainerEl) return;
        const svgRect = DOMElements.characterContainerEl.getBoundingClientRect();
        if (!svgRect || svgRect.width === 0) return;

        const pupilData = { 
            cx: parseFloat(pupilElement.getAttribute('cx')), 
            cy: parseFloat(pupilElement.getAttribute('cy')) 
        }; 
        const pupilX = svgRect.left + (pupilData.cx / 200) * svgRect.width; 
        const pupilY = svgRect.top + (pupilData.cy / 100) * svgRect.height; 
        const angle = Math.atan2(e.clientY - pupilY, e.clientX - pupilX); 
        const maxMove = 4; 
        const moveX = Math.cos(angle) * maxMove; 
        const moveY = Math.sin(angle) * maxMove; 
        pupilElement.setAttribute('transform', `translate(${moveX} ${moveY})`);
    }

    function getParticle() { for (let i = 0; i < particlePool.length; i++) { if (!particlePool[i].active) return particlePool[i]; } return null; }
    function createParticleBurst(x, y, color) { for (let i = 0; i < 10; i++) { const p = getParticle(); if (p) { p.active = true; p.x = x; p.y = y; p.vx = (Math.random() - 0.5) * 6; p.vy = (Math.random() - 0.5) * 6; p.size = Math.random() * 4 + 2; p.color = color; p.alpha = 1; } } }
    function setupLevel(level) { currentLevel = level; DOMElements.levelEl.textContent = level; const baseRequirement = 15 + (level - 1) * 8; const numTargets = Math.min(2 + Math.floor(level / 2), 5); quest = { targets: {}, collected: {}, totalDamage: 0, maxDamage: 0, heartsToSave: level, heartsSaved: 0 }; let availableColors = Array.from({ length: CONFIG.GEM_COLORS.length }, (_, i) => i); for (let i = 0; i < numTargets; i++) { if (availableColors.length === 0) break; const colorIndex = availableColors.splice(Math.floor(Math.random() * availableColors.length), 1)[0]; const requirement = Math.floor(baseRequirement * (Math.random() * 0.4 + 0.8)); quest.targets[colorIndex] = requirement; quest.collected[colorIndex] = 0; quest.maxDamage += requirement; } updateQuestUI(); updateHealthBar(); }
    async function resizeCanvas() { 
        const container = DOMElements.canvas.parentElement;
        if (!container) return;
        const containerWidth = container.clientWidth;
        const dpr = window.devicePixelRatio || 1; 
        DOMElements.canvas.style.width = containerWidth + 'px'; 
        DOMElements.canvas.style.height = containerWidth + 'px'; 
        DOMElements.canvas.width = Math.floor(containerWidth * dpr); 
        DOMElements.canvas.height = Math.floor(containerWidth * dpr); 
        DOMElements.ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
        gemSize = containerWidth / CONFIG.GRID_SIZE; 
        await preRenderGems(); 
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if(board[r] && board[r][c]) { board[r][c].x = c * gemSize; board[r][c].y = r * gemSize; } } } 
        if (gameMode !== 'balance') updateCigarettePosition(); 
    }
    function onResizeDebounced() { if (resizeTimer) clearTimeout(resizeTimer); resizeTimer = setTimeout(() => { resizeCanvas(); }, 150); }
    function updateCigarettePosition(col = cigarette.col, isLunging = false) { const columnCenter = (col * gemSize) + (gemSize / 2); const svgScaledWidth = 200 * 0.7; const translateX = columnCenter - (svgScaledWidth / 2); let scale = 0.7; let rotate = 0; let translateY = 0; if (isLunging) { scale = 0.8; translateY = 10; } else if (DOMElements.characterContainerEl.classList.contains('attacking')) { scale = 0.8; rotate = -5; } DOMElements.characterContainerEl.style.transform = `translateX(${translateX}px) translateY(${translateY}px) scale(${scale}) rotate(${rotate}deg)`; }
    function createBoard() { board = []; for (let row = 0; row < CONFIG.GRID_SIZE; row++) { board[row] = []; for (let col = 0; col < CONFIG.GRID_SIZE; col++) { let possibleColors = Array.from({ length: CONFIG.GEM_COLORS.length }, (_, i) => i); if (col >= 2 && board[row][col-1].colorIndex === board[row][col-2].colorIndex) { const colorToRemove = board[row][col-1].colorIndex; possibleColors = possibleColors.filter(c => c !== colorToRemove); } if (row >= 2 && board[row-1][col].colorIndex === board[row-2][col].colorIndex) { const colorToRemove = board[row-1][col].colorIndex; possibleColors = possibleColors.filter(c => c !== colorToRemove); } const colorIndex = possibleColors[Math.floor(Math.random() * possibleColors.length)]; board[row][col] = { colorIndex: colorIndex, isHeart: false, isLocked: false, special: SPECIAL_TYPES.NONE, row: row, col: col, x: col * gemSize, y: row * gemSize, scale: 1, alpha: 1, }; } } }
    function swapGems(gem1, gem2) { const r1 = gem1.row, c1 = gem1.col; const r2 = gem2.row, c2 = gem2.col; board[r1][c1] = gem2; board[r2][c2] = gem1; gem1.row = r2; gem1.col = c2; gem2.row = r1; gem2.col = c1; const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad); const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad); return Promise.all([p1, p2]); }
    function getSpecialEffectGems(gem) { let affected = new Set(); if (gem.special === SPECIAL_TYPES.H_BEAM) { for(let c=0; c<CONFIG.GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); } } else if (gem.special === SPECIAL_TYPES.V_BEAM) { for(let r=0; r<CONFIG.GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); } } else if (gem.special === SPECIAL_TYPES.BOMB) { for(let r = gem.row - 1; r <= gem.row + 1; r++) { for(let c = gem.col - 1; c <= gem.col + 1; c++) { if(r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) { affected.add(board[r][c]); } } } } return affected; }
    async function triggerHypercube(hypercube, otherGem) {
        AudioManager.playSfx('hypercube');
        let gemsToClear = new Set([hypercube, otherGem]);

        // Hypercube + Hypercube: Clear the whole board
        if (otherGem.special === SPECIAL_TYPES.HYPERCUBE) {
            board.flat().forEach(g => { if (g) gemsToClear.add(g); });
        }
        // Hypercube + Special (Bomb or Beam)
        else if (otherGem.special !== SPECIAL_TYPES.NONE) {
            const specialTypeToCreate = otherGem.special;
            const targetColorIndex = otherGem.colorIndex;
            const transformationPromises = [];

            board.flat().forEach(g => {
                if (g && g.colorIndex === targetColorIndex) {
                    g.special = specialTypeToCreate;
                    // Add a small visual pulse to indicate transformation
                    transformationPromises.push(animate(g, { scale: 1.2 }, 100).then(() => animate(g, { scale: 1 }, 100)));
                    gemsToClear.add(g); // These will be activated in the cascade
                }
            });
            await Promise.all(transformationPromises);
        }
        // Hypercube + Normal Gem
        else {
            const targetColorIndex = otherGem.colorIndex;
            board.flat().forEach(g => {
                if (g && g.colorIndex === targetColorIndex) {
                    gemsToClear.add(g);
                }
            });
        }

        await cascadeMatches(Array.from(gemsToClear));
    }
    function spawnHeartIfNeeded(isFirst = false) { if (isFirst || (moves > 0 && moves % CONFIG.MOVES_PER_HEART_SPAWN === 0)) { let availableCols = []; for (let c = 0; c < CONFIG.GRID_SIZE; c++) { const gem = board[CONFIG.GRID_SIZE - 1][c]; const gemAbove = board[CONFIG.GRID_SIZE - 2] ? board[CONFIG.GRID_SIZE - 2][c] : null; const canSpawn = gem && !gem.isHeart && gem.special === SPECIAL_TYPES.NONE; const isNotBlockedByLock = !gemAbove || !gemAbove.isLocked; if (canSpawn && isNotBlockedByLock) { availableCols.push(c); } } if (availableCols.length > 0) { const col = availableCols[Math.floor(Math.random() * availableCols.length)]; const gem = board[CONFIG.GRID_SIZE - 1][col]; gem.isHeart = true; gem.special = SPECIAL_TYPES.NONE; animate(gem, {scale: 1.5}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad) .then(() => animate(gem, {scale: 1}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad)); } } }
    async function moveHearts() { const movePromises = []; let movedGems = new Set(); let heartsDidMove = false; for (let r = 1; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { const gem = board[r][c]; if (gem && gem.isHeart && !movedGems.has(gem)) { const gemAbove = board[r - 1][c]; if (gemAbove && !gemAbove.isHeart) { heartsDidMove = true; board[r - 1][c] = gem; board[r][c] = gemAbove; gem.row = r - 1; gemAbove.row = r; movePromises.push(animate(gem, { y: gem.row * gemSize }, 200, easing.easeInOutQuad)); movePromises.push(animate(gemAbove, { y: gemAbove.row * gemSize }, 200, easing.easeInOutQuad)); movedGems.add(gem); movedGems.add(gemAbove); } } } } await Promise.all(movePromises); return heartsDidMove; }
    async function moveCigarette() { let highestHeart = null; let minRow = CONFIG.GRID_SIZE; board.flat().filter(g => g && g.isHeart).forEach(g => { if (g.row < minRow) { minRow = g.row; highestHeart = g; } }); if (highestHeart) { if (Math.random() < CONFIG.CIGARETTE_LUNGE_CHANCE) { const originalCol = cigarette.col; const targetCol = highestHeart.col; updateCigarettePosition(targetCol, true); await sleep(150); updateCigarettePosition(originalCol); await sleep(400); } if (cigarette.col < highestHeart.col) cigarette.col++; else if (cigarette.col > highestHeart.col) cigarette.col--; } updateCigarettePosition(); }
    function checkGameOver() { if(gameMode !== 'balance' && board[0][cigarette.col] && board[0][cigarette.col].isHeart) { showGameOver("Thuốc lá đã làm hại một trái tim."); return true; } return false; }
    function updateQuestProgress(collected) { for (const key in collected) { const colorIdx = parseInt(key, 10); const amount = collected[key]; if (!quest.targets.hasOwnProperty(colorIdx)) continue; const before = quest.collected[colorIdx] || 0; const remaining = Math.max(0, quest.targets[colorIdx] - before); const used = Math.min(remaining, amount); quest.collected[colorIdx] += used; quest.totalDamage += used; } updateHealthBar(); updateQuestUI(); }
    function goToNextLevel(isFreeModeLevelUp = false) {
        if (!isFreeModeLevelUp) {
            hideModal(DOMElements.winModal);
        } else {
            // Cập nhật và lưu điểm cao cho chế độ Tự do
            const highscore = parseInt(localStorage.getItem('kimcuong_free_highscore') || '1');
            if (currentLevel + 1 > highscore) {
                localStorage.setItem('kimcuong_free_highscore', currentLevel + 1);
                DOMElements.freeModeHighscoreEl.textContent = `Kỷ lục: Cấp ${currentLevel + 1}`;
            }
        }
        isAnimating = false;
        isPaused = false;
        setupLevel(currentLevel + 1);
        moves = 0;
        updateMoves(); do { createBoard(); } while(!hasPossibleMoves(board)); spawnHeartIfNeeded(true); if (threatInterval) clearInterval(threatInterval); threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL); }
    function hasPossibleMoves(currentBoard) { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (c < CONFIG.GRID_SIZE - 1) { const gem1 = currentBoard[r][c]; const gem2 = currentBoard[r][c+1]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [currentBoard[r][c], currentBoard[r][c+1]] = [gem2, gem1]; const matches = findMatches(currentBoard); [currentBoard[r][c], currentBoard[r][c+1]] = [gem1, gem2]; if (matches.length > 0) return true; } if (r < CONFIG.GRID_SIZE - 1) { const gem1 = currentBoard[r][c]; const gem2 = currentBoard[r+1][c]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [currentBoard[r][c], currentBoard[r+1][c]] = [gem2, gem1]; const matches = findMatches(currentBoard); [currentBoard[r][c], currentBoard[r+1][c]] = [gem1, gem2]; if (matches.length > 0) return true; } } } return false; }
    function findFirstPossibleMove() { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (c < CONFIG.GRID_SIZE - 1) { const gem1 = board[r][c]; const gem2 = board[r][c+1]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [board[r][c], board[r][c+1]] = [gem2, gem1]; const matches = findMatches(board); [board[r][c], board[r][c+1]] = [gem1, gem2]; if (matches.length > 0) return { gem1, gem2 }; } if (r < CONFIG.GRID_SIZE - 1) { const gem1 = board[r][c]; const gem2 = board[r+1][c]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [board[r][c], board[r+1][c]] = [gem2, gem1]; const matches = findMatches(board); [board[r][c], board[r+1][c]] = [gem1, gem2]; if (matches.length > 0) return { gem1, gem2 }; } } } return null; }
    function resetHintTimer() { if (hintTimeout) clearTimeout(hintTimeout); hintGems = []; hintTimeout = setTimeout(() => { if (!isAnimating && !isPaused) { const move = findFirstPossibleMove(); if (move) { hintGems = [move.gem1, move.gem2]; } } }, CONFIG.HINT_TIMEOUT); }
    function getEventPos(e) { const rect = DOMElements.canvas.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
    async function init() { await resizeCanvas(); DOMElements.ctx.font = `${gemSize * 0.7}px sans-serif`; cigarette.col = Math.floor(CONFIG.GRID_SIZE / 2); score = 0; moves = 0; setupLevel(1); do { createBoard(); } while (!hasPossibleMoves(board)); spawnHeartIfNeeded(true); updateCigarettePosition(); selectedGem = null; isAnimating = false; isPaused = false; animations = []; particlePool = []; for (let i = 0; i < CONFIG.MAX_PARTICLES; i++) { particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', alpha: 0 }); } factsShown = []; if (threatInterval) clearInterval(threatInterval); threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL); updateScore(); updateMoves(); updateQuestUI(); updateHealthBar(); DOMElements.levelEl.textContent = currentLevel; requestAnimationFrame(gameLoop); resetHintTimer(); }
    
    function startInfoPanelAnimation() {
        if (infoPanelInterval) clearInterval(infoPanelInterval);

        const facts = Array.from(DOMElements.factsList.children);
        const skills = Array.from(DOMElements.skillsList.children);
        let currentFactIndex = 0;
        let currentSkillIndex = 0;

        // Hide all initially
        facts.forEach(fact => fact.classList.remove('visible'));
        skills.forEach(skill => skill.classList.remove('visible'));

        const cycleInfo = () => {
            facts.forEach((fact, index) => {
                fact.classList.toggle('visible', index === currentFactIndex);
            });
            skills.forEach((skill, index) => {
                skill.classList.toggle('visible', index === currentSkillIndex);
            });

            currentFactIndex = (currentFactIndex + 1) % facts.length;
            currentSkillIndex = (currentSkillIndex + 1) % skills.length;
        };

        cycleInfo(); // Show the first items immediately
        infoPanelInterval = setInterval(cycleInfo, CONFIG.BALANCE_MODE.INFO_PANEL_INTERVAL);
    }
    
    async function initBalanceMode() {
        await resizeCanvas();
        DOMElements.ctx.font = `${gemSize * 0.7}px sans-serif`;
        createBoard();
        while (!hasPossibleMoves(board)) { createBoard(); }
        
        selectedGem = null; isAnimating = false; isPaused = false; animations = [];
        particlePool = []; for (let i = 0; i < CONFIG.MAX_PARTICLES; i++) { particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', alpha: 0 }); }
        
        setupBalanceLevel(1);
        startInfoPanelAnimation();
        
        requestAnimationFrame(gameLoop);
        resetHintTimer();
    }

    function setupBalanceLevel(level) {
        currentBalanceLevel = level;
        balanceTimeLeft = 60 + (level - 1) * 30;
        studyValue = 30; // Bắt đầu ở mức thấp hơn để có không gian tăng
        playValue = 30;
        balanceMovesMade = 0;
        
        DOMElements.balanceLevelEl.textContent = level;
        DOMElements.balanceTimerEl.textContent = balanceTimeLeft;
        updateBalanceBars();
        
        if (balanceTimerInterval) clearInterval(balanceTimerInterval);
        balanceTimerInterval = setInterval(tickBalanceTimer, 1000);
        
        if (passiveIncreaseInterval) clearInterval(passiveIncreaseInterval);
        passiveIncreaseInterval = setInterval(triggerPassiveIncrease, CONFIG.BALANCE_MODE.PASSIVE_INCREASE_INTERVAL); 
    }
    
    function tickBalanceTimer() {
        if(isPaused) return;
        balanceTimeLeft--;
        DOMElements.balanceTimerEl.textContent = balanceTimeLeft;

        if (balanceTimeLeft <= 0) {
            if(balanceMovesMade > 0) {
                handleBalanceWin();
            } else {
                showGameOver("Hết giờ! Bạn chưa thực hiện nước đi nào.");
            }
        }
    }

    function triggerPassiveIncrease() {
        if (isPaused || isAnimating || currentModal) return;

        const increaseAmount = Math.random() * 10 + 5; // Tăng ngẫu nhiên từ 5% đến 15%
        let tubeToFlash;

        if (Math.random() < 0.5) {
            // Tăng thanh Học Tập
            studyValue += increaseAmount;
            tubeToFlash = DOMElements.studyLiquid.closest('.balance-tube');
        } else {
            // Tăng thanh Giải Trí
            playValue += increaseAmount;
            tubeToFlash = DOMElements.playLiquid.closest('.balance-tube');
        }

        // Thêm hiệu ứng flash cho ống nghiệm được chọn
        if(tubeToFlash) {
            tubeToFlash.classList.add('flash-warning-effect');
            setTimeout(() => {
                tubeToFlash.classList.remove('flash-warning-effect');
            }, 600);
        }
        
        updateBalanceBars();
    }

    function updateBalanceBars() {
        studyValue = Math.min(100, Math.max(0, studyValue));
        playValue = Math.min(100, Math.max(0, playValue));
        
        DOMElements.studyLiquid.style.height = `${studyValue}%`;
        DOMElements.playLiquid.style.height = `${playValue}%`;
        DOMElements.studyPercentage.textContent = `${Math.round(studyValue)}%`;
        DOMElements.playPercentage.textContent = `${Math.round(playValue)}%`;

        // Điều chỉnh tốc độ và độ sáng của plasma dựa trên %
        // Càng cao, xung nhịp càng nhanh
        const studyPulseDuration = Math.max(0.5, 3 - (studyValue / 100) * 2.5);
        const playPulseDuration = Math.max(0.5, 3 - (playValue / 100) * 2.5);
        DOMElements.studyLiquid.style.animationDuration = `${studyPulseDuration}s`;
        DOMElements.playLiquid.style.animationDuration = `${playPulseDuration}s`;


        // Update Chain Tilt
        const difference = playValue - studyValue; // Đã sửa: (phải - trái) để nghiêng đúng hướng
        const tiltPercentage = difference / 100; // -1 to 1
        const tiltAngle = tiltPercentage * CONFIG.BALANCE_MODE.MAX_TILT_ANGLE;
        DOMElements.balanceScaleContainer.style.transform = `rotate(${tiltAngle}deg)`;

        // Update Danger Icons & Animations
        const studyWrapper = DOMElements.studyLiquid.closest('.balance-tube-wrapper');
        const playWrapper = DOMElements.playLiquid.closest('.balance-tube-wrapper');
        
        DOMElements.studyDangerIcon.classList.toggle('visible', studyValue > CONFIG.BALANCE_MODE.WARNING_THRESHOLD);
        studyWrapper.classList.toggle('warning-study', studyValue > CONFIG.BALANCE_MODE.WARNING_THRESHOLD);

        DOMElements.playDangerIcon.classList.toggle('visible', playValue > CONFIG.BALANCE_MODE.WARNING_THRESHOLD);
        playWrapper.classList.toggle('warning-play', playValue > CONFIG.BALANCE_MODE.WARNING_THRESHOLD);

        // Logic thua mới
        if (studyValue >= 100) {
            showGameOver("Học tập quá tải! Cần giải trí ngay!");
        } else if (playValue >= 100) {
            showGameOver("Giải trí quá đà! Cần tập trung học lại!");
        } else if (studyValue <= 0 && balanceMovesMade > 0) { // Thêm `balanceMovesMade > 0` để không bị thua ngay từ đầu
            showGameOver("Bỏ bê học tập! Mất cân bằng rồi!");
        } else if (playValue <= 0 && balanceMovesMade > 0) {
            showGameOver("Không còn niềm vui! Cuộc sống quá áp lực!");
        }
    }

    function handleBalanceWin() {
        clearInterval(balanceTimerInterval);
        clearInterval(passiveIncreaseInterval);
        if (infoPanelInterval) clearInterval(infoPanelInterval);
        isPaused = true;
        DOMElements.winLevelText.textContent = `Tuyệt vời! Cân bằng học tập và vui chơi giúp bạn khỏe mạnh, không cần thuốc lá.`;
        showModal(DOMElements.winModal, DOMElements.nextLevelButton);
        
        const nextLevelHandler = () => {
            hideModal(DOMElements.winModal);
            isPaused = false;
            setupBalanceLevel(currentBalanceLevel + 1);
            reshuffleBoard();
        };
        
        const nextLevelButton = DOMElements.nextLevelButton;
        const newNextLevelButton = nextLevelButton.cloneNode(true);
        nextLevelButton.parentNode.replaceChild(newNextLevelButton, nextLevelButton);
        DOMElements.nextLevelButton = newNextLevelButton;
        
        newNextLevelButton.addEventListener('click', nextLevelHandler, { once: true });
    }

    function gameLoop(time) { requestAnimationFrame(gameLoop); handleAnimations(time); const { ctx, canvas } = DOMElements; ctx.clearRect(0, 0, canvas.width, canvas.height); drawBoard(time); drawParticles(); drawSelection(time); drawHint(time); if (isPaused) { return; } }
    
    function returnToMenu() {
        [DOMElements.winModal, DOMElements.gameOverModal, DOMElements.finalWinModal, DOMElements.factModal, DOMElements.tutorialModal].forEach(modal => {
            if (modal && !modal.classList.contains('hidden')) {
                hideModal(modal);
            }
        });

        // Chuyển canvas trở lại màn hình game chính
        if (DOMElements.canvas.parentElement !== DOMElements.gameContainer) {
            DOMElements.gameContainer.appendChild(DOMElements.canvas);
        }

        isPaused = true;
        if (threatInterval) clearInterval(threatInterval);
        if (hintTimeout) clearTimeout(hintTimeout);
        if (balanceTimerInterval) clearInterval(balanceTimerInterval);
        if (passiveIncreaseInterval) clearInterval(passiveIncreaseInterval);
        if (infoPanelInterval) clearInterval(infoPanelInterval);

        DOMElements.startScreen.style.display = 'flex';
        DOMElements.gameUI.classList.add('hidden');
        DOMElements.gameUI.classList.remove('flex');
        DOMElements.balanceModeScreen.classList.add('hidden');
        DOMElements.balanceModeScreen.classList.remove('flex');
        DOMElements.backToMenuBtn.classList.add('hidden');
        updateButtonLocks(); // Cập nhật lại khóa khi về menu
    }

    function updateButtonLocks() {
        const easyCompleted = localStorage.getItem('kimcuong_easy_completed') === 'true';
        const hardCompleted = localStorage.getItem('kimcuong_hard_completed') === 'true';

        // Khóa chế độ Khó
        if (easyCompleted) {
            DOMElements.hardModeBtn.classList.remove('locked-button');
            DOMElements.hardLockIcon.classList.add('hidden');
        } else {
            DOMElements.hardModeBtn.classList.add('locked-button');
            DOMElements.hardLockIcon.classList.remove('hidden');
        }

        // Khóa chế độ Tự do & Cân bằng
        if (hardCompleted) {
            DOMElements.freeModeBtn.classList.remove('locked-button');
            DOMElements.freeLockIcon.classList.add('hidden');
            DOMElements.balanceModeBtn.classList.remove('locked-button');
            DOMElements.balanceLockIcon.classList.add('hidden');
        } else {
            DOMElements.freeModeBtn.classList.add('locked-button');
            DOMElements.freeLockIcon.classList.remove('hidden');
            DOMElements.balanceModeBtn.classList.add('locked-button');
            DOMElements.balanceLockIcon.classList.remove('hidden');
        }
    }

    // --- MODULE: EVENT LISTENERS & INITIALIZATION ---
    window.addEventListener('DOMContentLoaded', () => {
        DOMElements = {
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            scoreEl: document.getElementById('score'),
            levelEl: document.getElementById('level'),
            movesEl: document.getElementById('moves'),
            winModal: document.getElementById('winModal'),
            nextLevelButton: document.getElementById('nextLevelButton'),
            winLevelText: document.getElementById('win-level-text'),
            gameOverModal: document.getElementById('gameOverModal'),
            gameOverReason: document.getElementById('gameOverReason'),
            gameOverMessageContainer: document.getElementById('gameOverMessageContainer'),
            factModal: document.getElementById('factModal'),
            factText: document.getElementById('factText'),
            adviceText: document.getElementById('adviceText'),
            closeFactButton: document.getElementById('closeFactButton'),
            healthBar: document.getElementById('health-bar'),
            questList: document.getElementById('quest-list'),
            startScreen: document.getElementById('start-screen'),
            gameUI: document.getElementById('game-ui'),
            customCursor: document.getElementById('custom-cursor'),
            tutorialModal: document.getElementById('tutorial-modal'),
            tutorialSteps: document.querySelectorAll('.tutorial-step'),
            tutorialNextBtns: document.querySelectorAll('.tutorial-next-btn'),
            tutorialFinishBtn: document.getElementById('tutorial-finish-btn'),
            balanceTutorialFinishBtn: document.getElementById('balance-tutorial-finish-btn'),
            finalWinModal: document.getElementById('finalWinModal'),
            restartGameButton: document.getElementById('restartGameButton'),
            easyModeBtn: document.getElementById('easy-mode-btn'),
            hardModeBtn: document.getElementById('hard-mode-btn'),
            freeModeBtn: document.getElementById('free-mode-btn'),
            balanceModeBtn: document.getElementById('balance-mode-btn'),
            hardLockIcon: document.getElementById('hard-lock-icon'),
            freeLockIcon: document.getElementById('free-lock-icon'),
            balanceLockIcon: document.getElementById('balance-lock-icon'),
            freeModeHighscoreEl: document.getElementById('free-mode-highscore'),
            backToMenuBtn: document.getElementById('back-to-menu-btn'),
            tutorialStartBtn: document.getElementById('tutorial-start-btn'),
            characterContainerEl: document.getElementById('character-container'),
            threatBubble: document.getElementById('threat-bubble'),
            threatText: document.getElementById('threat-text'),
            mouth: document.getElementById('mouth-path'),
            pupil1: document.getElementById('pupil1'),
            pupil2: document.getElementById('pupil2'),
            copyrightYear: document.getElementById('year'),
            
            // UI cho chế độ Cân Bằng
            balanceModeScreen: document.getElementById('balance-mode-screen'),
            balanceGameBoard: document.getElementById('balance-game-board'),
            balanceScaleContainer: document.getElementById('balance-scale-container'),
            studyLiquid: document.getElementById('study-liquid'),
            playLiquid: document.getElementById('play-liquid'),
            studyPercentage: document.getElementById('study-percentage'),
            playPercentage: document.getElementById('play-percentage'),
            studyDangerIcon: document.getElementById('study-danger-icon'),
            playDangerIcon: document.getElementById('play-danger-icon'),
            balanceLevelEl: document.getElementById('balance-level'),
            balanceTimerEl: document.getElementById('balance-timer'),
            factsList: document.getElementById('facts-list'),
            skillsList: document.getElementById('skills-list'),
            
            // Các thành phần cần ẩn/hiện
            objectivePanel: document.getElementById('objective-panel'),
            storyModeStats: document.getElementById('story-mode-stats'),
            gameContainer: document.getElementById('game-container'),

        };

        const originalNextLevelHandler = () => goToNextLevel(false);

        function attachCanvasListeners() {
            const { canvas } = DOMElements; 
            if (!canvas.dataset.listenersAdded) { 
                const eventOptions = { passive: false };
                canvas.addEventListener('pointerdown', handlePointerStart, eventOptions); 
                canvas.addEventListener('pointermove', handlePointerMove, eventOptions); 
                canvas.addEventListener('pointerup', handlePointerEnd, eventOptions); 
                canvas.addEventListener('pointercancel', handlePointerEnd, eventOptions); 
                
                canvas.addEventListener('touchstart', handlePointerStart, eventOptions);
                canvas.addEventListener('touchmove', handlePointerMove, eventOptions);
                canvas.addEventListener('touchend', handlePointerEnd, eventOptions);
                canvas.addEventListener('touchcancel', handlePointerEnd, eventOptions);
                
                window.addEventListener('resize', onResizeDebounced); 
                canvas.dataset.listenersAdded = '1'; 
            } 
        }

        DOMElements.copyrightYear.textContent = new Date().getFullYear();
        let currentTutorialStep = 0;
        let firstInteraction = true;
        async function handleFirstInteraction() { if (firstInteraction) { firstInteraction = false; await AudioManager.init(); AudioManager.startMusic(); } }
        function showTutorialStep(index, maxSteps = 4) { // Add maxSteps to limit the regular tutorial
            DOMElements.tutorialSteps.forEach((step, i) => { 
                step.classList.toggle('hidden', i !== index); 
            }); 
            if (index === maxSteps - 1) { 
                if (isTutorialOnly) { DOMElements.tutorialFinishBtn.textContent = 'Quay Lại'; DOMElements.tutorialFinishBtn.classList.replace('bg-green-600', 'bg-blue-600'); } 
                else { DOMElements.tutorialFinishBtn.textContent = 'Bắt đầu chơi!'; DOMElements.tutorialFinishBtn.classList.replace('bg-blue-600', 'bg-green-600'); } 
            } 
        }
        
        function startGame(finalLevel, isFree = false, difficulty = 'easy') {
            gameMode = isFree ? 'free' : 'story';
            currentDifficulty = difficulty;
            isTutorialOnly = false;
            CONFIG.FINAL_LEVEL = finalLevel;
            isFreePlayMode = isFree;
            
            // --- QUẢN LÝ BỐ CỤC ---
            if (DOMElements.canvas.parentElement !== DOMElements.gameContainer) {
                DOMElements.gameContainer.appendChild(DOMElements.canvas);
            }

            DOMElements.startScreen.style.display = 'none';
            DOMElements.balanceModeScreen.classList.add('hidden');
            DOMElements.balanceModeScreen.classList.remove('flex', 'md:flex-row', 'flex-col');

            DOMElements.gameUI.classList.remove('hidden');
            DOMElements.gameUI.classList.add('flex');
            
            DOMElements.tutorialModal.classList.remove('hidden');
            showTutorialStep(0);
        }

        function showBalanceTutorial() {
            gameMode = 'balance';
            isTutorialOnly = false;
            isFreePlayMode = false;
            DOMElements.startScreen.style.display = 'none';
            DOMElements.tutorialSteps.forEach(step => step.classList.add('hidden'));
            const balanceStepIndex = Array.from(DOMElements.tutorialSteps).findIndex(step => step.id === 'tutorial-step-balance');
            if (balanceStepIndex !== -1) {
                DOMElements.tutorialSteps[balanceStepIndex].classList.remove('hidden');
            }
            DOMElements.tutorialModal.classList.remove('hidden');
        }

        function startBalanceMode() {
            // --- QUẢN LÝ BỐ CỤC ---
            DOMElements.balanceGameBoard.appendChild(DOMElements.canvas);

            DOMElements.startScreen.style.display = 'none';
            DOMElements.gameUI.classList.add('hidden');
            DOMElements.gameUI.classList.remove('flex');
            
            DOMElements.balanceModeScreen.classList.remove('hidden');
            DOMElements.balanceModeScreen.classList.add('flex', 'flex-col'); 
            
            DOMElements.backToMenuBtn.classList.remove('hidden');
            initBalanceMode();
            attachCanvasListeners();
        }

        DOMElements.easyModeBtn.addEventListener('click', () => { handleFirstInteraction(); startGame(1, false, 'easy'); });
        DOMElements.hardModeBtn.addEventListener('click', () => {
            if (DOMElements.hardModeBtn.classList.contains('locked-button')) return;
            handleFirstInteraction(); 
            startGame(3, false, 'hard'); 
        });
        DOMElements.freeModeBtn.addEventListener('click', () => { 
            if (DOMElements.freeModeBtn.classList.contains('locked-button')) return;
            handleFirstInteraction(); 
            startGame(Infinity, true, 'free'); 
        });
        DOMElements.balanceModeBtn.addEventListener('click', () => { 
            if (DOMElements.balanceModeBtn.classList.contains('locked-button')) return;
            handleFirstInteraction(); 
            showBalanceTutorial(); 
        });
        
        DOMElements.tutorialStartBtn.addEventListener('click', () => { handleFirstInteraction(); isTutorialOnly = true; DOMElements.startScreen.style.display = 'none'; DOMElements.tutorialModal.classList.remove('hidden'); showTutorialStep(0); });
        DOMElements.tutorialNextBtns.forEach(btn => btn.addEventListener('click', () => { currentTutorialStep++; if (currentTutorialStep < 4) showTutorialStep(currentTutorialStep); }));
        DOMElements.tutorialFinishBtn.addEventListener('click', async () => { 
            hideModal(DOMElements.tutorialModal); 
            currentTutorialStep = 0; 
            if (isTutorialOnly) { 
                DOMElements.startScreen.style.display = 'flex'; 
            } else if (gameMode === 'balance') {
                 // Không làm gì cả vì startBalanceMode đã init game
            }
            else { 
                DOMElements.backToMenuBtn.classList.remove('hidden'); 
                await init(); 
                attachCanvasListeners();
            } 
        });

        DOMElements.balanceTutorialFinishBtn.addEventListener('click', () => {
            hideModal(DOMElements.tutorialModal);
            startBalanceMode();
        });
        
        DOMElements.closeFactButton.addEventListener('click', () => {
            hideModal(DOMElements.factModal);
            isPaused = false;
            isPausedForFact = false;
            resetHintTimer();
        });
        
        DOMElements.nextLevelButton.addEventListener('click', originalNextLevelHandler);
        document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
        document.getElementById('backToIndexButton').addEventListener('click', returnToMenu);
        document.getElementById('gameOverHomeButton').addEventListener('click', returnToMenu);
        DOMElements.backToMenuBtn.addEventListener('click', returnToMenu);
        document.getElementById('gameOverRestartButton').addEventListener('click', () => {
             hideModal(DOMElements.gameOverModal);
             if (gameMode === 'balance') {
                initBalanceMode();
             } else {
                init();
             }
        });
        DOMElements.restartGameButton.addEventListener('click', () => {
            hideModal(DOMElements.finalWinModal);
            returnToMenu();
        });
        document.getElementById('continueToNextGameButton').addEventListener('click', () => window.location.href = 'kimcuongquatraloicauhoi.html');

        document.addEventListener('fullscreenchange', updateFullscreenIcons);
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && currentModal) { const closeButton = currentModal.querySelector('button'); if (closeButton) closeButton.click(); } });
        
        if (!window.matchMedia('(pointer: coarse)').matches) {
            document.body.style.cursor = 'none'; 
            if(DOMElements.customCursor) DOMElements.customCursor.style.display = 'block';
            if(DOMElements.canvas) DOMElements.canvas.style.cursor = 'none';
            
            let rafScheduled = false, lastMouseEvent = null;
            document.addEventListener('mousemove', (e) => {
                lastMouseEvent = e;
                if (!rafScheduled) { 
                    rafScheduled = true; 
                    requestAnimationFrame(() => { 
                        if (lastMouseEvent && DOMElements) { 
                            if (DOMElements.customCursor) {
                                DOMElements.customCursor.style.left = lastMouseEvent.clientX + 'px'; 
                                DOMElements.customCursor.style.top = lastMouseEvent.clientY + 'px'; 
                            }
                            if (DOMElements.startScreen && DOMElements.startScreen.style.display === 'none' && gameMode !== 'balance') { 
                                if (DOMElements.pupil1 && DOMElements.pupil2) {
                                    trackPupil(DOMElements.pupil1, lastMouseEvent); 
                                    trackPupil(DOMElements.pupil2, lastMouseEvent); 
                                }
                            } 
                        } 
                        rafScheduled = false; 
                    }); 
                }
            });
        }
        updateButtonLocks(); // Kiểm tra khóa ngay khi game tải xong
        // Tải và hiển thị điểm cao
        const highscore = parseInt(localStorage.getItem('kimcuong_free_highscore') || '0');
        if (highscore > 0) {
            DOMElements.freeModeHighscoreEl.textContent = `Kỷ lục: Cấp ${highscore}`;
        }
    });
    window.addEventListener('beforeunload', () => { if (threatInterval) clearInterval(threatInterval); if (hintTimeout) clearTimeout(hintTimeout); if(animationWatchdog) clearTimeout(animationWatchdog); });

})(); 
</script>
</body>
</html>

