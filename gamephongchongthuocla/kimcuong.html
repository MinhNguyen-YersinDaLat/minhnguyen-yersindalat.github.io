<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"/>
    <title>Game Kim C∆∞∆°ng: B·∫£o V·ªá Tr√°i Tim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: none;
            overflow: hidden;
            animation: vignette-pulse 8s infinite alternate ease-in-out;
            /* cursor is set by JS */
        }
        @keyframes vignette-pulse {
            from { background: radial-gradient(ellipse at center, #1a1111 50%, #000000 100%); }
            to { background: radial-gradient(ellipse at center, #110a0a 40%, #000000 100%); }
        }
        canvas {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            /* cursor is set by JS */
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        #character-container {
            position: absolute;
            top: -95px; /* ƒêi·ªÅu ch·ªânh v·ªã tr√≠ ƒë·ªÉ ph√π h·ª£p v·ªõi k√≠ch th∆∞·ªõc m·ªõi */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
            z-index: 20;
        }
        .character-aura {
            position: absolute;
            width: 250px;
            height: 150px;
            background: radial-gradient(ellipse at center, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0) 70%);
            border-radius: 50%;
            animation: aura-pulse 4s infinite alternate ease-in-out;
            z-index: -1;
        }
        @keyframes aura-pulse {
            from { transform: scale(1); opacity: 0.7; }
            to { transform: scale(1.2); opacity: 0.4; }
        }
        #cigarette-svg {
            width: 240px; 
            height: 120px; 
            filter: drop-shadow(0 5px 20px rgba(0, 0, 0, 0.8));
            animation: idle-spasm 6s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        #character-container.coughing #cigarette-svg {
            animation: cough-shake 0.5s ease-in-out;
        }
        @keyframes cough-shake {
            0%, 100% { transform: translate(0, 0); }
            20% { transform: translate(-8px, 5px) rotate(-3deg); }
            40% { transform: translate(8px, -5px) rotate(3deg); }
            60% { transform: translate(-5px, 3px) rotate(-2deg); }
            80% { transform: translate(5px, -3px) rotate(2deg); }
        }
        @keyframes idle-spasm {
            0%, 100% { transform: translate(0, 0) rotate(0); }
            10% { transform: translate(-2px, 2px) rotate(-1deg); }
            20% { transform: translate(2px, -2px) rotate(1deg); }
            30% { transform: translate(-3px, 0px) rotate(-1.5deg); }
            40% { transform: translate(3px, 1px) rotate(1.5deg); }
            50% { transform: translate(0, 0) rotate(0); }
            70% { transform: translate(0, 0) rotate(0); }
            72% { transform: translate(5px, -5px) rotate(3deg); }
            74% { transform: translate(0, 0) rotate(0); }
        }
        .cigarette-body-shape { fill: url(#paper-gradient); }
        .filter-shape { fill: #6b3520; }
        .ash-shape { fill: #333; }
        .ember-shape { fill: #ff4500; filter: url(#emberGlow); animation: ember-flicker 1.5s infinite alternate; }
        @keyframes ember-flicker {
            from { opacity: 0.9; }
            to { opacity: 1; }
        }
        .eye-socket { fill: #1a0000; }
        .eye-ball { fill: #dc143c; }
        .eye-pupil { fill: #000; transition: transform 0.1s linear; }
        .eye-vein { stroke: #8b0000; stroke-width: 0.5; fill: none; }
        .mouth { fill: #1a1a1a; transition: d 0.3s ease-in-out; }
        .crack { fill: none; stroke: #4e2a1d; stroke-width: 1.2; }
        .stain { fill: #704214; opacity: 0.6; }
        .spark { fill: #ffdd00; animation: spark-fly 1.5s infinite linear; }
        @keyframes spark-fly {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(-30px, var(--y-end)) scale(0); opacity: 0; }
        }
        .smoke-container { position: absolute; left: -120px; top: 50%; transform: translateY(-50%); width: 200px; height: 200px; pointer-events: none; filter: url(#smokeFilter); }
        .smoke-wisp {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: wisp-rise 12s infinite linear;
            opacity: 0;
        }
        @keyframes wisp-rise {
            0% { transform: translate(0, 0) scale(0.5); opacity: 0; }
            15% { opacity: 0.8; }
            100% { transform: translate(-120px, var(--y-end)) scale(2.5); opacity: 0; }
        }
        .smoke-wisp:nth-child(1) { width: 60px; height: 60px; animation-delay: 0s; --y-end: -80px; }
        .smoke-wisp:nth-child(2) { width: 80px; height: 80px; animation-delay: 4s; --y-end: 50px; }
        .smoke-wisp:nth-child(3) { width: 50px; height: 50px; animation-delay: 8s; --y-end: -20px; }
        #threat-bubble {
            position: absolute; bottom: 100%; left: 50%; margin-bottom: 10px; background-color: #110d0d; color: #ff4500;
            padding: 15px 22px; border-radius: 12px; border: 2px solid #ff4500; font-size: 1.3rem; font-family: 'Metal Mania', cursive;
            letter-spacing: 1px; opacity: 0; transform: translateY(20px) scale(0.9) translateX(-50%);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); white-space: nowrap; box-shadow: 0 0 25px rgba(255, 69, 0, 0.7);
        }
        #threat-bubble.visible { opacity: 1; transform: translateY(0) scale(1) translateX(-50%); }

        #monster-name {
            position: absolute;
            top: 50%;
            left: 230px; /* ƒêi·ªÅu ch·ªânh v·ªã tr√≠ cho ph√π h·ª£p */
            transform: translateY(-50%);
            white-space: nowrap;
        }

        #game-title { animation: sparkle 5s infinite linear; }
        @keyframes sparkle {
            0% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); }
            50% { text-shadow: 2px 2px 8px rgba(236, 72, 153, 0.5); }
            100% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); }
        }
        .health-bar-bg {
            background-color: rgba(0,0,0,0.3);
            border-radius: 9999px;
            padding: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .health-bar {
            background: linear-gradient(to right, #ef4444, #f87171);
            height: 16px;
            border-radius: 9999px;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px #ef4444;
        }
        #custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #ff4500;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 9999;
            transition: transform 0.1s ease-out;
            /* display is set by JS */
        }
        /* M√†n h√¨nh ch·ªù */
        #start-screen {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            padding: 1rem;
        }
        
        .tutorial-icon {
            height: 60px;
            margin: 0 auto 0.5rem auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tutorial-gem-container {
            width: 50px;
            height: 50px;
            position: relative;
        }
        .tutorial-gem {
            width: 100%;
            height: 100%;
            transform: rotate(45deg);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), inset -2px -2px 5px rgba(0,0,0,0.3);
        }
        .tutorial-gem-bomb {
            background: radial-gradient(circle, #6bb5ff, #1E90FF);
        }
        .tutorial-gem-bomb::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 60%;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px white;
        }
        .tutorial-gem-beam {
            background: radial-gradient(circle, #ff7b7b, #FF3131);
        }
        .tutorial-gem-beam::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 25%;
            background-color: white;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px white;
        }
        .tutorial-gem-hypercube {
            background: conic-gradient(from 0deg, #FF3131, #FFFF00, #00FF7F, #1E90FF, #FF00FF, #FF8C00, #FF3131);
            animation: spin 4s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(45deg); }
            to { transform: rotate(405deg); }
        }

        /* --- GIAO DI·ªÜN N√öT M·ªöI --- */
        .ui-button {
            position: fixed;
            z-index: 101; /* Above start screen */
            width: 44px;
            height: 44px;
            background: rgba(10, 20, 30, 0.5);
            border: 1px solid rgba(236, 72, 153, 0.3);
            border-radius: 50%;
            color: rgba(236, 72, 153, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.2), inset 0 0 5px rgba(236, 72, 153, 0.1);
        }
        .ui-button:hover {
            background: rgba(20, 40, 60, 0.7);
            color: white;
            border-color: rgba(236, 72, 153, 0.8);
            box-shadow: 0 0 25px rgba(236, 72, 153, 0.5), inset 0 0 10px rgba(236, 72, 153, 0.2);
            transform: scale(1.1);
        }
        #fullscreen-btn {
            top: 1rem;
            right: 1rem;
        }
        #back-to-menu-btn {
            bottom: 1rem;
            right: 1rem;
        }
    </style>
</head>
<div id="copyright">
    ¬© <span id="year"></span> Th·∫ßy Th√°i Minh Nguy√™n - Tr∆∞·ªùng Ti·ªÉu h·ªçc, THCS & THPT Yersin ƒê√† L·∫°t. All rights reserved.
</div>

<style>
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap');

#copyright {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 13px;
    padding: 6px 0;
    font-family: 'Roboto', Arial, Helvetica, sans-serif;
    z-index: 9999;
    pointer-events: none;

    color: rgba(255, 255, 255, 0.85);
    background: transparent;

    opacity: 0;
    animation: fadeIn 2s ease forwards;
}

@keyframes fadeIn {
    to { opacity: 1; }
}
</style>

<script>
document.getElementById("year").textContent = new Date().getFullYear();
</script>

<body class="bg-gradient-to-br from-gray-700 via-gray-800 to-gray-900 flex items-end justify-center min-h-screen p-4">

<!-- N√∫t To√†n m√†n h√¨nh -->
<button id="fullscreen-btn" class="ui-button" title="To√†n m√†n h√¨nh">
    <svg id="fullscreen-icon-open" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
    <svg id="fullscreen-icon-close" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
</button>

<!-- N√∫t V·ªÅ m√†n h√¨nh ch√≠nh -->
<button id="back-to-menu-btn" class="ui-button hidden" title="V·ªÅ m√†n h√¨nh ch√≠nh">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
</button>

<!-- M√†n h√¨nh ch·ªù -->
<div id="start-screen">
    <h1 class="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-4" id="game-title-start">B·∫£o V·ªá Tr√°i Tim</h1>
    <p class="text-gray-200 italic text-xl md:text-2xl mb-8 max-w-2xl">Qu√°i v·∫≠t thu·ªëc l√° ƒëang ƒë·∫øn g·∫ßn. H√£y d√πng tr√≠ tu·ªá c·ªßa b·∫°n ƒë·ªÉ gh√©p c√°c vi√™n kim c∆∞∆°ng, c·ª©u l·∫•y nh·ªØng tr√°i tim v√† ƒë·∫©y l√πi m·ªëi ƒëe d·ªça!</p>
    <div id="start-buttons" class="flex flex-col sm:flex-row gap-4">
        <button id="easy-mode-btn" class="bg-green-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">D·ªÖ (1 M√†n)</button>
        <button id="hard-mode-btn" class="bg-red-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">Kh√≥ (3 M√†n)</button>
        <button id="free-mode-btn" class="bg-blue-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">T·ª± Do</button>
    </div>
</div>

<!-- Modal H∆∞·ªõng d·∫´n ch∆°i -->
<div id="tutorial-modal" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm">
    <div class="bg-gray-800 border border-gray-700 rounded-2xl p-6 md:p-8 shadow-2xl max-w-md w-full text-white text-center">
        <!-- Step 1: Tr√°i Tim -->
        <div id="tutorial-step-1" class="tutorial-step">
            <h2 class="text-3xl font-bold text-pink-400 mb-4">M·ª•c Ti√™u: C·ª©u Tr√°i Tim!</h2>
            <div class="tutorial-icon text-5xl">üíó</div>
            <p class="text-lg mb-4">M·ªói v√†i n∆∞·ªõc ƒëi, m·ªôt vi√™n kim c∆∞∆°ng <strong>Tr√°i Tim</strong> s·∫Ω xu·∫•t hi·ªán ·ªü h√†ng d∆∞·ªõi c√πng.</p>
            <p class="text-lg mb-6">H√£y ƒë∆∞a n√≥ l√™n <strong>h√†ng tr√™n c√πng</strong> ƒë·ªÉ c·ª©u tr√°i tim v√† ghi ƒëi·ªÉm. ƒê·ª´ng ƒë·ªÉ qu√°i v·∫≠t thu·ªëc l√° ch·∫°m t·ªõi!</p>
            <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Ti·∫øp theo</button>
        </div>

        <!-- Step 2: Kim c∆∞∆°ng ƒë·∫∑c bi·ªát -->
        <div id="tutorial-step-2" class="tutorial-step hidden">
             <h2 class="text-3xl font-bold text-yellow-400 mb-4">S·ª©c M·∫°nh ƒê·∫∑c Bi·ªát</h2>
             <p class="text-lg mb-4">Gh√©p 4 ho·∫∑c 5 vi√™n kim c∆∞∆°ng ƒë·ªÉ t·∫°o ra c√°c lo·∫°i ƒë·∫∑c bi·ªát:</p>
             <div class="flex justify-around items-start text-center mb-6 space-x-2">
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-bomb"></div>
                        </div>
                    </div>
                    <p class="font-bold">Bom</p>
                    <p class="text-sm text-gray-300">(Gh√©p 5 vi√™n h√¨nh ch·ªØ L ho·∫∑c T)</p>
                </div>
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-beam"></div>
                        </div>
                    </div>
                    <p class="font-bold">Tia S√°ng</p>
                    <p class="text-sm text-gray-300">(Gh√©p 4 vi√™n)</p>
                </div>
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-hypercube"></div>
                        </div>
                    </div>
                    <p class="font-bold">Si√™u Kh·ªëi</p>
                    <p class="text-sm text-gray-300">(Gh√©p 5 vi√™n th·∫≥ng h√†ng)</p>
                </div>
             </div>
             <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Ti·∫øp theo</button>
        </div>

        <!-- Step 3: Qu√°i v·∫≠t -->
        <div id="tutorial-step-3" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-red-500 mb-4">M·ªëi ƒêe D·ªça</h2>
            <div class="tutorial-icon text-5xl">üö¨</div>
            <p class="text-lg mb-4"><strong>Qu√°i v·∫≠t thu·ªëc l√°</strong> s·∫Ω di chuy·ªÉn v√† c·ªë g·∫Øng "ƒÉn" nh·ªØng tr√°i tim ·ªü h√†ng tr√™n c√πng.</p>
            <p class="text-lg mb-6">H√£y ngƒÉn ch·∫∑n n√≥ b·∫±ng c√°ch ho√†n th√†nh <strong>m·ª•c ti√™u</strong> ·ªü b·∫£ng b√™n tr√°i ƒë·ªÉ qua m√†n!</p>
            <button id="play-from-tutorial-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform hover:scale-105">B·∫Øt ƒë·∫ßu ch∆°i!</button>
        </div>
    </div>
</div>


<div id="custom-cursor"></div>
<div class="w-full max-w-7xl mx-auto flex flex-col md:flex-row items-center md:items-start justify-center gap-4 md:gap-8">

    <!-- C·ªôt Tr√°i (Ti√™u ƒë·ªÅ & M·ª•c Ti√™u) -->
    <div id="objective-panel" class="w-full md:w-1/4 order-2 md:order-1">
        <div class="title-container text-center md:text-left mb-4">
            <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-2" id="game-title">B·∫£o V·ªá Tr√°i Tim</h1>
            <p class="text-gray-200 italic text-lg md:text-xl" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">Ti√™u di·ªát qu√°i v·∫≠t thu·ªëc l√°!</p>
        </div>
        <div class="p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <h2 class="text-xl font-bold text-white/80 mb-2">M·ª•c Ti√™u</h2>
            <div class="health-bar-bg mb-4">
                <div class="health-bar" id="health-bar" style="width: 0%;"></div>
            </div>
            <div class="space-y-2" id="quest-list">
                <!-- Quest items will be generated by JS -->
            </div>
        </div>
    </div>

    <!-- C·ªôt Gi·ªØa (Game) -->
    <div class="w-full max-w-md text-center order-1 md:order-2">
        <div class="relative" id="game-container">
            <div id="character-container">
                <div class="character-aura"></div>
                <svg id="cigarette-svg" viewBox="0 0 200 100">
                    <defs>
                        <filter id="smokeFilter">
                            <feTurbulence type="fractalNoise" baseFrequency="0.02 0.05" numOctaves="3" result="turbulence" />
                            <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="15" xChannelSelector="R" yChannelSelector="G" />
                        </filter>
                        <filter id="emberGlow">
                            <feGaussianBlur stdDeviation="3.5" result="coloredBlur" />
                            <feMerge>
                                <feMergeNode in="coloredBlur" />
                                <feMergeNode in="SourceGraphic" />
                            </feMerge>
                        </filter>
                        <radialGradient id="paper-gradient">
                            <stop offset="0%" stop-color="#d2b48c" />
                            <stop offset="100%" stop-color="#c8a97e" />
                        </radialGradient>
                    </defs>
                    <path class="filter-shape" d="M160,30 L180,28 Q192,30 190,50 Q188,70 180,72 L160,70 Z" />
                    <path class="cigarette-body-shape" d="M20,30 L160,30 L160,70 L20,70 Q10,70 10,50 Q10,30 20,30 Z" />
                    <path class="stain" d="M110,40 C 120,35 130,45 125,55 C 120,60 110,55 110,40 Z" />
                    <path class="stain" d="M70,60 C 75,55 85,58 80,68 Z" />
                    <path class="crack" d="M140,45 C 145,50, 145,55, 150,60" />
                    <path class="crack" d="M100,35 C 105,45, 95,55, 100,65" />
                    <path class="crack" d="M40,35 L 45,65" />
                    <path class="crack" d="M155,35 L 158,65" />
                    <path class="ash-shape" d="M20,30 Q10,30 10,50 Q10,70 20,70 L30,70 Q25,50 30,30 Z" />
                    <path d="M28 40 L 32 38 M28 50 L 33 50 M28 60 L 32 62" stroke="#a0522d" stroke-width="1" />
                    <path class="ember-shape" d="M25,35 Q20,50 25,65 L20,65 Q15,50 20,35 Z" />
                    <g id="sparks">
                        <circle class="spark" cx="22" cy="40" r="1.5" style="animation-delay: 0s; --y-end: -20px;"></circle>
                        <circle class="spark" cx="20" cy="50" r="1" style="animation-delay: 0.5s; --y-end: 0px;"></circle>
                        <circle class="spark" cx="22" cy="60" r="1.5" style="animation-delay: 1s; --y-end: 20px;"></circle>
                    </g>
                    <g id="face">
                        <g id="eye1_group">
                            <circle class="eye-socket" cx="55" cy="50" r="12" />
                            <circle class="eye-ball" cx="55" cy="50" r="11" />
                            <path class="eye-vein" d="M50,50 C 52,47 55,47 57,50" />
                            <path class="eye-vein" d="M57,50 C 59,53 62,53 85,50" />
                            <circle class="eye-pupil" id="pupil1" cx="55" cy="50" r="5" />
                        </g>
                        <g id="eye2_group">
                            <circle class="eye-socket" cx="80" cy="50" r="12" />
                            <circle class="eye-ball" cx="80" cy="50" r="11" />
                            <path class="eye-vein" d="M75,50 C 77,47 80,47 82,50" />
                            <path class="eye-vein" d="M82,50 C 84,53 87,53 85,50" />
                            <circle class="eye-pupil" id="pupil2" cx="80" cy="50" r="5" />
                        </g>
                        <path class="mouth" id="mouth-path" d="M60 65 L 64 63 L 68 65 L 72 63 L 76 65" />
                    </g>
                </svg>
                <div class="smoke-container">
                    <div class="smoke-wisp"></div>
                    <div class="smoke-wisp"></div>
                    <div class="smoke-wisp"></div>
                </div>
                <div id="threat-bubble"><p id="threat-text"></p></div>
                <div id="monster-name" class="text-center">
                    <p class="text-lg font-bold text-red-400" style="text-shadow: 0 0 8px rgba(255, 0, 0, 0.7);">Qu√°i v·∫≠t thu·ªëc l√°</p>
                </div>
            </div>
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>
    
    <!-- C·ªôt Ph·∫£i (Th√¥ng tin) -->
    <div class="w-full md:w-1/4 order-3 flex flex-row md:flex-col gap-4 md:gap-6">
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">C·∫•p ƒê·ªô</p>
            <p class="text-4xl font-bold text-white" id="level">1</p>
        </div>
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">N∆∞·ªõc ƒëi</p>
            <p class="text-4xl font-bold text-white" id="moves">0</p>
        </div>
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">Tr√°i tim ƒë√£ c·ª©u</p>
            <p class="text-4xl font-bold text-white" id="score">0</p>
        </div>
    </div>
</div>


<!-- Modal Chi·∫øn Th·∫Øng -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="winModal" tabindex="-1">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-green-600 mb-4">Qua M√†n!</h2>
        <p class="text-lg text-gray-700 mb-6" id="win-level-text"></p>
        <button class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-300" id="nextLevelButton">Ti·∫øp t·ª•c</button>
    </div>
</div>

<!-- Modal Game Over -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="gameOverModal" tabindex="-1">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-red-800 mb-4">Nguy hi·ªÉm!</h2>
        <p class="text-lg text-gray-700 mb-2">Thu·ªëc l√° ƒë√£ l√†m h·∫°i m·ªôt tr√°i tim.</p>
        <p class="text-xl text-gray-800 mb-8">B·∫°n ƒë√£ b·∫£o v·ªá ƒë∆∞·ª£c <span class="font-bold text-pink-600" id="finalScore">0</span> tr√°i tim.</p>
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="gameOverHomeButton">V·ªÅ Trang Ch·ªß</button>
            <button class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105" id="gameOverRestartButton">Ch∆°i L·∫°i</button>
        </div>
    </div>
</div>


<!-- Modal Th√¥ng ƒëi·ªáp s·ª©c kh·ªèe -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm" id="factModal" tabindex="-1">
    <div class="bg-white rounded-2xl p-6 md:p-8 text-center shadow-2xl transform transition-all scale-95 max-w-md w-full">
        <h2 class="text-2xl md:text-3xl font-bold text-blue-700 mb-4">S·ª± Th·∫≠t & L·ªùi Khuy√™n</h2>
        <p class="text-base md:text-lg text-gray-800 mb-3 text-left" id="factText"></p>
        <p class="text-base md:text-lg text-green-700 font-semibold mb-6 text-left" id="adviceText"></p>
        <button class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300" id="closeFactButton">ƒê√£ hi·ªÉu</button>
    </div>
</div>

<!-- Modal Chi·∫øn Th·∫Øng Cu·ªëi C√πng -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="finalWinModal" tabindex="-1">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-yellow-500 mb-4">CHI·∫æN TH·∫ÆNG!</h2>
        <p class="text-lg text-gray-700 mb-2">B·∫°n ƒë√£ b·∫£o v·ªá th√†nh c√¥ng nh·ªØng tr√°i tim kh·ªèi nanh vu·ªët c·ªßa qu√°i v·∫≠t!</p>
        <p class="text-xl text-gray-800 mb-6">C·∫£m ∆°n b·∫°n ƒë√£ tr·ªü th√†nh ng∆∞·ªùi h√πng!</p>
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="restartGameButton">Ch∆°i l·∫°i</button>
            <button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="backToIndexButton">V·ªÅ m√†n h√¨nh ch√≠nh</button>
            <button class="bg-yellow-500 text-white font-bold py-3 px-8 rounded-full hover:bg-yellow-600 transition-transform transform hover:scale-110 ring-4 ring-yellow-300 shadow-lg shadow-yellow-500/50" id="continueToNextGameButton">Ti·∫øp t·ª•c</button>
        </div>
    </div>
</div>

<script>
// S·ª≠ d·ª•ng IIFE ƒë·ªÉ t·∫°o scope ri√™ng, tr√°nh bi·∫øn to√†n c·ª•c
(function() {
    'use strict';

    // =========================================================================
    // --- MODULE: CONSTANTS & CONFIG ---
    // =========================================================================

    const CONFIG = {
        GRID_SIZE: 8,
        GEM_COLORS: ['#FF3131', '#00FF7F', '#1E90FF', '#FF00FF', '#FF8C00', '#FFFF00'],
        HEART_EMOJI: 'üíó',
        MOVES_PER_HEART_SPAWN: 3,
        CIGARETTE_LUNGE_CHANCE: 0.25,
        THREAT_INTERVAL: 6000,
        ANIM_SWAP_SPEED: 150,
        ANIM_FALL_SPEED: 400,
        ANIM_CLEAR_SPEED: 200,
        ANIM_SPECIAL_PULSE_SPEED: 150,
        MAX_PARTICLES: 150, 
        HINT_TIMEOUT: 5000,
        FINAL_LEVEL: 1,
        COUGH_INTERVAL_MOVES: 10,
        COUGH_START_LEVEL: 2
    };

    const SPECIAL_TYPES = {
        NONE: 'none',
        H_BEAM: 'h_beam',
        V_BEAM: 'v_beam',
        BOMB: 'bomb',
        HYPERCUBE: 'hypercube'
    };

    const HEALTH_FACTS = [
        { fact: "Thu·ªëc l√° gi·∫øt **h∆°n 7 tri·ªáu ng∆∞·ªùi/nƒÉm**, trong ƒë√≥ c√≥ kho·∫£ng **1,6 tri·ªáu ng∆∞·ªùi kh√¥ng h√∫t th·ª• ƒë·ªông**. (Ngu·ªìn: WHO)", advice: "L·ªùi khuy√™n: H√£y tr√°nh xa kh√≥i thu·ªëc ƒë·ªÉ b·∫£o v·ªá b·∫°n v√† nh·ªØng ng∆∞·ªùi xung quanh." },
        { fact: "H√∫t thu·ªëc kh√¥ng th·ª• ƒë·ªông (passive smoking) c≈©ng g√¢y ung th∆∞ ph·ªïi, b·ªánh tim v√† nhi·ªÅu v·∫•n ƒë·ªÅ s·ª©c kh·ªèe nghi√™m tr·ªçng. (Ngu·ªìn: CDC / IARC)", advice: "L·ªùi khuy√™n: ƒê·ª´ng ƒë·ªÉ kh√≥i thu·ªëc x√¢m nh·∫≠p kh√¥ng kh√≠ s·ªëng, gi·ªØ s·∫°ch m√¥i tr∆∞·ªùng cho ph·ªïi b·∫°n." },
        { fact: "H√∫t thu·ªëc g√¢y t·ªïn th∆∞∆°ng **gan, ph·ªïi, tim**, l√†m tƒÉng nguy c∆° m·∫Øc **COPD, nh·ªìi m√°u c∆° tim, ƒë·ªôt qu·ªµ** v√† nhi·ªÅu lo·∫°i ung th∆∞. (Ngu·ªìn: CDC)", advice: "L·ªùi khuy√™n: M·ªói h∆°i thu·ªëc b·∫°n h√≠t v√†o l√† t·ªïn h·∫°i cho c∆° th·ªÉ‚Äîng∆∞ng ngay h√¥m nay ƒë·ªÉ kh·ªèe m·∫°nh h∆°n." },
        { fact: "H√∫t thu·ªëc g√¢y ung th∆∞ ·ªü **kho·∫£ng 20% c√°c ca ung th∆∞**, v√† kho·∫£ng **80% ca ung th∆∞ ph·ªïi** l√† do vi·ªác h√∫t thu·ªëc. (Ngu·ªìn: American Cancer Society)", advice: "L·ªùi khuy√™n: B·ªè thu·ªëc s·∫Ω gi√∫p gi·∫£m nguy c∆° m·∫Øc nhi·ªÅu lo·∫°i ung th∆∞ ‚Äî ƒë√≥ l√† c√°ch b·∫£o v·ªá t∆∞∆°ng lai c·ªßa b·∫°n." },
        { fact: "H√∫t thu·ªëc c√≥ th·ªÉ **r√∫t ng·∫Øn tu·ªïi th·ªç trung b√¨nh 10 nƒÉm** so v·ªõi ng∆∞·ªùi kh√¥ng h√∫t. (Ngu·ªìn: Wikipedia ‚Äì WHO)", advice: "L·ªùi khuy√™n: Ch·ªçn s·ªëng l√¢u h∆°n ‚Äî n√≥i kh√¥ng v·ªõi thu·ªëc l√° h√¥m nay." },
        { fact: "Kh√≥i thu·ªëc l√° ch·ª©a h∆°n **7.000 h√≥a ch·∫•t**, trong ƒë√≥ c√≥ **h∆°n 70 ch·∫•t g√¢y ung th∆∞**. (Ngu·ªìn: FDA)", advice: "L·ªùi khuy√™n: C∆° th·ªÉ b·∫°n kh√¥ng n√™n tr·ªü th√†nh ph√≤ng th√≠ nghi·ªám‚Äîh√£y gi·ªØ ph·ªïi trong l√†nh." },
        { fact: "H√∫t thu·ªëc l√†m suy y·∫øu h·ªá mi·ªÖn d·ªãch, l√†m c∆° th·ªÉ kh√≥ ch·ªëng l·∫°i nhi·ªÖm tr√πng v√† c√≥ th·ªÉ l√†m t·ªïn th∆∞∆°ng mi·ªÖn d·ªãch k√©o d√†i ngay c·∫£ sau khi b·ªè thu·ªëc. (Ngu·ªìn: Nature/CNN)", advice: "L·ªùi khuy√™n: H√£y b·∫£o v·ªá h·ªá mi·ªÖn d·ªãch c·ªßa b·∫°n‚Äîm·ªôt l√Ω do tuy·ªát v·ªùi ƒë·ªÉ b·ªè thu·ªëc." },
        { fact: "Ti·∫øp x√∫c v·ªõi kh√≥i thu·ªëc l√†m tƒÉng nguy c∆° ung th∆∞ v√∫ ·ªü ph·ª• n·ªØ tr·∫ª l√™n t·ªõi **70%**. (Ngu·ªìn: IARC / Wikipedia)", advice: "L·ªùi khuy√™n: B·∫£o v·ªá b·∫£n th√¢n, b·∫£o v·ªá s·ª©c kh·ªèe‚Äîtr√°nh kh√≥i thu·ªëc th·ª• ƒë·ªông." },
        { fact: "H√∫t thu·ªëc l√†m gi·∫£m kh·∫£ nƒÉng sinh s·∫£n‚Äîph·ª• n·ªØ h√∫t thu·ªëc c√≥ nguy c∆° v√¥ sinh cao h∆°n **60%**, tƒÉng nguy c∆° s·∫©y thai v√† c√°c v·∫•n ƒë·ªÅ thai k·ª≥. (Ngu·ªìn: Wikipedia)", advice: "L·ªùi khuy√™n: H√£y gi·ªØ s·ª©c kh·ªèe sinh s·∫£n‚Äîn√≥i kh√¥ng v·ªõi thu·ªëc l√° ƒë·ªÉ t∆∞∆°ng lai t∆∞∆°i s√°ng." },
        { fact: "Kh√¥ng c√≥ m·ª©c ƒë·ªô h√∫t thu·ªëc n√†o l√† an to√†n ‚Äî k·ªÉ c·∫£ m·ªôt ƒëi·∫øu m·ªói ng√†y c≈©ng tƒÉng nguy c∆° b·ªánh tim v√† ung th∆∞. (Ngu·ªìn: WHO)", advice: "L·ªùi khuy√™n: ƒê·ª´ng t·ª± ƒë√°nh l·ª´a‚Äîb·ªè h·∫≥n l√† c√°ch an to√†n duy nh·∫•t." },
    ];
    
    const THREATS = [
        "Ta n·∫øm ƒë∆∞·ª£c n·ªói s·ª£ c·ªßa ng∆∞∆°i.",
        "M·ªói t·∫ø b√†o c·ªßa ng∆∞∆°i ƒëang g√†o th√©t.",
        "Ta l√† c√°i ch·∫øt ch·∫≠m r√£i ng∆∞∆°i t·ª± ch·ªçn.",
        "Linh h·ªìn ng∆∞∆°i... s·∫Ω l√† l√†n kh√≥i ti·∫øp theo.",
        "Kh√¥ng c√≥ l·ªëi tho√°t ƒë√¢u."
    ];

    // =========================================================================
    // --- MODULE: DOM ELEMENTS ---
    // =========================================================================

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const movesEl = document.getElementById('moves');
    const winModal = document.getElementById('winModal');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const winLevelText = document.getElementById('win-level-text');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');
    const factModal = document.getElementById('factModal');
    const factText = document.getElementById('factText');
    const adviceText = document.getElementById('adviceText');
    const closeFactButton = document.getElementById('closeFactButton');
    const healthBar = document.getElementById('health-bar');
    const questList = document.getElementById('quest-list');
    const startScreen = document.getElementById('start-screen');
    const customCursor = document.getElementById('custom-cursor');
    const tutorialModal = document.getElementById('tutorial-modal');
    const tutorialSteps = document.querySelectorAll('.tutorial-step');
    const tutorialNextBtns = document.querySelectorAll('.tutorial-next-btn');
    const playFromTutorialBtn = document.getElementById('play-from-tutorial-btn');
    const finalWinModal = document.getElementById('finalWinModal');
    const restartGameButton = document.getElementById('restartGameButton');
    const easyModeBtn = document.getElementById('easy-mode-btn');
    const hardModeBtn = document.getElementById('hard-mode-btn');
    const freeModeBtn = document.getElementById('free-mode-btn');
    const backToMenuBtn = document.getElementById('back-to-menu-btn');
    const characterContainerEl = document.getElementById('character-container');
    const threatBubble = document.getElementById('threat-bubble');
    const threatText = document.getElementById('threat-text');
    const mouth = document.getElementById('mouth-path');
    const pupil1 = document.getElementById('pupil1');
    const pupil2 = document.getElementById('pupil2');

    // =========================================================================
    // --- MODULE: GAME STATE ---
    // =========================================================================

    let gemSize;
    let board = [];
    let selectedGem = null;
    let score = 0;
    let moves = 0;
    let isAnimating = false;
    let isPaused = false;
    let animations = [];
    let particles = [];
    let cigarette = { col: Math.floor(CONFIG.GRID_SIZE / 2), level: 1 };
    let currentLevel = 1;
    let quest = {};
    let startDragPos = { x: null, y: null };
    let startGem = null;
    let isDragging = false;
    let gemCache = {}; 
    let particlePool = [];
    let hintTimeout = null;
    let hintGems = [];
    let isFreePlayMode = false;
    let resizeTimer = null;
    let factsShown = [];
    let threatInterval = null;
    let currentModal = null;

    // =========================================================================
    // --- MODULE: AUDIO MANAGER ---
    // =========================================================================

    const AudioManager = {
      initialized: false,
      started: false,
      nodes: {},
      sfx: {},
      musicParts: {},
      lastPlayed: {}, 
      MIN_INTERVAL: 0.05, 

      setup() {
        if (this.initialized) return;
        Tone.Destination.volume.value = -9;
        const limiter = new Tone.Limiter(-1).toDestination();
        const comp = new Tone.Compressor(-24, 4).connect(limiter);
        const reverb = new Tone.Reverb({ decay: 1.5, wet: 0.2 }).connect(comp);
        const delay = new Tone.FeedbackDelay("16n", 0.25).connect(reverb);
        const melodySynth = new Tone.PolySynth(Tone.FMSynth, {
            harmonicity: 2, modulationIndex: 5,
            envelope: { attack: 0.01, decay: 0.2, release: 0.2 },
            modulationEnvelope: { attack: 0.01, decay: 0.1, release: 0.2 }
        }).connect(delay);
        melodySynth.volume.value = -15;
        const bassSynth = new Tone.MonoSynth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.3, release: 1 },
            filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.5, baseFrequency: 200, octaves: 2.6 }
        }).connect(comp);
        bassSynth.volume.value = -18;
        const melodyPattern = new Tone.Sequence((time, note) => {
            melodySynth.triggerAttackRelease(note, "16n", time);
        }, ["C5", null, "E5", "G5", "E5", null, "C5", null, "D5", null, "F5", "A5", "F5", null, "D5", null], "8n");
        const bassPattern = new Tone.Sequence((time, note) => {
            bassSynth.triggerAttackRelease(note, "2n", time);
        }, ["C3", "G3"], "1n");
        const clickSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.03 } }).connect(comp);
        const pluck = new Tone.PluckSynth().connect(comp);
        const noise = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.005, decay: 0.15, sustain: 0 } }).connect(new Tone.Filter(1200, "bandpass").connect(comp));
        const bombKick = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 3, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.2 } }).connect(comp);
        const fm = new Tone.FMSynth().connect(reverb);
        const unlockSynth = new Tone.MetalSynth({
            frequency: 400,
            envelope: { attack: 0.001, decay: 0.1, release: 0.05 },
            harmonicity: 3.1,
            modulationIndex: 16,
            resonance: 4000,
            octaves: 0.5
        }).connect(comp);
        unlockSynth.volume.value = -18;
        const coughSound = new Tone.NoiseSynth({
            noise: { type: "brown" },
            envelope: { attack: 0.1, decay: 0.3, sustain: 0 }
        }).connect(new Tone.Filter(200, "lowpass").connect(comp));
        coughSound.volume.value = -10;

        this.sfx = { clickSynth, pluck, noise, kick: bombKick, fm, unlockSynth, coughSound };
        this.musicParts = { melodyPattern, bassPattern };
        Tone.Transport.bpm.value = 140;
        this.initialized = true;
      },
      async start() {
        if (this.started) return;
        this.setup();
        await Tone.start();
        this.musicParts.melodyPattern.start(0);
        this.musicParts.bassPattern.start(0);
        Tone.Transport.start("+0.1");
        this.started = true;
      },
      setMasterVolume(db) { Tone.Destination.volume.rampTo(db, 0.2); },
      play(name, opts = {}) {
        if (!this.initialized || !this.started) return;
        
        const now = Tone.now();
        const last = this.lastPlayed[name] || 0;
        if (now - last < this.MIN_INTERVAL && name !== 'matchSound') { // Allow match sounds to overlap
            return; 
        }
        this.lastPlayed[name] = now;

        switch (name) {
          case "selectSound": this.sfx.clickSynth.triggerAttackRelease("C5", "16n"); break;
          case "matchSound": {
            const intensity = Math.min(1, Math.max(0.2, (opts.intensity || 3) / 6));
            this.sfx.pluck.triggerAttackRelease("E5", "8n", undefined, 0.4 + 0.4 * intensity);
            break;
          }
          case "beamSound": this.sfx.noise.triggerAttackRelease("16n"); break;
          case "bombSound": this.sfx.kick.triggerAttackRelease("C2", "8n"); break;
          case "hypercubeSound": this.sfx.fm.triggerAttackRelease("A4", "8n"); break;
          case "unlockSound": this.sfx.unlockSynth.triggerAttack(); break;
          case "coughSound": this.sfx.coughSound.triggerAttack(); break;
        }
      }
    };

    // =========================================================================
    // --- MODULE: UI & RENDERING ---
    // =========================================================================
    
    function showModal(modalElement, focusElement) {
        currentModal = modalElement;
        modalElement.classList.remove('hidden');
        setTimeout(() => {
            modalElement.querySelector('div').classList.add('scale-100');
            if (focusElement) focusElement.focus();
        }, 10);
    }

    function hideModal(modalElement) {
        if (modalElement) {
            modalElement.querySelector('div').classList.remove('scale-100');
            setTimeout(() => modalElement.classList.add('hidden'), 200);
        }
        currentModal = null;
    }


    function showThreat() {
        if (isPaused || !gameOverModal.classList.contains('hidden') || characterContainerEl.classList.contains('attacking')) return;
        AudioManager.play('beamSound');
        threatText.textContent = THREATS[Math.floor(Math.random() * THREATS.length)];
        mouth.setAttribute('d', 'M58 68 L 64 60 L 70 68 L 76 60 L 82 68');
        characterContainerEl.classList.add('attacking');
        threatBubble.classList.add('visible');
        setTimeout(() => {
            threatBubble.classList.remove('visible');
            mouth.setAttribute('d', 'M60 65 L 64 63 L 68 65 L 72 63 L 76 65');
            characterContainerEl.classList.remove('attacking');
        }, 2000);
    }

    async function showFact() {
        isPaused = true;
        clearTimeout(hintTimeout);
        let availableFacts = HEALTH_FACTS.filter(obj => !factsShown.includes(obj));
        if (availableFacts.length === 0) factsShown = [];
        const factObject = availableFacts.length > 0 ? availableFacts[Math.floor(Math.random() * availableFacts.length)] : HEALTH_FACTS[0];
        factsShown.push(factObject);
        const formattedFact = factObject.fact.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        const formattedAdvice = factObject.advice.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        factText.innerHTML = formattedFact;
        adviceText.innerHTML = formattedAdvice;
        
        showModal(factModal, closeFactButton);
    }

    function showGameOver() {
        AudioManager.setMasterVolume(-12);
        isAnimating = true;
        isPaused = true;
        if (threatInterval) clearInterval(threatInterval);
        finalScoreEl.textContent = score;
        showModal(gameOverModal, gameOverRestartButton);
    }

    function updateQuestUI() {
        questList.innerHTML = '';
        for (const colorIdx in quest.targets) {
            const remaining = Math.max(0, quest.targets[colorIdx] - quest.collected[colorIdx]);
            const isCompleted = remaining === 0;
            const item = document.createElement('div');
            item.className = `flex items-center justify-between p-2 rounded-lg transition-all ${isCompleted ? 'bg-green-500/30' : 'bg-black/20'}`;
            item.innerHTML = `<div class="w-6 h-6 rounded-full border-2 border-white/20" style="background-color: ${CONFIG.GEM_COLORS[colorIdx]}"></div><span class="font-bold text-white">${remaining}</span>`;
            questList.appendChild(item);
        }
        const remainingHearts = Math.max(0, quest.heartsToSave - quest.heartsSaved);
        const heartsCompleted = remainingHearts === 0;
        const heartItem = document.createElement('div');
        heartItem.className = `flex items-center justify-between p-2 rounded-lg transition-all ${heartsCompleted ? 'bg-green-500/30' : 'bg-black/20'}`;
        heartItem.innerHTML = `<span class="text-2xl">${CONFIG.HEART_EMOJI}</span><span class="font-bold text-white">${remainingHearts}</span>`;
        questList.appendChild(heartItem);
    }

    function updateHealthBar() {
        const progressPercent = quest.maxDamage > 0 ? Math.min(100, (quest.totalDamage / quest.maxDamage) * 100) : 0;
        healthBar.style.width = `${progressPercent}%`;
    }

    function updateScore() { scoreEl.textContent = score; }
    function updateMoves() { movesEl.textContent = moves; }

    function drawBoard(time) {
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                const gem = board[row][col];
                if (gem) {
                    ctx.save();
                    ctx.globalAlpha = gem.alpha;
                    const centerX = gem.x + gemSize / 2;
                    const centerY = gem.y + gemSize / 2;
                    ctx.translate(centerX, centerY);
                    ctx.scale(gem.scale, gem.scale);
                    ctx.translate(-centerX, -centerY);
                    let cacheKey;
                    if (gem.special !== SPECIAL_TYPES.NONE && gem.special !== SPECIAL_TYPES.HYPERCUBE) {
                        cacheKey = `${gem.special}_${gem.colorIndex}`;
                    } else if (gem.special === SPECIAL_TYPES.HYPERCUBE) {
                        cacheKey = SPECIAL_TYPES.HYPERCUBE;
                    } else {
                        cacheKey = CONFIG.GEM_COLORS[gem.colorIndex];
                    }
                    const cachedGem = gemCache[cacheKey];
                    if (cachedGem) {
                        ctx.drawImage(cachedGem, gem.x, gem.y, gemSize, gemSize);
                    }
                    if (gem.isLocked) {
                        ctx.drawImage(gemCache['chain'], gem.x, gem.y, gemSize, gemSize);
                    }
                    if (gem.isHeart) {
                        const heartPulse = Math.sin(time / 300) * 0.1 + 1.1;
                        ctx.save();
                        ctx.translate(gem.x + gemSize / 2, gem.y + gemSize / 2);
                        ctx.scale(heartPulse, heartPulse);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = 'rgba(0,0,0,0)';
                        ctx.font = `${gemSize * 0.6}px sans-serif`;
                        ctx.fillText(CONFIG.HEART_EMOJI, 0, 0);
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }
        }
    }

    function drawHint(time) {
        if (hintGems.length === 2 && !isAnimating) {
            const [gem1, gem2] = hintGems;
            const pulse = (Math.sin(time / 200) + 1) / 2;
            const scale = 1 + 0.05 * pulse;
            const drawPulse = (gem) => {
                if (!gem) return;
                ctx.save();
                const centerX = gem.x + gemSize / 2;
                const centerY = gem.y + gemSize / 2;
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.translate(-centerX, -centerY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(gem.x + 2, gem.y + 2, gemSize - 4, gemSize - 4);
                ctx.restore();
            };
            drawPulse(gem1);
            drawPulse(gem2);
        }
    }

    function drawParticles() {
        for (let i = particlePool.length - 1; i >= 0; i--) {
            const p = particlePool[i];
            if (!p.active) continue;
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= 0.02;
            if (p.alpha <= 0) {
                p.active = false;
            } else {
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
    }

    function drawSelection(time) {
        if (selectedGem) {
            const pulse = Math.sin(time / 100) * 0.5 + 0.5;
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
        }
    }

    async function preRenderGems() {
        gemCache = {};
        const promises = [];
        const specials = Object.values(SPECIAL_TYPES);
        const size = Math.max(1, Math.round(gemSize));

        CONFIG.GEM_COLORS.forEach((col) => {
            const canvas = renderGemCanvas(col, size);
            if ('createImageBitmap' in window) {
                promises.push(createImageBitmap(canvas).then(img => { gemCache[col] = img; }));
            } else {
                gemCache[col] = canvas;
            }
        });

        specials.forEach(special => {
            if (special === SPECIAL_TYPES.HYPERCUBE) {
                const canvas = renderHypercubeCanvas(size);
                 if ('createImageBitmap' in window) {
                    promises.push(createImageBitmap(canvas).then(img => { gemCache[special] = img; }));
                } else {
                    gemCache[special] = canvas;
                }
            } else if (special !== SPECIAL_TYPES.NONE) {
                CONFIG.GEM_COLORS.forEach((col, idx) => {
                    const canvas = renderSpecialCanvas(special, col, size);
                     if ('createImageBitmap' in window) {
                        promises.push(createImageBitmap(canvas).then(img => { gemCache[`${special}_${idx}`] = img; }));
                    } else {
                        gemCache[`${special}_${idx}`] = canvas;
                    }
                });
            }
        });
        
        const chainCanvas = renderChainCanvas(size);
        if ('createImageBitmap' in window) {
            promises.push(createImageBitmap(chainCanvas).then(img => { gemCache['chain'] = img; }));
        } else {
            gemCache['chain'] = chainCanvas;
        }

        await Promise.all(promises);
    }
    
    function renderGemCanvas(color, size) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = size;
        offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;
        
        offscreenCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
        offscreenCtx.shadowBlur = 5;
        offscreenCtx.shadowOffsetX = 2;
        offscreenCtx.shadowOffsetY = 2;

        const shadeColor = (col, percent) => {
            let f = parseInt(col.slice(1), 16), t = percent < 0 ? 0 : 255, p = Math.abs(percent),
                R = f >> 16, G = (f >> 8) & 0xff, B = f & 0xff;
            const hex = (0x1000000 + (Math.round((t-R)*p)+R)*0x10000 + (Math.round((t-G)*p)+G)*0x100 + (Math.round((t-B)*p)+B)).toString(16).slice(1);
            return `#${hex.padStart(6,'0')}`;
        };

        const lightColor = shadeColor(color, 0.6);
        const darkColor = shadeColor(color, -0.6);
        const grad = offscreenCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, half);
        grad.addColorStop(0, lightColor);
        grad.addColorStop(1, color);
        
        offscreenCtx.fillStyle = grad;
        offscreenCtx.beginPath();
        offscreenCtx.moveTo(centerX, centerY - half); 
        offscreenCtx.lineTo(centerX + half, centerY); 
        offscreenCtx.lineTo(centerX, centerY + half); 
        offscreenCtx.lineTo(centerX - half, centerY);
        offscreenCtx.closePath();
        offscreenCtx.fill();
        
        offscreenCtx.strokeStyle = darkColor;
        offscreenCtx.lineWidth = 2;
        offscreenCtx.stroke();

        return offscreenCanvas;
    }

    function renderSpecialCanvas(special, color, size) {
        const canvas = renderGemCanvas(color, size);
        const ctx = canvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;

        ctx.fillStyle = 'white';
        ctx.shadowColor = 'white';
        ctx.shadowBlur = 10;

        if(special === SPECIAL_TYPES.H_BEAM) {
            ctx.fillRect(centerX - half, centerY - half * 0.1, s, half * 0.2);
        } else if (special === SPECIAL_TYPES.V_BEAM) {
            ctx.fillRect(centerX - half * 0.1, centerY - half, half * 0.2, s);
        } else if (special === SPECIAL_TYPES.BOMB) {
            ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, half * 0.6, 0, 2 * Math.PI);
            ctx.fill();
        }
        return canvas;
    }

    function renderHypercubeCanvas(size) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = size;
        offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;

        offscreenCtx.shadowColor = 'rgba(255, 255, 255, 0.7)';
        offscreenCtx.shadowBlur = 10;

        for (let i = 0; i < 6; i++) {
            offscreenCtx.fillStyle = CONFIG.GEM_COLORS[i];
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(centerX,centerY);
            const angle1 = (i / 6) * 2 * Math.PI;
            const angle2 = ((i+1) / 6) * 2 * Math.PI;
            offscreenCtx.arc(centerX,centerY, half, angle1, angle2);
            offscreenCtx.closePath();
            offscreenCtx.fill();
        }
        return offscreenCanvas;
    }

    function renderChainCanvas(size) {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const p = size * 0.1; // padding
        const lw = size * 0.08; // line width
        ctx.strokeStyle = 'rgba(200, 200, 220, 0.7)';
        ctx.lineWidth = lw;
        ctx.lineCap = 'round';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 4;

        // Draw chain links
        ctx.beginPath();
        ctx.moveTo(p, p);
        ctx.lineTo(size - p, size - p);
        ctx.moveTo(size - p, p);
        ctx.lineTo(p, size - p);
        ctx.stroke();
        return canvas;
    }

    // =========================================================================
    // --- MODULE: CORE GAME LOGIC ---
    // =========================================================================

    async function processSwap(gem1, gem2) {
        if (gem1.isLocked || gem2.isLocked) return;
        isAnimating = true;
        selectedGem = null;
        try {
            const startPos1 = { row: gem1.row, col: gem1.col };
            const startPos2 = { row: gem2.row, col: gem2.col };
            if (gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE) {
                moves++;
                updateMoves();
                const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
                const otherGem = hypercube === gem1 ? gem2 : gem1;
                await triggerHypercube(hypercube, otherGem);
            } else {
                await swapGems(gem1, gem2);
                const matchInfo = findMatchesAndSpecial(startPos1, startPos2);
                if (matchInfo.allMatches.length > 0) {
                    moves++;
                    updateMoves();
                    await cascadeMatches(matchInfo.allMatches, matchInfo.specialToCreate);
                } else {
                    await sleep(100);
                    await swapGems(gem1, gem2);
                }
            }
            if (gameOverModal.classList.contains('hidden') && winModal.classList.contains('hidden') && finalWinModal.classList.contains('hidden')) {
                await moveCigarette();
                if (checkGameOver()) {
                    return;
                }
                spawnHeartIfNeeded();
                checkWinCondition();
                 if (currentLevel >= CONFIG.COUGH_START_LEVEL && moves > 0 && moves % CONFIG.COUGH_INTERVAL_MOVES === 0) {
                    await triggerCough();
                }
                if (!hasPossibleMoves(board)) {
                    await reshuffleBoard();
                }
            }
        } finally {
            isAnimating = false;
            resetHintTimer();
        }
    }

    async function cascadeMatches(initialMatches, specialToCreate = null) {
        let gemsToClear = new Set(initialMatches);
        let processedSpecials = new Set();
        
        while (true) {
            let newGemsFromExplosion = new Set();
            let foundNewExplosion = false;
            for (const gem of gemsToClear) {
                if (gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                    foundNewExplosion = true;
                    processedSpecials.add(gem);
                    switch (gem.special) {
                        case SPECIAL_TYPES.H_BEAM:
                        case SPECIAL_TYPES.V_BEAM: AudioManager.play('beamSound'); break;
                        case SPECIAL_TYPES.BOMB: AudioManager.play('bombSound'); break;
                    }
                    getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                }
            }
            if (!foundNewExplosion) break;
            newGemsFromExplosion.forEach(g => gemsToClear.add(g));
        }

        const savedAHeart = await handleMatches(Array.from(gemsToClear), specialToCreate);
        await sleep(150);
        await shiftAndRefill();
        
        if (savedAHeart) {
            await showFact();
        }

        const matchGroups = findMatches(board, true);
        if (matchGroups.length > 0) {
            const nextMatches = [...new Set(matchGroups.flat())];
            const newSpecialToCreate = findSpecialFromCascade(matchGroups);
            await cascadeMatches(nextMatches, newSpecialToCreate);
        } else {
            const heartsMoved = await moveHearts();
            if (heartsMoved) {
                const newMatchesFromHeartsGroups = findMatches(board, true);
                 if (newMatchesFromHeartsGroups.length > 0) {
                    const newMatchesFromHearts = [...new Set(newMatchesFromHeartsGroups.flat())];
                    const newSpecialToCreate = findSpecialFromCascade(newMatchesFromHeartsGroups);
                    await cascadeMatches(newMatchesFromHearts, newSpecialToCreate);
                }
            }
        }
    }

    async function handleMatches(matches, specialToCreate) {
        if (matches.length > 0) {
            AudioManager.play('matchSound', { intensity: matches.length });
        }
        const promises = [];
        let heartSaved = false;
        let collectedForQuest = {};
        
        // --- LOGIC M·ªû KH√ìA ---
        let unlockedGems = new Set();
        matches.forEach(gem => {
            const { row, col } = gem;
            const neighbors = [
                { r: row - 1, c: col }, { r: row + 1, c: col },
                { r: row, c: col - 1 }, { r: row, c: col + 1 },
            ];
            neighbors.forEach(n => {
                if (n.r >= 0 && n.r < CONFIG.GRID_SIZE && n.c >= 0 && n.c < CONFIG.GRID_SIZE) {
                    const neighborGem = board[n.r][n.c];
                    if (neighborGem && neighborGem.isLocked) {
                        unlockedGems.add(neighborGem);
                    }
                }
            });
        });

        unlockedGems.forEach(gem => {
            gem.isLocked = false;
            promises.push(
                animate(gem, { scale: 1.2 }, 100).then(() => animate(gem, { scale: 1 }, 100))
            );
        });
        if (unlockedGems.size > 0) {
            AudioManager.play('unlockSound');
        }
        // --- K·∫æT TH√öC LOGIC M·ªû KH√ìA ---

        matches.forEach(gem => {
            if (specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) return;
            if (gem.isHeart) {
                score++;
                quest.heartsSaved++;
                updateScore();
                heartSaved = true;
            }
            const colorIdx = gem.colorIndex;
            if (quest.targets[colorIdx] !== undefined) {
                collectedForQuest[colorIdx] = (collectedForQuest[colorIdx] || 0) + 1;
            }
            createParticleBurst(gem.x + gemSize / 2, gem.y + gemSize / 2, CONFIG.GEM_COLORS[gem.colorIndex]);
            
            promises.push(new Promise(async (resolve) => {
                if (gem) {
                    await animate(gem, { scale: 0, alpha: 0 }, CONFIG.ANIM_CLEAR_SPEED, easing.easeInQuad)
                        .catch(console.error);
                    if (board[gem.row]) {
                        board[gem.row][gem.col] = null;
                    }
                }
                resolve();
            }));
        });
        await Promise.all(promises);
        updateQuestProgress(collectedForQuest);
        updateQuestUI();
        
        if (specialToCreate) {
            let gem = board[specialToCreate.row] && board[specialToCreate.row][specialToCreate.col];
            if (!gem) {
                gem = {
                    row: specialToCreate.row,
                    col: specialToCreate.col,
                    x: specialToCreate.col * gemSize,
                    y: specialToCreate.row * gemSize,
                    colorIndex: (specialToCreate.colorIndex !== undefined) ? specialToCreate.colorIndex : Math.floor(Math.random() * CONFIG.GEM_COLORS.length),
                    isHeart: false,
                    isLocked: false,
                    special: SPECIAL_TYPES.NONE,
                    scale: 0,
                    alpha: 1
                };
                board[specialToCreate.row][specialToCreate.col] = gem;
            }
            gem.special = specialToCreate.special;
            if (specialToCreate.special !== SPECIAL_TYPES.HYPERCUBE) gem.colorIndex = specialToCreate.colorIndex;
            gem.isHeart = false;
            await animate(gem, { scale: 1.5 }, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad)
              .then(() => animate(gem, { scale: 1 }, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad));
        }

        return heartSaved;
    }

    function findMatches(currentBoard, returnGroups = false) {
        const matches = new Set();
        const groups = [];

        // Horizontal matches
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE - 2;) {
                const gem = currentBoard[r][c];
                if (gem) {
                    let match = [gem];
                    for (let i = c + 1; i < CONFIG.GRID_SIZE; i++) {
                        const nextGem = currentBoard[r][i];
                        if (nextGem && nextGem.colorIndex === gem.colorIndex) {
                            match.push(nextGem);
                        } else { break; }
                    }
                    if (match.length >= 3) {
                        match.forEach(m => matches.add(m));
                        if (returnGroups) groups.push(match);
                    }
                    c += match.length > 1 ? match.length : 1;
                } else { c++; }
            }
        }

        // Vertical matches
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            for (let r = 0; r < CONFIG.GRID_SIZE - 2;) {
                const gem = currentBoard[r][c];
                if (gem) {
                    let match = [gem];
                    for (let i = r + 1; i < CONFIG.GRID_SIZE; i++) {
                        const nextGem = currentBoard[i][c];
                        if (nextGem && nextGem.colorIndex === gem.colorIndex) {
                            match.push(nextGem);
                        } else { break; }
                    }
                    if (match.length >= 3) {
                        match.forEach(m => matches.add(m));
                        if (returnGroups) groups.push(match);
                    }
                    r += match.length > 1 ? match.length : 1;
                } else { r++; }
            }
        }
        return returnGroups ? groups : Array.from(matches);
    }
    
    function findSpecialFromCascade(matchGroups) {
        let bestSpecial = null;
        let bestRank = 0; // 1: beam, 2: bomb, 3: hypercube
        let processedInGroups = new Set();

        // Rank 3: Hypercubes (line of 5)
        for (const group of matchGroups) {
            if (group.length >= 5) {
                const middleGem = group[Math.floor(group.length / 2)];
                if (processedInGroups.has(middleGem)) continue;

                bestRank = 3;
                bestSpecial = {
                    special: SPECIAL_TYPES.HYPERCUBE,
                    colorIndex: middleGem.colorIndex,
                    row: middleGem.row,
                    col: middleGem.col
                };
                group.forEach(g => processedInGroups.add(g));
                return bestSpecial; // Found the best, return immediately
            }
        }

        // Rank 2: Bombs (L/T shapes)
        for (let i = 0; i < matchGroups.length; i++) {
            for (let j = i + 1; j < matchGroups.length; j++) {
                const group1 = matchGroups[i];
                const group2 = matchGroups[j];
                const intersection = group1.find(gem1 => group2.some(gem2 => gem1 === gem2));

                if (intersection && !processedInGroups.has(intersection)) {
                    if (bestRank < 2) {
                        bestRank = 2;
                        bestSpecial = {
                            special: SPECIAL_TYPES.BOMB,
                            colorIndex: intersection.colorIndex,
                            row: intersection.row,
                            col: intersection.col
                        };
                        group1.forEach(g => processedInGroups.add(g));
                        group2.forEach(g => processedInGroups.add(g));
                    }
                }
            }
        }

        // Rank 1: Beams (line of 4)
        if (bestRank < 2) { // Only check for beams if no bomb was found
            for (const group of matchGroups) {
                if (group.length === 4) {
                    const gemToReplace = group[1]; // Arbitrary choice
                    if (processedInGroups.has(gemToReplace)) continue;
                    
                    if (bestRank < 1) {
                        bestRank = 1;
                        const isHorizontal = group[0].row === group[1].row;
                        bestSpecial = {
                            special: isHorizontal ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM,
                            colorIndex: gemToReplace.colorIndex,
                            row: gemToReplace.row,
                            col: gemToReplace.col
                        };
                        group.forEach(g => processedInGroups.add(g));
                    }
                }
            }
        }
        
        return bestSpecial;
    }


    function findMatchesAndSpecial(startPos1, startPos2) {
        const allMatches = new Set();
        const checkLine = (line) => {
            const res = [];
            for (let i = 0; i < line.length - 2; i++) {
                const g = line[i];
                if (!g) continue;
                let len = 1;
                while (i + len < line.length && line[i + len] && line[i + len].colorIndex === g.colorIndex) len++;
                if (len >= 3) {
                    const matchGroup = line.slice(i, i + len);
                    res.push(matchGroup);
                    i += len - 1;
                }
            }
            return res;
        };
        const h1 = checkLine(board[startPos1.row] || []);
        const v1 = checkLine(board.map(r => r[startPos1.col]) || []);
        const h2 = checkLine(board[startPos2.row] || []);
        const v2 = checkLine(board.map(r => r[startPos2.col]) || []);
        const groups = [h1, v1, h2, v2];
        for (const gArr of groups) {
            for (const match of gArr) {
                for (const gem of match) { allMatches.add(gem); }
            }
        }
        
        let specialToCreate = null;
        const matchesArray = Array.from(allMatches);

        let intersectionGem = null;
        const movedGem = board[startPos1.row][startPos1.col];
        const otherGem = board[startPos2.row][startPos2.col];
        const checkGems = [movedGem, otherGem];

        for (const gem of checkGems) {
            if (!gem || !matchesArray.includes(gem)) continue;

            const horizontalMatch = matchesArray.filter(g => g.row === gem.row && g.colorIndex === gem.colorIndex);
            const verticalMatch = matchesArray.filter(g => g.col === gem.col && g.colorIndex === gem.colorIndex);

            if (horizontalMatch.length >= 3 && verticalMatch.length >= 3) {
                intersectionGem = gem;
                break;
            }
        }

        if (intersectionGem) {
            specialToCreate = {
                special: SPECIAL_TYPES.BOMB,
                colorIndex: intersectionGem.colorIndex,
                row: intersectionGem.row,
                col: intersectionGem.col
            };
        } else {
            const allLineMatches = [...h1, ...v1, ...h2, ...v2].filter(match => match.some(g => g === movedGem || g === otherGem));
            allLineMatches.sort((a, b) => b.length - a.length);

            if (allLineMatches.length > 0) {
                const longestMatch = allLineMatches[0];
                const pivotGem = longestMatch.includes(movedGem) ? movedGem : otherGem;
                
                if (longestMatch.length >= 5) {
                    specialToCreate = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: pivotGem.colorIndex, row: pivotGem.row, col: pivotGem.col };
                } else if (longestMatch.length === 4) {
                    const isHorizontal = longestMatch[0].row === longestMatch[1].row;
                    specialToCreate = {
                        special: isHorizontal ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM,
                        colorIndex: pivotGem.colorIndex,
                        row: pivotGem.row,
                        col: pivotGem.col
                    };
                }
            }
        }

        return { allMatches: matchesArray, specialToCreate };
    }

    async function shiftAndRefill() {
        const shiftPromises = [];
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            let emptySlots = 0;
            for (let r = CONFIG.GRID_SIZE - 1; r >= 0; r--) {
                if (board[r][c] === null) {
                    emptySlots++;
                } else if (emptySlots > 0) {
                    const gem = board[r][c];
                    board[r + emptySlots][c] = gem;
                    board[r][c] = null;
                    gem.row += emptySlots;
                    shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300, easing.easeOutQuad));
                }
            }
        }
        await Promise.all(shiftPromises);
        const refillPromises = [];
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
                if (board[r][c] === null) {
                    const newGem = {
                        colorIndex: Math.floor(Math.random() * CONFIG.GEM_COLORS.length),
                        isHeart: false,
                        isLocked: false,
                        special: SPECIAL_TYPES.NONE,
                        row: r, col: c,
                        x: c * gemSize, y: (r - CONFIG.GRID_SIZE) * gemSize,
                        scale: 1, alpha: 1,
                    };
                    if (currentLevel >= 1 && isFreePlayMode && Math.random() < 0.05 * Math.min(currentLevel, 4)) {
                        newGem.isLocked = true;
                    }
                    board[r][c] = newGem;
                    refillPromises.push(animate(newGem, { y: r * gemSize }, CONFIG.ANIM_FALL_SPEED, easing.easeOutQuad));
                }
            }
        }
        await Promise.all(refillPromises);
    }

    async function reshuffleBoard() {
        isAnimating = true;
        const promises = [];
        board.flat().forEach(gem => {
            if (gem) { promises.push(animate(gem, { alpha: 0, scale: 0 }, 300)); }
        });
        await Promise.all(promises);
        let attempts = 0;
        do {
            createBoard();
            attempts++;
            if (attempts > 100) { console.error("Could not generate a board with possible moves."); break; }
        } while (!hasPossibleMoves(board));
        const refillPromises = [];
        board.flat().forEach(gem => {
            if (gem) {
                gem.alpha = 0; gem.scale = 0;
                refillPromises.push(animate(gem, { alpha: 1, scale: 1 }, 300));
            }
        });
        await Promise.all(refillPromises);
        isAnimating = false;
        resetHintTimer();
    }

    function checkWinCondition() {
        const objectivesMet = quest.totalDamage >= quest.maxDamage && quest.heartsSaved >= quest.heartsToSave;

        if (objectivesMet) {
            if (isFreePlayMode) {
                goToNextLevel(true); 
            } else {
                AudioManager.setMasterVolume(-12);
                isAnimating = true;
                isPaused = true;
                if (threatInterval) clearInterval(threatInterval);
                if (currentLevel >= CONFIG.FINAL_LEVEL) {
                    showModal(finalWinModal, restartGameButton);
                } else {
                    winLevelText.textContent = `B·∫°n ƒë√£ ho√†n th√†nh m√†n ${currentLevel}!`;
                    showModal(winModal, nextLevelButton);
                }
            }
        }
    }


    // =========================================================================
    // --- MODULE: EVENT HANDLERS ---
    // =========================================================================

    function handlePointerStart(e) {
        e.preventDefault();
        if (isAnimating || isPaused) return;
        resetHintTimer();
        hintGems = [];
        const pos = getEventPos(e);
        const col = Math.floor(pos.x / gemSize);
        const row = Math.floor(pos.y / gemSize);
        if (row < 0 || row >= CONFIG.GRID_SIZE || col < 0 || col >= CONFIG.GRID_SIZE) {
            selectedGem = null;
            return;
        }
        const clickedGem = board[row][col];
        if (clickedGem.isLocked) {
            AudioManager.play('unlockSound'); // Play a sound to indicate it's locked
            return;
        }
        isDragging = true;
        startDragPos = pos;
        startGem = clickedGem;
        if (selectedGem) {
            if (selectedGem === clickedGem) {
                selectedGem = null;
                return;
            }
            const isAdjacent = Math.abs(selectedGem.row - clickedGem.row) + Math.abs(selectedGem.col - clickedGem.col) === 1;
            if (isAdjacent) {
                processSwap(selectedGem, clickedGem);
            } else {
                AudioManager.play('selectSound');
                selectedGem = clickedGem;
            }
        } else {
            AudioManager.play('selectSound');
            selectedGem = clickedGem;
        }
    }

    function handlePointerMove(e) {
        e.preventDefault();
        if (!isDragging || isAnimating || isPaused) return;
        const pos = getEventPos(e);
        const deltaX = pos.x - startDragPos.x;
        const deltaY = pos.y - startDragPos.y;
        if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) {
            let endGem = null;
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                const endCol = startGem.col + (deltaX > 0 ? 1 : -1);
                if (endCol >= 0 && endCol < CONFIG.GRID_SIZE) {
                    endGem = board[startGem.row][endCol];
                }
            } else {
                const endRow = startGem.row + (deltaY > 0 ? 1 : -1);
                if (endRow >= 0 && endRow < CONFIG.GRID_SIZE) {
                    endGem = board[endRow][startGem.col];
                }
            }
            if (endGem && !endGem.isLocked && startGem !== endGem) {
                isDragging = false;
                selectedGem = null;
                processSwap(startGem, endGem);
            }
        }
    }

    function handlePointerEnd(e) {
        isDragging = false;
        startGem = null;
    }

    // =========================================================================
    // --- MODULE: ANIMATION SYSTEM ---
    // =========================================================================

    const easing = {
        easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
        easeInQuad: t => t * t,
        easeOutQuad: t => t * (2 - t)
    };

    function animate(target, toProperties, duration, easeFunc = easing.easeInOutQuad) {
        return new Promise(resolve => {
            const startProps = {};
            const endProps = {};
            for (const key in toProperties) {
                const cur = typeof target[key] === 'number' && !isNaN(target[key]) ? target[key] : 0;
                startProps[key] = cur;
                endProps[key] = Number(toProperties[key]);
            }
            animations.push({
                target, startProperties: startProps, endProperties: endProps,
                duration, easeFunc, startTime: performance.now(), onComplete: resolve
            });
        });
    }

    function handleAnimations() {
        const now = performance.now();
        for (let i = animations.length - 1; i >= 0; i--) {
            const anim = animations[i];
            const elapsed = now - (anim.startTime || now);
            const duration = Number(anim.duration) || 0;
            const t = duration > 0 ? Math.min(elapsed / duration, 1) : 1;
            const progress = (typeof anim.easeFunc === 'function') ? anim.easeFunc(t) : t;

            if (t >= 1) {
                for (const key in anim.endProperties) {
                    if (anim.target) anim.target[key] = anim.endProperties[key];
                }
                try {
                    if (anim.onComplete) anim.onComplete();
                } catch (err) {
                    console.error('Error in animation onComplete:', err);
                }
                animations.splice(i, 1);
            } else {
                for (const key in anim.endProperties) {
                    if (anim.target) {
                        const start = anim.startProperties[key] || 0;
                        const end = anim.endProperties[key];
                        anim.target[key] = start + (end - start) * progress;
                    }
                }
            }
        }
    }

    // =========================================================================
    // --- MODULE: INITIALIZATION & HELPERS ---
    // =========================================================================

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    function updateFullscreenIcons() {
        const fullscreenIconOpen = document.getElementById('fullscreen-icon-open');
        const fullscreenIconClose = document.getElementById('fullscreen-icon-close');
        if (document.fullscreenElement) {
            fullscreenIconOpen.classList.add('hidden');
            fullscreenIconClose.classList.remove('hidden');
        } else {
            fullscreenIconOpen.classList.remove('hidden');
            fullscreenIconClose.classList.add('hidden');
        }
    }
    
    function trackPupil(pupilElement, e) {
        const svgRect = characterContainerEl.getBoundingClientRect();
        const pupilData = {
            cx: parseFloat(pupilElement.getAttribute('cx')),
            cy: parseFloat(pupilElement.getAttribute('cy'))
        };
        const pupilX = svgRect.left + (pupilData.cx / 200) * svgRect.width;
        const pupilY = svgRect.top + (pupilData.cy / 100) * svgRect.height;
        const angle = Math.atan2(e.clientY - pupilY, e.clientX - pupilX);
        const maxMove = 4;
        const moveX = Math.cos(angle) * maxMove;
        const moveY = Math.sin(angle) * maxMove;
        pupilElement.style.transform = `translate(${moveX}px, ${moveY}px)`;
    }

    function getParticle() {
        for (let i = 0; i < particlePool.length; i++) {
            if (!particlePool[i].active) return particlePool[i];
        }
        return null;
    }

    function createParticleBurst(x, y, color) {
        for (let i = 0; i < 10; i++) {
            const p = getParticle();
            if (p) {
                p.active = true; p.x = x; p.y = y;
                p.vx = (Math.random() - 0.5) * 6;
                p.vy = (Math.random() - 0.5) * 6;
                p.size = Math.random() * 4 + 2;
                p.color = color; p.alpha = 1;
            }
        }
    }

    function setupLevel(level) {
        currentLevel = level;
        levelEl.textContent = level;
        const baseRequirement = 15 + (level - 1) * 8;
        const numTargets = Math.min(2 + Math.floor(level / 2), 5);
        quest = {
            targets: {}, collected: {}, totalDamage: 0,
            maxDamage: 0, heartsToSave: level, heartsSaved: 0
        };
        let availableColors = Array.from({ length: CONFIG.GEM_COLORS.length }, (_, i) => i);
        for (let i = 0; i < numTargets; i++) {
            if (availableColors.length === 0) break;
            const colorIndex = availableColors.splice(Math.floor(Math.random() * availableColors.length), 1)[0];
            const requirement = Math.floor(baseRequirement * (Math.random() * 0.4 + 0.8));
            quest.targets[colorIndex] = requirement;
            quest.collected[colorIndex] = 0;
            quest.maxDamage += requirement;
        }
        updateQuestUI();
        updateHealthBar();
    }

    async function resizeCanvas() {
        const container = document.getElementById('game-container');
        const containerWidth = container.clientWidth;
        const dpr = window.devicePixelRatio || 1;

        canvas.style.width = containerWidth + 'px';
        canvas.style.height = containerWidth + 'px';

        canvas.width = Math.floor(containerWidth * dpr);
        canvas.height = Math.floor(containerWidth * dpr);

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        gemSize = containerWidth / CONFIG.GRID_SIZE;
        
        await preRenderGems();

        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if(board[r] && board[r][c]) {
                    board[r][c].x = c * gemSize;
                    board[r][c].y = r * gemSize;
                }
            }
        }
        updateCigarettePosition();
    }
    
    function onResizeDebounced() {
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            resizeCanvas();
        }, 150);
    }
    
    function updateCigarettePosition(col = cigarette.col, isLunging = false) {
        const columnCenter = (col * gemSize) + (gemSize / 2);
        const svgScaledWidth = 200 * 0.7;
        const translateX = columnCenter - (svgScaledWidth / 2);

        let scale = 0.7;
        let rotate = 0;
        let translateY = 0;
        
        if (isLunging) {
            scale = 0.8;
            translateY = 10;
        } else if (characterContainerEl.classList.contains('attacking')) {
            scale = 0.8;
            rotate = -5;
        }

        characterContainerEl.style.transform = `translateX(${translateX}px) translateY(${translateY}px) scale(${scale}) rotate(${rotate}deg)`;
    }

    function createBoard() {
        board = [];
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            board[row] = [];
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                let possibleColors = Array.from({ length: CONFIG.GEM_COLORS.length }, (_, i) => i);
                
                if (col >= 2 && board[row][col-1].colorIndex === board[row][col-2].colorIndex) {
                    const colorToRemove = board[row][col-1].colorIndex;
                    possibleColors = possibleColors.filter(c => c !== colorToRemove);
                }

                if (row >= 2 && board[row-1][col].colorIndex === board[row-2][col].colorIndex) {
                    const colorToRemove = board[row-1][col].colorIndex;
                    possibleColors = possibleColors.filter(c => c !== colorToRemove);
                }

                const colorIndex = possibleColors[Math.floor(Math.random() * possibleColors.length)];

                board[row][col] = {
                    colorIndex: colorIndex,
                    isHeart: false,
                    isLocked: false,
                    special: SPECIAL_TYPES.NONE,
                    row: row,
                    col: col,
                    x: col * gemSize,
                    y: row * gemSize,
                    scale: 1,
                    alpha: 1,
                };
            }
        }
    }

    function swapGems(gem1, gem2) {
        const r1 = gem1.row, c1 = gem1.col;
        const r2 = gem2.row, c2 = gem2.col;
        board[r1][c1] = gem2;
        board[r2][c2] = gem1;
        gem1.row = r2; gem1.col = c2;
        gem2.row = r1; gem2.col = c1;
        const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad);
        const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad);
        return Promise.all([p1, p2]);
    }

    function getSpecialEffectGems(gem) {
        let affected = new Set();
        if (gem.special === SPECIAL_TYPES.H_BEAM) {
            for(let c=0; c<CONFIG.GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); }
        } else if (gem.special === SPECIAL_TYPES.V_BEAM) {
            for(let r=0; r<CONFIG.GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); }
        } else if (gem.special === SPECIAL_TYPES.BOMB) {
            for(let r = gem.row - 1; r <= gem.row + 1; r++) {
                for(let c = gem.col - 1; c <= gem.col + 1; c++) {
                    if(r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) {
                        affected.add(board[r][c]);
                    }
                }
            }
        }
        return affected;
    }

    async function triggerHypercube(hypercube, otherGem) {
        let gemsToClear = new Set([hypercube]);
        AudioManager.play('hypercubeSound');
        
        if (otherGem.special === SPECIAL_TYPES.NONE) {
            const targetColorIndex = otherGem.colorIndex;
            board.flat().filter(g => g && g.colorIndex === targetColorIndex).forEach(g => gemsToClear.add(g));
        } 
        else if (otherGem.special && otherGem.special !== SPECIAL_TYPES.HYPERCUBE) {
            board.flat().filter(g => g && !g.isHeart && g.colorIndex === otherGem.colorIndex)
              .forEach(g => {
                 if (g.special === SPECIAL_TYPES.NONE) g.special = otherGem.special;
                 gemsToClear.add(g);
              });
        }
        else { // Hypercube + Hypercube
            board.flat().forEach(g => { if(g) gemsToClear.add(g) });
        }
        await cascadeMatches(Array.from(gemsToClear));
    }

    function spawnHeartIfNeeded(isFirst = false) {
         if (isFirst || (moves > 0 && moves % CONFIG.MOVES_PER_HEART_SPAWN === 0)) {
            let availableCols = [];
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if (board[CONFIG.GRID_SIZE - 1][c] && !board[CONFIG.GRID_SIZE - 1][c].isHeart && board[CONFIG.GRID_SIZE - 1][c].special === SPECIAL_TYPES.NONE) {
                    availableCols.push(c);
                }
            }
            if (availableCols.length > 0) {
                const col = availableCols[Math.floor(Math.random() * availableCols.length)];
                const gem = board[CONFIG.GRID_SIZE - 1][col];
                gem.isHeart = true;
                gem.special = SPECIAL_TYPES.NONE;
                animate(gem, {scale: 1.5}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad)
                    .then(() => animate(gem, {scale: 1}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad));
            }
        }
    }

    async function moveHearts() {
        const movePromises = [];
        let movedGems = new Set();
        let heartsDidMove = false;

        for (let r = 1; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                const gem = board[r][c];
                if (gem && gem.isHeart && !movedGems.has(gem)) {
                    const gemAbove = board[r - 1][c];
                    if (gemAbove && !gemAbove.isHeart) {
                        heartsDidMove = true;
                        board[r - 1][c] = gem;
                        board[r][c] = gemAbove;
                        
                        gem.row = r - 1;
                        gemAbove.row = r;
                        
                        movePromises.push(animate(gem, { y: gem.row * gemSize }, 200, easing.easeInOutQuad));
                        movePromises.push(animate(gemAbove, { y: gemAbove.row * gemSize }, 200, easing.easeInOutQuad));
                        
                        movedGems.add(gem);
                        movedGems.add(gemAbove);
                    }
                }
            }
        }
        await Promise.all(movePromises);
        return heartsDidMove;
    }

    async function moveCigarette() {
        let highestHeart = null;
        let minRow = CONFIG.GRID_SIZE;

        board.flat().filter(g => g && g.isHeart).forEach(g => {
            if (g.row < minRow) {
                minRow = g.row;
                highestHeart = g;
            }
        });

        if (highestHeart) {
            if (Math.random() < CONFIG.CIGARETTE_LUNGE_CHANCE) {
                const originalCol = cigarette.col;
                const targetCol = highestHeart.col;
                
                updateCigarettePosition(targetCol, true);
                await sleep(150);
                updateCigarettePosition(originalCol);
                await sleep(400);
            }

            if (cigarette.col < highestHeart.col) cigarette.col++;
            else if (cigarette.col > highestHeart.col) cigarette.col--;
        }
        updateCigarettePosition();
    }

    function checkGameOver() {
        if(board[0][cigarette.col] && board[0][cigarette.col].isHeart) {
            showGameOver();
            return true;
        }
        return false;
    }

    function updateQuestProgress(collected) {
        for (const key in collected) {
            const colorIdx = parseInt(key, 10);
            const amount = collected[key];
            if (!quest.targets.hasOwnProperty(colorIdx)) continue;

            const before = quest.collected[colorIdx] || 0;
            const remaining = Math.max(0, quest.targets[colorIdx] - before);
            const used = Math.min(remaining, amount);
            
            quest.collected[colorIdx] += used;
            quest.totalDamage += used;
        }
        updateHealthBar();
    }

    function goToNextLevel(isFreeModeLevelUp = false) {
        if (!isFreeModeLevelUp) {
            hideModal(winModal);
            AudioManager.setMasterVolume(-9);
        }
        isAnimating = false;
        isPaused = false;
        setupLevel(currentLevel + 1);
        moves = 0; updateMoves();
        
        if (!isFreeModeLevelUp) {
            do {
                createBoard();
            } while(!hasPossibleMoves(board));
            spawnHeartIfNeeded(true);
        }
        
        if (threatInterval) clearInterval(threatInterval);
        threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL);
    }

    function hasPossibleMoves(currentBoard) {
      for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
          if (c < CONFIG.GRID_SIZE - 1) {
            [currentBoard[r][c], currentBoard[r][c+1]] = [currentBoard[r][c+1], currentBoard[r][c]];
            const matches = findMatches(currentBoard);
            [currentBoard[r][c], currentBoard[r][c+1]] = [currentBoard[r][c+1], currentBoard[r][c]];
            if (matches.length > 0) return true;
          }
          if (r < CONFIG.GRID_SIZE - 1) {
            [currentBoard[r][c], currentBoard[r+1][c]] = [currentBoard[r+1][c], currentBoard[r][c]];
            const matches = findMatches(currentBoard);
            [currentBoard[r][c], currentBoard[r+1][c]] = [currentBoard[r+1][c], currentBoard[r][c]];
            if (matches.length > 0) return true;
          }
        }
      }
      return false;
    }

    function findFirstPossibleMove() {
      for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
          if (c < CONFIG.GRID_SIZE - 1) {
            [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
            const matches = findMatches(board);
            [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
            if (matches.length > 0) return { gem1: board[r][c], gem2: board[r][c+1] };
          }
          if (r < CONFIG.GRID_SIZE - 1) {
            [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
            const matches = findMatches(board);
            [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
            if (matches.length > 0) return { gem1: board[r][c], gem2: board[r+1][c] };
          }
        }
      }
      return null;
    }

    function resetHintTimer() {
        if (hintTimeout) clearTimeout(hintTimeout);
        hintGems = [];
        hintTimeout = setTimeout(() => {
            if (!isAnimating && !isPaused) {
                const move = findFirstPossibleMove();
                if (move) {
                    hintGems = [move.gem1, move.gem2];
                }
            }
        }, CONFIG.HINT_TIMEOUT);
    }
    
    function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    async function init() {
        await resizeCanvas();
        ctx.font = `${gemSize * 0.7}px sans-serif`;
        
        cigarette.col = Math.floor(CONFIG.GRID_SIZE / 2);
        score = 0; 
        moves = 0;
        setupLevel(1);
        do {
            createBoard();
        } while (!hasPossibleMoves(board));
        spawnHeartIfNeeded(true);

        updateCigarettePosition();
        selectedGem = null; isAnimating = false; isPaused = false;
        animations = []; particles = [];
        particlePool = [];
        for (let i = 0; i < CONFIG.MAX_PARTICLES; i++) {
            particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', alpha: 0 });
        }
        factsShown = [];
        if (threatInterval) clearInterval(threatInterval);
        threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL);
        updateScore();
        updateMoves();
        updateQuestUI();
        updateHealthBar();
        levelEl.textContent = currentLevel;

        requestAnimationFrame(gameLoop);
        resetHintTimer();
    }

    function gameLoop(time) {
        requestAnimationFrame(gameLoop);
        handleAnimations(time);

        if (isPaused || currentModal) {
            return;
        }
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard(time);
        drawParticles();
        drawSelection(time);
        drawHint(time);
    }
    
    window.addEventListener('DOMContentLoaded', () => {
        let currentTutorialStep = 0;
        const backToIndexButton = document.getElementById('backToIndexButton');
        const continueToNextGameButton = document.getElementById('continueToNextGameButton');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const gameOverHomeButton = document.getElementById('gameOverHomeButton');
        const gameOverRestartButton = document.getElementById('gameOverRestartButton');

        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', toggleFullScreen);
            document.addEventListener('fullscreenchange', updateFullscreenIcons);
        }
        if (backToIndexButton) { backToIndexButton.addEventListener('click', () => { window.location.href = 'index.html'; }); }
        if (continueToNextGameButton) { continueToNextGameButton.addEventListener('click', () => { window.location.href = 'kimcuongquatraloicauhoi.html'; }); }
        if (gameOverHomeButton) { gameOverHomeButton.addEventListener('click', () => { window.location.href = 'index.html'; }); }
        if (gameOverRestartButton) { gameOverRestartButton.addEventListener('click', () => { location.reload(); }); }
        
        nextLevelButton.addEventListener('click', () => {
            goToNextLevel(false);
        });

        restartGameButton.addEventListener('click', () => { location.reload(); });

        function showTutorialStep(index) {
            tutorialSteps.forEach((step, i) => { step.classList.toggle('hidden', i !== index); });
        }
        function startGame(finalLevel, isFree = false) {
            CONFIG.FINAL_LEVEL = finalLevel;
            isFreePlayMode = isFree;
            
            const objectivePanel = document.getElementById('objective-panel');
            objectivePanel.style.visibility = 'visible';

            startScreen.style.display = 'none';
            tutorialModal.classList.remove('hidden');
            showTutorialStep(0);
        }
        
        easyModeBtn.addEventListener('click', () => startGame(1, false));
        hardModeBtn.addEventListener('click', () => startGame(3, false));
        freeModeBtn.addEventListener('click', () => startGame(Infinity, true));

        const isTouch = window.matchMedia('(pointer: coarse)').matches;
        if (isTouch) {
            document.body.style.cursor = 'auto';
            customCursor.style.display = 'none';
            canvas.style.cursor = 'auto';
        } else {
            document.body.style.cursor = 'none';
            customCursor.style.display = 'block';
            canvas.style.cursor = 'none';
            let rafScheduled = false;
            let lastMouseEvent = null;
            document.addEventListener('mousemove', (e) => {
                lastMouseEvent = e;
                if (!rafScheduled) {
                    rafScheduled = true;
                    requestAnimationFrame(() => {
                        if (lastMouseEvent) {
                            customCursor.style.left = lastMouseEvent.clientX + 'px';
                            customCursor.style.top = lastMouseEvent.clientY + 'px';
                            if (startScreen.style.display === 'none') {
                                trackPupil(pupil1, lastMouseEvent);
                                trackPupil(pupil2, lastMouseEvent);
                            }
                        }
                        rafScheduled = false;
                    });
                }
            });
        }
        tutorialNextBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                currentTutorialStep++;
                if (currentTutorialStep < tutorialSteps.length) {
                    showTutorialStep(currentTutorialStep);
                }
            });
        });
        playFromTutorialBtn.addEventListener('click', async () => {
            tutorialModal.classList.add('hidden');
            backToMenuBtn.classList.remove('hidden');
            await AudioManager.start();
            await init();
            canvas.addEventListener('pointerdown', handlePointerStart, { passive: false });
            canvas.addEventListener('pointermove', handlePointerMove, { passive: false });
            canvas.addEventListener('pointerup', handlePointerEnd);
            canvas.addEventListener('pointercancel', handlePointerEnd);
            window.addEventListener('resize', onResizeDebounced);
        });
        backToMenuBtn.addEventListener('click', () => { window.location.href = 'index.html'; });
        document.addEventListener("visibilitychange", () => {
            if (document.hidden) { Tone.Transport.pause(); } 
            else if (AudioManager.started) { Tone.Transport.start(); }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && currentModal) {
                const closeButton = currentModal.querySelector('button');
                if (closeButton) closeButton.click();
            }
        });

        closeFactButton.addEventListener('click', () => {
            hideModal(factModal);
            isPaused = false;
            resetHintTimer();
        });

    });
    window.addEventListener('beforeunload', () => {
        if (threatInterval) clearInterval(threatInterval);
        if (hintTimeout) clearTimeout(hintTimeout);
    });

})(); // K·∫øt th√∫c IIFE
</script>
</body>
</html>
