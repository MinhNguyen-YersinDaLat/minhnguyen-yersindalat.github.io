<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Game Kim C∆∞∆°ng: C√¢n B·∫±ng Cu·ªôc S·ªëng</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/4a2129a3a2.js" crossorigin="anonymous"></script>

    <style>
        /* --- General Styles --- */
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            animation: vignette-pulse 8s infinite alternate ease-in-out;
            background-color: #0c0a09; /* Darker base for neon */
        }
        @keyframes vignette-pulse {
            from { background: radial-gradient(ellipse at center, #1a1111 50%, #000000 100%); }
            to { background: radial-gradient(ellipse at center, #110a0a 40%, #000000 100%); }
        }
        canvas {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        /* --- Character / Monster Styles --- */
        #character-container {
            position: absolute;
            top: -95px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
            z-index: 20;
        }
        .character-aura {
            position: absolute;
            width: 250px;
            height: 150px;
            background: radial-gradient(ellipse at center, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0) 70%);
            border-radius: 50%;
            animation: aura-pulse 4s infinite alternate ease-in-out;
            z-index: -1;
        }
        @keyframes aura-pulse {
            from { transform: scale(1); opacity: 0.7; }
            to { transform: scale(1.2); opacity: 0.4; }
        }
        #cigarette-svg {
            width: 240px; 
            height: 120px; 
            filter: drop-shadow(0 5px 20px rgba(0, 0, 0, 0.8));
            animation: idle-spasm 6s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        #character-container.coughing #cigarette-svg { animation: cough-shake 0.5s ease-in-out; }
        @keyframes cough-shake {
            0%, 100% { transform: translate(0, 0); } 20% { transform: translate(-8px, 5px) rotate(-3deg); } 40% { transform: translate(8px, -5px) rotate(3deg); } 60% { transform: translate(-5px, 3px) rotate(-2deg); } 80% { transform: translate(5px, -3px) rotate(2deg); }
        }
        @keyframes idle-spasm {
            0%, 100% { transform: translate(0, 0) rotate(0); } 10% { transform: translate(-2px, 2px) rotate(-1deg); } 20% { transform: translate(2px, -2px) rotate(1deg); } 30% { transform: translate(-3px, 0px) rotate(-1.5deg); } 40% { transform: translate(3px, 1px) rotate(1.5deg); } 50% { transform: translate(0, 0) rotate(0); } 70% { transform: translate(0, 0) rotate(0); } 72% { transform: translate(5px, -5px) rotate(3deg); } 74% { transform: translate(0, 0) rotate(0); }
        }
        .cigarette-body-shape { fill: url(#paper-gradient); } .filter-shape { fill: #6b3520; } .ash-shape { fill: #333; } .ember-shape { fill: #ff4500; filter: url(#emberGlow); animation: ember-flicker 1.5s infinite alternate; }
        @keyframes ember-flicker { from { opacity: 0.9; } to { opacity: 1; } }
        .eye-socket { fill: #1a0000; } .eye-ball { fill: #dc143c; } .eye-pupil { fill: #000; transition: transform 0.1s linear; } .eye-vein { stroke: #8b0000; stroke-width: 0.5; fill: none; } .mouth { fill: #1a1a1a; transition: d 0.3s ease-in-out; } .crack { fill: none; stroke: #4e2a1d; stroke-width: 1.2; } .stain { fill: #704214; opacity: 0.6; } .spark { fill: #ffdd00; animation: spark-fly 1.5s infinite linear; }
        @keyframes spark-fly { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(-30px, var(--y-end)) scale(0); opacity: 0; } }
        .smoke-container { position: absolute; left: -120px; top: 50%; transform: translateY(-50%); width: 200px; height: 200px; pointer-events: none; filter: url(#smokeFilter); }
        .smoke-wisp { position: absolute; background: white; border-radius: 50%; animation: wisp-rise 12s infinite linear; opacity: 0; }
        @keyframes wisp-rise { 0% { transform: translate(0, 0) scale(0.5); opacity: 0; } 15% { opacity: 0.8; } 100% { transform: translate(-120px, var(--y-end)) scale(2.5); opacity: 0; } }
        .smoke-wisp:nth-child(1) { width: 60px; height: 60px; animation-delay: 0s; --y-end: -80px; } .smoke-wisp:nth-child(2) { width: 80px; height: 80px; animation-delay: 4s; --y-end: 50px; } .smoke-wisp:nth-child(3) { width: 50px; height: 50px; animation-delay: 8s; --y-end: -20px; }
        #threat-bubble { position: absolute; bottom: 100%; left: 50%; margin-bottom: 10px; background-color: #110d0d; color: #ff4500; padding: 15px 22px; border-radius: 12px; border: 2px solid #ff4500; font-size: 1.3rem; font-family: 'Metal Mania', cursive; letter-spacing: 1px; opacity: 0; transform: translateY(20px) scale(0.9) translateX(-50%); transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); white-space: nowrap; box-shadow: 0 0 25px rgba(255, 69, 0, 0.7); }
        #threat-bubble.visible { opacity: 1; transform: translateY(0) scale(1) translateX(-50%); }
        #monster-name { position: absolute; top: 50%; left: 230px; transform: translateY(-50%); white-space: nowrap; }

        /* --- UI & Game Elements --- */
        #game-title { animation: sparkle 5s infinite linear; }
        @keyframes sparkle { 0% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); } 50% { text-shadow: 2px 2px 8px rgba(236, 72, 153, 0.5); } 100% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); } }
        #custom-cursor { position: fixed; width: 20px; height: 20px; border: 2px solid #ff4500; border-radius: 50%; pointer-events: none; transform: translate(-50%, -50%); z-index: 9999; transition: transform 0.1s ease-out; }
        
        progress {
            vertical-align: baseline;
            appearance: none;
        }
        progress::-webkit-progress-bar {
            background-color: rgba(0,0,0,0.3);
            border-radius: 9999px;
        }
        progress::-webkit-progress-value {
            background: linear-gradient(to right, #ef4444, #f87171);
            border-radius: 9999px;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px #ef4444;
        }
        progress::-moz-progress-bar {
            background: linear-gradient(to right, #ef4444, #f87171);
            border-radius: 9999px;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px #ef4444;
        }

        /* --- Screens & Modals --- */
        #start-screen { position: fixed; inset: 0; background-color: rgba(0,0,0,0.8); backdrop-filter: blur(10px); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; text-align: center; padding: 1rem; }
        .tutorial-icon { height: 60px; margin: 0 auto 0.5rem auto; display: flex; align-items: center; justify-content: center; }
        .tutorial-gem-container { width: 50px; height: 50px; position: relative; }
        .tutorial-gem { width: 100%; height: 100%; transform: rotate(45deg); border-radius: 8px; position: relative; overflow: hidden; border: 2px solid rgba(255,255,255,0.5); box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), inset -2px -2px 5px rgba(0,0,0,0.3); }
        .tutorial-gem-bomb { background: radial-gradient(circle, #6bb5ff, #1E90FF); }
        .tutorial-gem-bomb::after { content: ''; position: absolute; top: 50%; left: 50%; width: 60%; height: 60%; background-color: rgba(255, 255, 255, 0.9); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px white; }
        .tutorial-gem-beam { background: radial-gradient(circle, #ff7b7b, #FF3131); }
        .tutorial-gem-beam::after { content: ''; position: absolute; top: 50%; left: 50%; width: 100%; height: 25%; background-color: white; transform: translate(-50%, -50%); box-shadow: 0 0 10px white; }
        .tutorial-gem-hypercube { background: conic-gradient(from 0deg, #FF3131, #FFFF00, #00FF7F, #1E90FF, #FF00FF, #FF8C00, #FF3131); animation: spin 4s linear infinite; }
        @keyframes spin { from { transform: rotate(45deg); } to { transform: rotate(405deg); } }

        /* --- UI Buttons --- */
        .ui-button { position: fixed; z-index: 101; width: 44px; height: 44px; background: rgba(10, 20, 30, 0.5); border: 1px solid rgba(236, 72, 153, 0.3); border-radius: 50%; color: rgba(236, 72, 153, 0.7); display: flex; align-items: center; justify-content: center; cursor: pointer; backdrop-filter: blur(5px); transition: all 0.3s ease; box-shadow: 0 0 15px rgba(236, 72, 153, 0.2), inset 0 0 5px rgba(236, 72, 153, 0.1); }
        .ui-button:hover { background: rgba(20, 40, 60, 0.7); color: white; border-color: rgba(236, 72, 153, 0.8); box-shadow: 0 0 25px rgba(236, 72, 153, 0.5), inset 0 0 10px rgba(236, 72, 153, 0.2); transform: scale(1.1); }
        #fullscreen-btn { top: 1rem; right: 1rem; }
        #back-to-menu-btn { bottom: 1rem; right: 1rem; }

        /* --- Copyright --- */
        #copyright {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 13px;
            padding: 6px 0;
            font-family: 'Roboto', Arial, Helvetica, sans-serif;
            z-index: 9999;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.85);
            background: transparent;
            opacity: 0;
            animation: fadeIn 2s ease forwards;
        }
        @keyframes fadeIn { to { opacity: 1; } }

        /* --- Balance Mode UI (REWORKED) --- */
        #balance-mode-screen {
            height: 100vh;
            width: 100vw;
            padding: 1rem;
        }
        .info-panel {
            background: rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 1rem;
            padding: 1rem;
            color: white;
            animation: fadeInPanel 1s ease forwards;
            overflow-y: auto;
        }
        @keyframes fadeInPanel { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .info-panel h2 {
            font-weight: bold;
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
            text-align: center;
            position: sticky;
            top: 0;
            background: rgba(0,0,0,0.5);
            padding: 0.5rem 0;
            z-index: 10;
        }
        .info-panel ul { list-style: none; padding: 0; }
        .info-panel li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            opacity: 0;
            transform: translateX(-20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .info-panel li.visible {
            opacity: 1;
            transform: translateX(0);
        }
        .info-panel .icon { width: 24px; text-align: center; flex-shrink: 0; }
        
        #balance-three-columns {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            height: 100%;
        }

        #balance-center-column {
             height: 100%;
        }

        #balance-scale-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            margin: 0 auto;
            height: 320px;
        }
        #balance-game-board {
            width: 100%;
            max-width: 450px;
            margin-top: -290px;
        }
        #balance-mode-stats {
             margin-top: 1rem;
        }

        /* --- New Energy Core Styles --- */
        @keyframes plasma-swirl {
            0% { transform: rotate(0deg) scale(1.2); opacity: 0.6; }
            50% { transform: rotate(180deg) scale(1.5); opacity: 0.8; }
            100% { transform: rotate(360deg) scale(1.2); opacity: 0.6; }
        }

        @keyframes plasma-pulse {
            from { filter: brightness(1) drop-shadow(0 0 5px currentColor); }
            to { filter: brightness(1.5) drop-shadow(0 0 15px currentColor); }
        }

        #balance-chain {
            height: 8px; /* D·∫£i hologram m·ªèng h∆°n */
            background: linear-gradient(90deg, transparent, #00d9ff, #00d9ff, transparent);
            border-radius: 4px;
            box-shadow: 0 0 15px #00d9ff, 0 0 25px #00d9ff, inset 0 0 2px white;
            position: relative;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #balance-pivot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #fff, #00d9ff);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #fff, 0 0 20px #00d9ff;
            border: 2px solid white;
        }
        .balance-tube-wrapper {
            position: absolute;
            top: 30px; 
            width: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .balance-tube-wrapper.left { left: 0; }
        .balance-tube-wrapper.right { right: 0; }
        
        .balance-tube { /* V·ªè b·ªçc L√µi NƒÉng L∆∞·ª£ng */
            width: 100%;
            height: 250px;
            border: 2px solid rgba(0, 217, 255, 0.5);
            border-top: 4px solid #00d9ff;
            border-radius: 12px;
            background: linear-gradient(rgba(0,0,0,0.2), rgba(0,0,0,0.5));
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 15px rgba(0, 217, 255, 0.2), 0 0 10px rgba(0, 217, 255, 0.3);
        }
        .balance-liquid { /* Kh·ªëi Plasma */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            transition: height 0.3s ease-out;
            background: transparent;
            overflow: hidden;
            animation: plasma-pulse 2s infinite alternate ease-in-out;
        }

        .balance-liquid::before, .balance-liquid::after {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            border-radius: 40%;
            animation: plasma-swirl 10s infinite linear;
        }
        
        .balance-liquid.study { 
            color: #ff4b2b;
        }
        .balance-liquid.play { 
            color: #1cb5e0;
        }

        .balance-liquid.study::before { background: radial-gradient(circle at center, rgba(255, 75, 43, 0.7) 0%, rgba(255, 0, 0, 0) 60%); }
        .balance-liquid.study::after { background: radial-gradient(circle at center, rgba(255, 65, 108, 0.7) 0%, rgba(255, 0, 0, 0) 60%); animation-direction: reverse; animation-duration: 8s; }
        .balance-liquid.play::before { background: radial-gradient(circle at center, rgba(28, 181, 224, 0.7) 0%, rgba(0, 123, 255, 0) 60%); }
        .balance-liquid.play::after { background: radial-gradient(circle at center, rgba(0, 217, 255, 0.7) 0%, rgba(0, 123, 255, 0) 60%); animation-direction: reverse; animation-duration: 8s; }
        
        .tube-label {
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 0 0 5px #000, 0 0 8px #000;
            color: white;
        }
        .tube-percentage {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 0 5px black, 0 0 10px black;
            pointer-events: none;
            z-index: 2;
        }
        .danger-icon {
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%) scale(0);
            font-size: 3rem;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            text-shadow: 0 0 10px white;
        }
        .danger-icon.visible {
            transform: translateX(-50%) scale(1);
            opacity: 1;
        }
        .warning-study .balance-tube { animation: shake-horizontal 0.8s cubic-bezier(.455,.030,.515,.955) both; border-color: #ff4b2b;}
        .warning-play .balance-tube { animation: shake-horizontal 0.8s cubic-bezier(.455,.030,.515,.955) both; border-color: #1cb5e0;}
        
        @keyframes flash-warning {
            50% { box-shadow: inset 0 0 25px rgba(255,255,255,0.8), 0 0 20px rgba(255,255,255,0.7), 0 0 30px rgba(255,255,0,0.5); border-color: #FFFF00; }
        }
        .flash-warning-effect {
            animation: flash-warning 0.6s ease-in-out;
        }

        @keyframes shake-horizontal { 0%,100%{transform:translateX(0)} 10%,30%,50%,70%{transform:translateX(-8px)} 20%,40%,60%,80%{transform:translateX(8px)} }

        #balance-message {
            text-align: center;
            padding: 0.5rem 1rem;
            margin-bottom: 1rem;
            font-size: clamp(1.1rem, 3vw, 1.5rem);
            font-weight: bold;
            color: #f8fafc;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #67e8f9, 0 0 20px #67e8f9, 0 0 25px #67e8f9;
            white-space: normal;
        }

        #balance-mode-stats {
            display: flex;
            gap: 2rem;
            background-color: rgba(0,0,0,0.3);
            padding: 0.5rem 1.5rem;
            border-radius: 9999px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            margin: 0 auto; /* Center horizontally */
        }
        #balance-mode-stats .stat-item span {
            font-size: 1.8rem;
            font-weight: bold;
        }

        .locked-button {
            background-color: #4a5568 !important; /* gray-700 */
            cursor: not-allowed;
            opacity: 0.6;
        }
        .locked-button:hover {
            transform: scale(1);
        }

    </style>
</head>
<body class="bg-gradient-to-br from-gray-700 via-gray-800 to-gray-900 flex items-center justify-center min-h-screen p-4">

<audio id="bg-music" src="nhackimcuong.mp3" loop></audio>
    
<button id="fullscreen-btn" class="ui-button" title="To√†n m√†n h√¨nh" aria-label="Ch·∫ø ƒë·ªô to√†n m√†n h√¨nh">
    <svg id="fullscreen-icon-open" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
    <svg id="fullscreen-icon-close" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
</button>
<button id="back-to-menu-btn" class="ui-button hidden" title="V·ªÅ m√†n h√¨nh ch√≠nh" aria-label="V·ªÅ m√†n h√¨nh ch√≠nh">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
</button>

<div id="start-screen">
    <h1 class="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-4" id="game-title-start">B·∫£o V·ªá Tr√°i Tim</h1>
    <p class="text-gray-200 italic text-xl md:text-2xl mb-8 max-w-2xl">Qu√°i v·∫≠t thu·ªëc l√° ƒëang ƒë·∫øn g·∫ßn. H√£y d√πng tr√≠ tu·ªá c·ªßa b·∫°n ƒë·ªÉ gh√©p c√°c vi√™n kim c∆∞∆°ng, c·ª©u l·∫•y nh·ªØng tr√°i tim v√† ƒë·∫©y l√πi m·ªëi ƒëe d·ªça!</p>
    <div id="start-buttons" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-x-6 gap-y-8 items-start max-w-5xl w-full">
        <div class="flex flex-col items-center">
            <button id="easy-mode-btn" class="w-full bg-green-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform">D·ªÖ (1 M√†n)</button>
            <p class="text-gray-400 text-sm mt-2 px-4">Tr·∫£i nghi·ªám c·ªët truy·ªán.</p>
        </div>
        <div class="flex flex-col items-center">
            <button id="hard-mode-btn" class="w-full bg-red-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform flex items-center justify-center gap-2">Kh√≥ (3 M√†n) <i id="hard-lock-icon" class="fas fa-lock"></i></button>
            <p class="text-gray-400 text-sm mt-2 px-4">Th·ª≠ th√°ch cao h∆°n.</p>
        </div>
        <div class="flex flex-col items-center">
            <button id="free-mode-btn" class="w-full bg-blue-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform flex items-center justify-center gap-2">T·ª± Do <i id="free-lock-icon" class="fas fa-lock"></i></button>
            <p class="text-gray-400 text-sm mt-2 px-4">Ch∆°i kh√¥ng gi·ªõi h·∫°n.</p>
            <p id="free-mode-highscore" class="text-yellow-400 text-sm mt-1"></p>
        </div>
        <div class="flex flex-col items-center">
            <button id="balance-mode-btn" class="w-full bg-purple-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform flex items-center justify-center gap-2">C√¢n B·∫±ng <i id="balance-lock-icon" class="fas fa-lock"></i></button>
            <p class="text-gray-400 text-sm mt-2 px-4">H·ªçc &amp; Ch∆°i.</p>
        </div>
        <div class="col-span-1 sm:col-span-2 lg:col-span-4 flex justify-center mt-4">
             <button id="tutorial-start-btn" class="bg-yellow-600 text-white font-bold py-3 px-8 rounded-full text-xl hover:scale-105 transition-transform">H∆Ø·ªöNG D·∫™N</button>
        </div>
    </div>
</div>

<div id="tutorial-modal" role="dialog" aria-modal="true" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm" aria-labelledby="tutorial-modal-title">
    <div class="bg-gray-800 border border-gray-700 rounded-2xl p-6 md:p-8 shadow-2xl max-w-md w-full text-white text-center">
        <div id="tutorial-step-1" class="tutorial-step">
            <h2 class="text-3xl font-bold text-pink-400 mb-4" id="tutorial-modal-title">M·ª•c Ti√™u: C·ª©u Tr√°i Tim!</h2>
            <div class="tutorial-icon text-5xl">üíó</div>
            <p class="text-lg mb-4">M·ªói v√†i n∆∞·ªõc ƒëi, m·ªôt vi√™n kim c∆∞∆°ng <strong>Tr√°i Tim</strong> s·∫Ω xu·∫•t hi·ªán ·ªü h√†ng d∆∞·ªõi c√πng.</p>
            <p class="text-lg mb-6">H√£y ƒë∆∞a n√≥ l√™n <strong>h√†ng tr√™n c√πng</strong> ƒë·ªÉ c·ª©u tr√°i tim v√† ghi ƒëi·ªÉm. ƒê·ª´ng ƒë·ªÉ qu√°i v·∫≠t thu·ªëc l√° ch·∫°m t·ªõi!</p>
            <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Ti·∫øp theo</button>
        </div>
        <div id="tutorial-step-2" class="tutorial-step hidden">
             <h2 class="text-3xl font-bold text-yellow-400 mb-4">S·ª©c M·∫°nh ƒê·∫∑c Bi·ªát</h2>
             <p class="text-lg mb-4">Gh√©p 4 ho·∫∑c 5 vi√™n kim c∆∞∆°ng ƒë·ªÉ t·∫°o ra c√°c lo·∫°i ƒë·∫∑c bi·ªát:</p>
             <div class="flex justify-around items-start text-center mb-6 space-x-2">
                <div class="flex-1"><div class="tutorial-icon"><div class="tutorial-gem-container"><div class="tutorial-gem tutorial-gem-bomb"></div></div></div><p class="font-bold">Bom</p><p class="text-sm text-gray-300">(Gh√©p 5 vi√™n h√¨nh ch·ªØ L ho·∫∑c T)</p></div>
                <div class="flex-1"><div class="tutorial-icon"><div class="tutorial-gem-container"><div class="tutorial-gem tutorial-gem-beam"></div></div></div><p class="font-bold">Tia S√°ng</p><p class="text-sm text-gray-300">(Gh√©p 4 vi√™n)</p></div>
                <div class="flex-1"><div class="tutorial-icon"><div class="tutorial-gem-container"><div class="tutorial-gem tutorial-gem-hypercube"></div></div></div><p class="font-bold">Si√™u Kh·ªëi</p><p class="text-sm text-gray-300">(Gh√©p 5 vi√™n th·∫≥ng h√†ng)</p></div>
             </div>
             <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Ti·∫øp theo</button>
        </div>
        <div id="tutorial-step-3" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-red-500 mb-4">M·ªëi ƒêe D·ªça</h2>
            <div class="tutorial-icon text-5xl">üö¨</div>
            <p class="text-lg mb-4"><strong>Qu√°i v·∫≠t thu·ªëc l√°</strong> s·∫Ω di chuy·ªÉn v√† c·ªë g·∫Øng "ƒÉn" nh·ªØng tr√°i tim ·ªü h√†ng tr√™n c√πng.</p>
            <p class="text-lg mb-6">H√£y ngƒÉn ch·∫∑n n√≥ b·∫±ng c√°ch ho√†n th√†nh m·ª•c ti√™u ƒë·ªÉ qua m√†n!</p>
            <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Ti·∫øp theo</button>
        </div>
        <div id="tutorial-step-4" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-green-400 mb-4">Ho√†n Th√†nh M·ª•c Ti√™u</h2>
            <p class="text-lg mb-4">Thu th·∫≠p ƒë·ªß s·ªë l∆∞·ª£ng kim c∆∞∆°ng m√†u v√† c·ª©u tr√°i tim theo y√™u c·∫ßu tr√™n <strong>B·∫£ng M·ª•c Ti√™u</strong> ƒë·ªÉ g√¢y s√°t th∆∞∆°ng l√™n qu√°i v·∫≠t.</p>
            <div class="p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10 mb-6 mx-auto max-w-xs">
                <h2 class="text-xl font-bold text-white/80 mb-2">M·ª•c Ti√™u</h2>
                <progress class="w-full h-5 rounded-full overflow-hidden border border-white/10 mb-4" value="40" max="100"></progress>
                <div class="flex items-center justify-between p-2 rounded-lg bg-black/20"><div class="w-6 h-6 rounded-full border-2 border-white/20" style="background-color: #FF3131"></div><span class="font-bold text-white">15</span></div>
            </div>
            <p class="text-lg mb-6">Thanh ti·∫øn tr√¨nh s·∫Ω ƒë·∫ßy d·∫ßn. Khi ho√†n th√†nh t·∫•t c·∫£ m·ª•c ti√™u, b·∫°n s·∫Ω chi·∫øn th·∫Øng m√†n ch∆°i!</p>
            <button id="tutorial-finish-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform hover:scale-105">B·∫Øt ƒë·∫ßu ch∆°i!</button>
        </div>
        
        <!-- H∆∞·ªõng d·∫´n cho m√†n ch∆°i C√¢n B·∫±ng -->
        <div id="tutorial-step-balance" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-purple-400 mb-4">Lu·∫≠t Ch∆°i C√¢n B·∫±ng</h2>
            <p class="text-lg mb-4">Gi·ªØ 2 thanh <strong class="text-red-400">H·ªçc T·∫≠p</strong> v√† <strong class="text-blue-400">Gi·∫£i Tr√≠</strong> kh√¥ng b·ªã c·∫°n (0%) ho·∫∑c ƒë·∫ßy (100%).</p>
            <p class="text-lg mb-6">C·ª© sau v√†i gi√¢y, m·ªôt thanh s·∫Ω <strong class="text-yellow-400">T·ª∞ ƒê·ªòNG TƒÇNG L√äN!</strong></p>
            <div class="space-y-4 text-left p-4 bg-black/20 rounded-lg mb-6">
                <div class="flex items-center gap-4">
                    <div class="w-10 h-10 shrink-0"><div class="tutorial-gem" style="background-color: #1E90FF"></div></div>
                    <div>ƒê·ªÉ <strong class="text-red-400">GI·∫¢M</strong> thanh H·ªçc T·∫≠p, h√£y ƒÉn kim c∆∞∆°ng <strong class="text-blue-400">XANH</strong>.</div>
                </div>
                <div class="flex items-center gap-4">
                    <div class="w-10 h-10 shrink-0"><div class="tutorial-gem" style="background-color: #FF3131"></div></div>
                    <div>ƒê·ªÉ <strong class="text-blue-400">GI·∫¢M</strong> thanh Gi·∫£i Tr√≠, h√£y ƒÉn kim c∆∞∆°ng <strong class="text-red-400">ƒê·ªé</strong>.</div>
                </div>
            </div>
            <button id="balance-tutorial-finish-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-full hover:bg-purple-700 transition-transform hover:scale-105">V√†o Ch∆°i Th√¥i!</button>
        </div>

    </div>
</div>

<div id="custom-cursor"></div>

<!-- M√†n h√¨nh ch∆°i ch√≠nh (Story/Free mode) -->
<div id="game-ui" class="w-full max-w-7xl mx-auto flex-col md:flex-row md:items-start justify-center gap-4 md:gap-8 hidden">
    <!-- C·ªôt m·ª•c ti√™u (Tr√°i) -->
    <div id="objective-panel" class="w-full md:w-1/4 order-3 md:order-1 mt-4 md:mt-0">
        <div class="title-container text-center md:text-left mb-4">
            <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-2" id="game-title">B·∫£o V·ªá Tr√°i Tim</h1>
            <p class="text-gray-200 italic text-lg md:text-xl" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">Ti√™u di·ªát qu√°i v·∫≠t thu·ªëc l√°!</p>
        </div>
        <div class="p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <h2 class="text-xl font-bold text-white/80 mb-2">M·ª•c Ti√™u</h2>
            <progress id="health-bar" class="w-full h-5 rounded-full overflow-hidden border border-white/10 mb-4" value="0" max="100"></progress>
            <div class="space-y-2" id="quest-list"></div>
        </div>
    </div>

    <!-- C·ªôt ch∆°i game (Gi·ªØa) - S·∫Ω ƒë∆∞·ª£c sao ch√©p v√†o Balance Mode -->
    <div class="w-full max-w-md text-center order-2 md:order-2">
        <div class="relative" id="game-container">
            <div id="character-container">
                <div class="character-aura"></div>
                <svg id="cigarette-svg" viewBox="0 0 200 100">
                    <defs>
                        <filter id="smokeFilter"><feTurbulence type="fractalNoise" baseFrequency="0.02 0.05" numOctaves="3" result="turbulence" /><feDisplacementMap in2="turbulence" in="SourceGraphic" scale="15" xChannelSelector="R" yChannelSelector="G" /></filter>
                        <filter id="emberGlow"><feGaussianBlur stdDeviation="3.5" result="coloredBlur" /><feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge></filter>
                        <radialGradient id="paper-gradient"><stop offset="0%" stop-color="#d2b48c" /><stop offset="100%" stop-color="#c8a97e" /></radialGradient>
                    </defs>
                    <path class="filter-shape" d="M160,30 L180,28 Q192,30 190,50 Q188,70 180,72 L160,70 Z" /><path class="cigarette-body-shape" d="M20,30 L160,30 L160,70 L20,70 Q10,70 10,50 Q10,30 20,30 Z" /><path class="stain" d="M110,40 C 120,35 130,45 125,55 C 120,60 110,55 110,40 Z" /><path class="stain" d="M70,60 C 75,55 85,58 80,68 Z" /><path class="crack" d="M140,45 C 145,50, 145,55, 150,60" /><path class="crack" d="M100,35 C 105,45, 95,55, 100,65" /><path class="crack" d="M40,35 L 45,65" /><path class="crack" d="M155,35 L 158,65" /><path class="ash-shape" d="M20,30 Q10,30 10,50 Q10,70 20,70 L30,70 Q25,50 30,30 Z" /><path d="M28 40 L 32 38 M28 50 L 33 50 M28 60 L 32 62" stroke="#a0522d" stroke-width="1" /><path class="ember-shape" d="M25,35 Q20,50 25,65 L20,65 Q15,50 20,35 Z" /><g id="sparks"><circle class="spark" cx="22" cy="40" r="1.5" style="animation-delay: 0s; --y-end: -20px;"></circle><circle class="spark" cx="20" cy="50" r="1" style="animation-delay: 0.5s; --y-end: 0px;"></circle><circle class="spark" cx="22" cy="60" r="1.5" style="animation-delay: 1s; --y-end: 20px;"></circle></g><g id="face"><g id="eye1_group"><circle class="eye-socket" cx="55" cy="50" r="12" /><circle class="eye-ball" cx="55" cy="50" r="11" /><path class="eye-vein" d="M50,50 C 52,47 55,47 57,50" /><path class="eye-vein" d="M57,50 C 59,53 62,53 85,50" /><circle class="eye-pupil" id="pupil1" cx="55" cy="50" r="5" /></g><g id="eye2_group"><circle class="eye-socket" cx="80" cy="50" r="12" /><circle class="eye-ball" cx="80" cy="50" r="11" /><path class="eye-vein" d="M75,50 C 77,47 80,47 82,50" /><path class="eye-vein" d="M82,50 C 84,53 87,53 85,50" /><circle class="eye-pupil" id="pupil2" cx="80" cy="50" r="5" /></g><path class="mouth" id="mouth-path" d="M60 65 L 64 63 L 68 65 L 72 63 L 76 65" /></g>
                </svg>
                <div class="smoke-container"><div class="smoke-wisp"></div><div class="smoke-wisp"></div><div class="smoke-wisp"></div></div>
                <div id="threat-bubble"><p id="threat-text"></p></div>
                <div id="monster-name" class="text-center"><p class="text-lg font-bold text-red-400" style="text-shadow: 0 0 8px rgba(255, 0, 0, 0.7);">Qu√°i v·∫≠t thu·ªëc l√°</p></div>
            </div>
            <canvas id="gameCanvas" role="img" aria-label="B·∫£ng ch∆°i Kim C∆∞∆°ng: c·ª©u tr√°i tim b·∫±ng c√°ch gh√©p 3 vi√™n"></canvas>
            
        </div>
    </div>
    
    <!-- C·ªôt th√¥ng s·ªë (Ph·∫£i) -->
    <div id="story-mode-stats" class="w-full md:w-1/4 order-1 md:order-3 flex flex-row md:flex-col justify-around md:justify-start gap-2 md:gap-6 mb-4 md:mb-0">
        <div class="flex-1 md:flex-auto p-2 md:p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10"><p class="text-base md:text-lg font-bold text-white/70">C·∫•p ƒê·ªô</p><p class="text-3xl md:text-4xl font-bold text-white" id="level">1</p></div>
        <div class="flex-1 md:flex-auto p-2 md:p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10"><p class="text-base md:text-lg font-bold text-white/70">N∆∞·ªõc ƒëi</p><p class="text-3xl md:text-4xl font-bold text-white" id="moves">0</p></div>
        <div class="flex-1 md:flex-auto p-2 md:p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10"><p class="text-base md:text-lg font-bold text-white/70">ƒê√£ c·ª©u</p><p class="text-3xl md:text-4xl font-bold text-white" id="score">0</p></div>
    </div>
</div>

<!-- M√†n h√¨nh ch∆°i C√¢n B·∫±ng (thi·∫øt k·∫ø m·ªõi) -->
<div id="balance-mode-screen" class="w-full h-screen flex-col items-center justify-center gap-4 hidden p-4">
    <div id="balance-message">
        H√£y c√¢n b·∫±ng h·ªçc t·∫≠p v√† gi·∫£i tr√≠ ‚Äì ƒê·ª´ng ƒë·ªÉ √°p l·ª±c ƒë·∫©y b·∫°n ƒë·∫øn thu·ªëc l√°.
    </div>
    <div id="balance-three-columns" class="w-full flex-grow">
        <!-- C·ªôt th√¥ng tin b√™n tr√°i -->
        <div class="info-panel w-full md:w-1/4 h-full hidden md:flex flex-col">
            <h2 class="text-red-400">T√ÅC H·∫†I THU·ªêC L√Å</h2>
            <ul id="facts-list" class="flex-grow space-y-2">
                <li><span class="icon text-red-500"><i class="fas fa-skull-crossbones"></i></span><span>H∆°n 8 tri·ªáu ng∆∞·ªùi ch·∫øt m·ªói nƒÉm tr√™n to√†n c·∫ßu.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-lungs-virus"></i></span><span>G√¢y ung th∆∞ ph·ªïi, b·ªánh tim v√† ƒë·ªôt qu·ªµ.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-child"></i></span><span>H√∫t thu·ªëc th·ª• ƒë·ªông g√¢y h·∫°i cho gia ƒë√¨nh v√† b·∫°n b√®.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-wallet"></i></span><span>Ti√™u t·ªën m·ªôt kho·∫£n ti·ªÅn l·ªõn m·ªói nƒÉm.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-smoking-ban"></i></span><span>Ch·ª©a h∆°n 7,000 h√≥a ch·∫•t, h√†ng trƒÉm ch·∫•t ƒë·ªôc h·∫°i.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-tooth"></i></span><span>G√¢y v√†ng rƒÉng, h√¥i mi·ªáng v√† c√°c b·ªánh v·ªÅ n∆∞·ªõu.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-running"></i></span><span>L√†m gi·∫£m s·ª©c b·ªÅn th·ªÉ ch·∫•t v√† kh·∫£ nƒÉng v·∫≠n ƒë·ªông.</span></li>
                <li><span class="icon text-red-500"><i class="fas fa-brain"></i></span><span>TƒÉng nguy c∆° m·∫Øc b·ªánh Alzheimer v√† suy gi·∫£m tr√≠ nh·ªõ.</span></li>
            </ul>
        </div>

        <!-- C·ªôt ch∆°i game ·ªü gi·ªØa -->
        <div id="balance-center-column" class="w-full md:w-1/2 h-full flex flex-col items-center justify-center">
            <div id="balance-scale-container">
                <div id="balance-chain">
                    <div id="balance-pivot"></div>
                </div>
                <div class="balance-tube-wrapper left">
                    <div class="danger-icon" id="study-danger-icon">üìö</div>
                    <div class="balance-tube">
                        <div id="study-liquid" class="balance-liquid study"></div>
                        <div id="study-percentage" class="tube-percentage">50%</div>
                    </div>
                    <div class="tube-label">H·ªçc T·∫≠p</div>
                </div>
                <div class="balance-tube-wrapper right">
                     <div class="danger-icon" id="play-danger-icon">üéÆ</div>
                    <div class="balance-tube">
                        <div id="play-liquid" class="balance-liquid play"></div>
                        <div id="play-percentage" class="tube-percentage">50%</div>
                    </div>
                    <div class="tube-label">Gi·∫£i Tr√≠</div>
                </div>
            </div>
            <div id="balance-game-board" class="w-full max-w-md">
                <!-- Canvas s·∫Ω ƒë∆∞·ª£c chuy·ªÉn v√†o ƒë√¢y b·∫±ng JS -->
            </div>
            <div id="balance-mode-stats">
                <div class="stat-item">
                    <p>Level</p>
                    <span id="balance-level">1</span>
                </div>
                <div class="stat-item">
                    <p>Time</p>
                    <span id="balance-timer">60</span>
                </div>
            </div>
        </div>

        <!-- C·ªôt th√¥ng tin b√™n ph·∫£i -->
        <div class="info-panel w-full md:w-1/4 h-full hidden md:flex flex-col">
            <h2 class="text-cyan-400">L·ªêI S·ªêNG L√ÄNH M·∫†NH</h2>
            <ul id="skills-list" class="flex-grow space-y-2">
                <li><span class="icon text-cyan-500"><i class="fas fa-dumbbell"></i></span><span>T·∫≠p th·ªÉ d·ª•c √≠t nh·∫•t 30 ph√∫t m·ªói ng√†y.</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-book-open"></i></span><span>ƒê·ªçc m·ªôt ch∆∞∆°ng s√°ch ƒë·ªÉ th∆∞ gi√£n v√† h·ªçc h·ªèi.</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-users"></i></span><span>G·ªçi ƒëi·ªán ho·∫∑c g·∫∑p g·ª° b·∫°n b√®, ng∆∞·ªùi th√¢n.</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-brain"></i></span><span>H·ªçc m·ªôt k·ªπ nƒÉng m·ªõi: nh·∫°c c·ª•, ng√¥n ng·ªØ, v·∫Ω...</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-leaf"></i></span><span>ƒêi d·∫°o ngo√†i tr·ªùi, h√≠t th·ªü kh√¥ng kh√≠ trong l√†nh.</span></li>
                <li><span class="icon text-cyan-500"><i class="fas fa-music"></i></span><span>Nghe m·ªôt b·∫£n nh·∫°c y√™u th√≠ch ƒë·ªÉ gi·∫£m cƒÉng th·∫≥ng.</span></li>
                 <li><span class="icon text-cyan-500"><i class="fas fa-utensils"></i></span><span>Th·ª≠ n·∫•u m·ªôt m√≥n ƒÉn m·ªõi, t·ªët cho s·ª©c kh·ªèe.</span></li>
                 <li><span class="icon text-cyan-500"><i class="fas fa-bed"></i></span><span>Ng·ªß ƒë·ªß 7-8 ti·∫øng m·ªói ƒë√™m ƒë·ªÉ ph·ª•c h·ªìi nƒÉng l∆∞·ª£ng.</span></li>
            </ul>
        </div>
    </div>
</div>


<!-- Game Modals -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="winModal" role="dialog" aria-modal="true" tabindex="-1" aria-labelledby="winModalTitle">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95"><h2 class="text-4xl font-bold text-green-600 mb-4" id="winModalTitle">Qua M√†n!</h2><p class="text-lg text-gray-700 mb-6" id="win-level-text"></p><button class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-300" id="nextLevelButton">Ti·∫øp t·ª•c</button></div>
</div>

<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="gameOverModal" role="dialog" aria-modal="true" tabindex="-1" aria-labelledby="gameOverModalTitle">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95"><h2 class="text-4xl font-bold text-red-800 mb-4" id="gameOverModalTitle">Th·∫•t B·∫°i!</h2><p class="text-lg text-gray-700 mb-2" id="gameOverReason">M·∫•t c√¢n b·∫±ng!</p><p class="text-xl text-gray-800 mb-8" id="gameOverMessageContainer"></p><div class="flex flex-col sm:flex-row gap-4 justify-center"><button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="gameOverHomeButton">V·ªÅ Trang Ch·ªß</button><button class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105" id="gameOverRestartButton">Ch∆°i L·∫°i</button></div></div>
</div>
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm" id="factModal" role="dialog" aria-modal="true" tabindex="-1" aria-labelledby="factModalTitle">
    <div class="bg-white rounded-2xl p-6 md:p-8 text-center shadow-2xl transform transition-all scale-95 max-w-md w-full"><h2 class="text-2xl md:text-3xl font-bold text-blue-700 mb-4" id="factModalTitle">S·ª± Th·∫≠t & L·ªùi Khuy√™n</h2><p class="text-base md:text-lg text-gray-800 mb-3 text-left" id="factText"></p><p class="text-base md:text-lg text-green-700 font-semibold mb-6 text-left" id="adviceText"></p><button class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300" id="closeFactButton">ƒê√£ hi·ªÉu</button></div>
</div>
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="finalWinModal" role="dialog" aria-modal="true" tabindex="-1">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95"><h2 class="text-4xl font-bold text-yellow-500 mb-4">CHI·∫æN TH·∫ÆNG!</h2><p class="text-lg text-gray-700 mb-2">B·∫°n ƒë√£ b·∫£o v·ªá th√†nh c√¥ng nh·ªØng tr√°i tim kh·ªèi nanh vu·ªët c·ªßa qu√°i v·∫≠t!</p><p class="text-xl text-gray-800 mb-6">C·∫£m ∆°n b·∫°n ƒë√£ tr·ªü th√†nh ng∆∞·ªùi h√πng!</p><div class="flex flex-col sm:flex-row gap-4 justify-center"><button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="restartGameButton">Ch∆°i l·∫°i</button><button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="backToIndexButton">V·ªÅ m√†n h√¨nh ch√≠nh</button><button class="bg-yellow-500 text-white font-bold py-3 px-8 rounded-full hover:bg-yellow-600 transition-transform transform hover:scale-110 ring-4 ring-yellow-300 shadow-lg shadow-yellow-500/50" id="continueToNextGameButton">Ti·∫øp t·ª•c</button></div></div>
</div>

<div id="copyright">
    ¬© <span id="year"></span> Th·∫ßy Th√°i Minh Nguy√™n - Tr∆∞·ªùng Ti·ªÉu h·ªçc, THCS & THPT Yersin ƒê√† L·∫°t. All rights reserved.
</div>

<script>
(function() {
    'use strict';

    // --- MODULE: CONSTANTS & CONFIGURATION ---
    const CONFIG = {
        GRID_SIZE: 8,
        GEM_COLORS: ['#FF3131', '#00FF7F', '#1E90FF', '#FF00FF', '#FF8C00', '#FFFF00'],
        HEART_EMOJI: 'üíó',
        MOVES_PER_HEART_SPAWN: 3,
        CIGARETTE_LUNGE_CHANCE: 0.25,
        THREAT_INTERVAL: 6000,
        ANIM_SWAP_SPEED: 150,
        ANIM_FALL_SPEED: 400,
        ANIM_CLEAR_SPEED: 200,
        ANIM_SPECIAL_PULSE_SPEED: 150,
        MAX_PARTICLES: 150, 
        HINT_TIMEOUT: 5000,
        FINAL_LEVEL: 1,
        COUGH_INTERVAL_MOVES: 10,
        COUGH_START_LEVEL: 2,
        WATCHDOG_TIMEOUT: 5000,
        BALANCE_MODE: {
            STUDY_GEM_INDEX: 0, // Index for red gem (H·ªçc T·∫≠p)
            PLAY_GEM_INDEX: 2,  // Index for blue gem (Gi·∫£i Tr√≠)
            POINTS_PER_GEM_REDUCTION: 8, // ƒêi·ªÉm m·ªói vi√™n kim c∆∞∆°ng l√†m gi·∫£m thanh ƒë·ªëi di·ªán
            PASSIVE_INCREASE_INTERVAL: 2000, // C·ª© 2 gi√¢y s·∫Ω tƒÉng m·ªôt l·∫ßn
            WARNING_THRESHOLD: 85,
            MAX_TILT_ANGLE: 10, // degrees
            INFO_PANEL_INTERVAL: 15000 // 15 gi√¢y
        }
    };

    const SPECIAL_TYPES = { NONE: 'none', H_BEAM: 'h_beam', V_BEAM: 'v_beam', BOMB: 'bomb', HYPERCUBE: 'hypercube' };

    const HEALTH_FACTS = [
        { fact: "Thu·ªëc l√° gi·∫øt **h∆°n 7 tri·ªáu ng∆∞·ªùi/nƒÉm**, trong ƒë√≥ c√≥ kho·∫£ng **1,6 tri·ªáu ng∆∞·ªùi kh√¥ng h√∫t th·ª• ƒë·ªông**. (Ngu·ªìn: WHO)", advice: "L·ªùi khuy√™n: H√£y tr√°nh xa kh√≥i thu·ªëc ƒë·ªÉ b·∫£o v·ªá b·∫°n v√† nh·ªØng ng∆∞·ªùi xung quanh." },
        { fact: "H√∫t thu·ªëc kh√¥ng th·ª• ƒë·ªông (passive smoking) c≈©ng g√¢y ung th∆∞ ph·ªïi, b·ªánh tim v√† nhi·ªÅu v·∫•n ƒë·ªÅ s·ª©c kh·ªèe nghi√™m tr·ªçng. (Ngu·ªìn: CDC / IARC)", advice: "L·ªùi khuy√™n: ƒê·ª´ng ƒë·ªÉ kh√≥i thu·ªëc x√¢m nh·∫≠p kh√¥ng kh√≠ s·ªëng, gi·ªØ s·∫°ch m√¥i tr∆∞·ªùng cho ph·ªïi b·∫°n." },
        { fact: "H√∫t thu·ªëc g√¢y t·ªïn th∆∞∆°ng **gan, ph·ªïi, tim**, l√†m tƒÉng nguy c∆° m·∫Øc **COPD, nh·ªìi m√°u c∆° tim, ƒë·ªôt qu·ªµ** v√† nhi·ªÅu lo·∫°i ung th∆∞. (Ngu·ªìn: CDC)", advice: "L·ªùi khuy√™n: M·ªói h∆°i thu·ªëc b·∫°n h√≠t v√†o l√† t·ªïn h·∫°i cho c∆° th·ªÉ‚Äîng∆∞ng ngay h√¥m nay ƒë·ªÉ kh·ªèe m·∫°nh h∆°n." },
    ];
    
    const THREATS = [ "Ta n·∫øm ƒë∆∞·ª£c n·ªói s·ª£ c·ªßa ng∆∞∆°i.", "M·ªói t·∫ø b√†o c·ªßa ng∆∞∆°i ƒëang g√†o th√©t.", "Ta l√† c√°i ch·∫øt ch·∫≠m r√£i ng∆∞∆°i t·ª± ch·ªçn.", "Linh h·ªìn ng∆∞∆°i... s·∫Ω l√† l√†n kh√≥i ti·∫øp theo.", "Kh√¥ng c√≥ l·ªëi tho√°t ƒë√¢u." ];

    // --- MODULE: GAME STATE & DOM ELEMENTS ---
    let DOMElements;
    let gemSize, board = [], selectedGem = null, score = 0, moves = 0, isAnimating = false;
    let isPaused = false, animations = [], particles = [], particlePool = [], hintTimeout = null;
    let cigarette = { col: Math.floor(CONFIG.GRID_SIZE / 2), level: 1 };
    let currentLevel = 1, quest = {}, startDragPos = { x: null, y: null }, startGem = null;
    let isDragging = false, gemCache = {}, hintGems = [], isFreePlayMode = false;
    let resizeTimer = null, factsShown = [], threatInterval = null, currentModal = null, isTutorialOnly = false;
    let animationWatchdog = null, isPausedForFact = false;
    let gameMode = 'story'; // 'story', 'free', 'balance'
    let currentDifficulty = 'easy';
    let studyValue = 50, playValue = 50, balanceTimerInterval = null, balanceTimeLeft = 60, currentBalanceLevel = 1, balanceMovesMade = 0;
    let passiveIncreaseInterval = null, infoPanelInterval = null;


    // --- MODULE: AUDIO MANAGER ---
    const AudioManager = {
        isInitialized: false, isMusicStarted: false, sfxBus: null, sfx: {},
        async init() {
            if (this.isInitialized) return;
            await Tone.start();
            this.sfxBus = new Tone.Volume(-8).toDestination();
            this.sfx.select = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).connect(this.sfxBus);
            this.sfx.match = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.7 }).connect(this.sfxBus);
            this.sfx.bombKick = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).connect(this.sfxBus);
            this.sfx.bombNoise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).connect(this.sfxBus);
            const beamFilter = new Tone.AutoFilter("16n").connect(this.sfxBus).start();
            beamFilter.baseFrequency = 400; beamFilter.octaves = 3;
            this.sfx.beam = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0 } }).connect(beamFilter);
            this.sfx.unlock = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, release: 0.1 } }).connect(this.sfxBus);
            this.isInitialized = true;
        },
        startMusic() {
            if (!this.isMusicStarted) {
                const music = document.getElementById("bg-music");
                if (music && music.getAttribute('src')) {
                    music.volume = 0.2; 
                    music.play().catch(e => console.warn("Audio play failed, likely due to missing file:", e.message)); 
                    this.isMusicStarted = true; 
                }
            }
        },
        playSfx(type) {
            if (!this.isInitialized) return;
            const now = Tone.now();
            try {
                switch (type) {
                    case 'select': this.sfx.select.triggerAttackRelease('C7', '32n', now); break;
                    case 'match': this.sfx.match.triggerAttackRelease('G5', '8n', now); break;
                    case 'bomb': this.sfx.bombKick.triggerAttackRelease('C2', '8n', now); this.sfx.bombNoise.triggerAttackRelease('16n', now + 0.01); break;
                    case 'unlock': this.sfx.unlock.triggerAttackRelease('A6', '16n', now); break;
                    case 'beam': case 'hypercube': this.sfx.beam.triggerAttackRelease('8n', now); break;
                }
            } catch (e) { console.error('SFX error:', e); }
        }
    };

    // --- MODULE: UI & RENDERING ---
    function showModal(modalElement, focusElement) {
        currentModal = modalElement;
        modalElement.classList.remove('hidden');
        setTimeout(() => { 
            const innerDiv = modalElement.querySelector('div');
            if(innerDiv) innerDiv.classList.add('scale-100');
            if (focusElement) focusElement.focus(); 
            trapFocus(modalElement);
        }, 10);
    }

    function hideModal(modalElement) {
        if (modalElement) {
            releaseFocus(modalElement);
            const innerDiv = modalElement.querySelector('div');
            if(innerDiv) innerDiv.classList.remove('scale-100'); 
            setTimeout(() => modalElement.classList.add('hidden'), 200); 
        }
        currentModal = null;
    }
    
    function trapFocus(modal) {
      if (!modal) return;
      const focusables = modal.querySelectorAll('button, a, input, textarea, [tabindex]:not([tabindex="-1"])');
      if (!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      
      function keyHandler(e) {
        if (e.key === 'Tab') {
          if (e.shiftKey && document.activeElement === first) {
            e.preventDefault(); last.focus();
          } else if (!e.shiftKey && document.activeElement === last) {
            e.preventDefault(); first.focus();
          }
        }
      }
      modal._keyHandler = keyHandler;
      modal.addEventListener('keydown', keyHandler);
    }
    
    function releaseFocus(modal) {
      if (modal && modal._keyHandler) {
          modal.removeEventListener('keydown', modal._keyHandler);
          delete modal._keyHandler;
      }
    }

    function showThreat() {
        if (isPaused || !DOMElements.gameOverModal.classList.contains('hidden') || DOMElements.characterContainerEl.classList.contains('attacking')) return;
        DOMElements.threatText.textContent = THREATS[Math.floor(Math.random() * THREATS.length)];
        DOMElements.mouth.setAttribute('d', 'M58 68 L 64 60 L 70 68 L 76 60 L 82 68');
        DOMElements.characterContainerEl.classList.add('attacking');
        DOMElements.threatBubble.classList.add('visible');
        setTimeout(() => {
            DOMElements.threatBubble.classList.remove('visible');
            DOMElements.mouth.setAttribute('d', 'M60 65 L 64 63 L 68 65 L 72 63 L 76 65');
            DOMElements.characterContainerEl.classList.remove('attacking');
        }, 2000);
    }

    async function showFact() {
        isPaused = true;
        isPausedForFact = true;
        clearTimeout(hintTimeout);
        let availableFacts = HEALTH_FACTS.filter(obj => !factsShown.includes(obj));
        if (availableFacts.length === 0) factsShown = [];
        const factObject = availableFacts.length > 0 ? availableFacts[Math.floor(Math.random() * availableFacts.length)] : HEALTH_FACTS[0];
        factsShown.push(factObject);
        DOMElements.factText.innerHTML = factObject.fact.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        DOMElements.adviceText.innerHTML = factObject.advice.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        showModal(DOMElements.factModal, DOMElements.closeFactButton);
    }

    function showGameOver(reason = "M·∫•t c√¢n b·∫±ng!") {
        if (animationWatchdog) clearTimeout(animationWatchdog);
        isAnimating = true; isPaused = true; 
        if (threatInterval) clearInterval(threatInterval);
        if (balanceTimerInterval) clearInterval(balanceTimerInterval);
        if (passiveIncreaseInterval) clearInterval(passiveIncreaseInterval);
        if (infoPanelInterval) clearInterval(infoPanelInterval);

        if(gameMode === 'balance'){
            DOMElements.gameOverReason.textContent = reason;
            const timeSurvived = (60 + (currentBalanceLevel-1)*30) - balanceTimeLeft;
            DOMElements.gameOverMessageContainer.innerHTML = `B·∫°n ƒë√£ c√¢n b·∫±ng ƒë∆∞·ª£c ${timeSurvived} gi√¢y.`;
        } else {
            DOMElements.gameOverReason.textContent = "Thu·ªëc l√° ƒë√£ l√†m h·∫°i m·ªôt tr√°i tim.";
            DOMElements.gameOverMessageContainer.innerHTML = `B·∫°n ƒë√£ b·∫£o v·ªá ƒë∆∞·ª£c <span class="font-bold text-pink-600">${score}</span> tr√°i tim.`;
        }
        
        showModal(DOMElements.gameOverModal, DOMElements.gameOverModal.querySelector('#gameOverRestartButton'));
    }

    function updateQuestUI() {
        if (gameMode === 'balance') return;
        DOMElements.questList.innerHTML = '';
        for (const colorIdx in quest.targets) {
            const remaining = Math.max(0, quest.targets[colorIdx] - quest.collected[colorIdx]);
            const item = document.createElement('div');
            item.className = `flex items-center justify-between p-2 rounded-lg transition-all ${remaining === 0 ? 'bg-green-500/30' : 'bg-black/20'}`;
            item.innerHTML = `<div class="w-6 h-6 rounded-full border-2 border-white/20" style="background-color: ${CONFIG.GEM_COLORS[colorIdx]}"></div><span class="font-bold text-white">${remaining}</span>`;
            DOMElements.questList.appendChild(item);
        }
        const remainingHearts = Math.max(0, quest.heartsToSave - quest.heartsSaved);
        const heartItem = document.createElement('div');
        heartItem.className = `flex items-center justify-between p-2 rounded-lg transition-all ${remainingHearts === 0 ? 'bg-green-500/30' : 'bg-black/20'}`;
        heartItem.innerHTML = `<span class="text-2xl">${CONFIG.HEART_EMOJI}</span><span class="font-bold text-white">${remainingHearts}</span>`;
        DOMElements.questList.appendChild(heartItem);
    }

    function updateHealthBar() {
        const percentage = quest.maxDamage > 0 ? Math.min(100, (quest.totalDamage / quest.maxDamage) * 100) : 0;
        DOMElements.healthBar.value = percentage;
    }
    function updateScore() { DOMElements.scoreEl.textContent = score; }
    function updateMoves() { DOMElements.movesEl.textContent = moves; }

    function drawBoard(time) {
        const { ctx } = DOMElements;
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                const gem = board[row][col];
                if (!gem) continue;
                ctx.save();
                ctx.globalAlpha = gem.alpha;
                const centerX = gem.x + gemSize / 2, centerY = gem.y + gemSize / 2;
                ctx.translate(centerX, centerY); ctx.scale(gem.scale, gem.scale); ctx.translate(-centerX, -centerY);
                let cacheKey = gem.special === SPECIAL_TYPES.HYPERCUBE ? SPECIAL_TYPES.HYPERCUBE : (gem.special !== SPECIAL_TYPES.NONE ? `${gem.special}_${gem.colorIndex}` : CONFIG.GEM_COLORS[gem.colorIndex]);
                if (gemCache[cacheKey]) ctx.drawImage(gemCache[cacheKey], gem.x, gem.y, gemSize, gemSize);
                if (gem.isLocked) ctx.drawImage(gemCache['chain'], gem.x, gem.y, gemSize, gemSize);
                if (gem.isHeart) {
                    ctx.save();
                    ctx.translate(gem.x + gemSize / 2, gem.y + gemSize / 2); ctx.scale(Math.sin(time / 300) * 0.1 + 1.1, Math.sin(time / 300) * 0.1 + 1.1);
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0)'; ctx.font = `${gemSize * 0.6}px sans-serif`; ctx.fillText(CONFIG.HEART_EMOJI, 0, 0);
                    ctx.restore();
                }
                ctx.restore();
            }
        }
    }

    function drawHint(time) {
        if (hintGems.length === 2 && !isAnimating) {
            const [gem1, gem2] = hintGems;
            const pulse = (Math.sin(time / 200) + 1) / 2;
            const scale = 1 + 0.05 * pulse;
            const drawPulse = (gem) => {
                if (!gem) return;
                const { ctx } = DOMElements;
                ctx.save();
                const centerX = gem.x + gemSize / 2, centerY = gem.y + gemSize / 2;
                ctx.translate(centerX, centerY); ctx.scale(scale, scale); ctx.translate(-centerX, -centerY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`; ctx.lineWidth = 4;
                ctx.strokeRect(gem.x + 2, gem.y + 2, gemSize - 4, gemSize - 4);
                ctx.restore();
            };
            drawPulse(gem1); drawPulse(gem2);
        }
    }

    function drawParticles() {
        const { ctx } = DOMElements;
        for (let i = particlePool.length - 1; i >= 0; i--) {
            const p = particlePool[i];
            if (!p.active) continue;
            p.x += p.vx; p.y += p.vy; p.alpha -= 0.02;
            if (p.alpha <= 0) { p.active = false; } 
            else {
                ctx.save(); ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }
    }

    function drawSelection(time) {
        if (selectedGem) {
            const { ctx } = DOMElements;
            const pulse = Math.sin(time / 100) * 0.5 + 0.5;
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`; ctx.lineWidth = 4;
            ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
        }
    }

    async function preRenderGems() {
        gemCache = {}; const promises = []; const specials = Object.values(SPECIAL_TYPES); const size = Math.max(1, Math.round(gemSize));
        CONFIG.GEM_COLORS.forEach((col) => { const canvas = renderGemCanvas(col, size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[col] = img; })); } else { gemCache[col] = canvas; } });
        specials.forEach(special => {
            if (special === SPECIAL_TYPES.HYPERCUBE) { const canvas = renderHypercubeCanvas(size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[special] = img; })); } else { gemCache[special] = canvas; } } 
            else if (special !== SPECIAL_TYPES.NONE) { CONFIG.GEM_COLORS.forEach((col, idx) => { const canvas = renderSpecialCanvas(special, col, size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(canvas).then(img => { gemCache[`${special}_${idx}`] = img; })); } else { gemCache[`${special}_${idx}`] = canvas; } }); }
        });
        const chainCanvas = renderChainCanvas(size); if ('createImageBitmap' in window) { promises.push(createImageBitmap(chainCanvas).then(img => { gemCache['chain'] = img; })); } else { gemCache['chain'] = canvas; }
        await Promise.all(promises);
    }
    
    function renderGemCanvas(color, size) {
        const offscreenCanvas = document.createElement('canvas'); offscreenCanvas.width = size; offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        offscreenCtx.shadowColor = 'rgba(0, 0, 0, 0.2)'; offscreenCtx.shadowBlur = 5; offscreenCtx.shadowOffsetX = 2; offscreenCtx.shadowOffsetY = 2;
        const shadeColor = (col, percent) => { let f = parseInt(col.slice(1), 16), t = percent < 0 ? 0 : 255, p = Math.abs(percent), R = f >> 16, G = (f >> 8) & 0xff, B = f & 0xff; const hex = (0x1000000 + (Math.round((t-R)*p)+R)*0x10000 + (Math.round((t-G)*p)+G)*0x100 + (Math.round((t-B)*p)+B)).toString(16).slice(1); return `#${hex.padStart(6,'0')}`; };
        const lightColor = shadeColor(color, 0.6), darkColor = shadeColor(color, -0.6);
        const grad = offscreenCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, half); grad.addColorStop(0, lightColor); grad.addColorStop(1, color);
        offscreenCtx.fillStyle = grad; offscreenCtx.beginPath(); offscreenCtx.moveTo(centerX, centerY - half); offscreenCtx.lineTo(centerX + half, centerY); offscreenCtx.lineTo(centerX, centerY + half); offscreenCtx.lineTo(centerX - half, centerY); offscreenCtx.closePath(); offscreenCtx.fill();
        offscreenCtx.strokeStyle = darkColor; offscreenCtx.lineWidth = 2; offscreenCtx.stroke();
        return offscreenCanvas;
    }

    function renderSpecialCanvas(special, color, size) {
        const canvas = renderGemCanvas(color, size); const ctx = canvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        ctx.fillStyle = 'white'; ctx.shadowColor = 'white'; ctx.shadowBlur = 10;
        if(special === SPECIAL_TYPES.H_BEAM) { ctx.fillRect(centerX - half, centerY - half * 0.1, s, half * 0.2); } 
        else if (special === SPECIAL_TYPES.V_BEAM) { ctx.fillRect(centerX - half * 0.1, centerY - half, half * 0.2, s); } 
        else if (special === SPECIAL_TYPES.BOMB) { ctx.fillStyle = `rgba(255, 255, 255, 0.8)`; ctx.beginPath(); ctx.arc(centerX, centerY, half * 0.6, 0, 2 * Math.PI); ctx.fill(); }
        return canvas;
    }

    function renderHypercubeCanvas(size) {
        const offscreenCanvas = document.createElement('canvas'); offscreenCanvas.width = size; offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d'); const centerX = size / 2, centerY = size / 2; const s = size * 0.85, half = s / 2;
        offscreenCtx.shadowColor = 'rgba(255, 255, 255, 0.7)'; offscreenCtx.shadowBlur = 10;
        for (let i = 0; i < 6; i++) { offscreenCtx.fillStyle = CONFIG.GEM_COLORS[i]; offscreenCtx.beginPath(); offscreenCtx.moveTo(centerX,centerY); const angle1 = (i / 6) * 2 * Math.PI, angle2 = ((i+1) / 6) * 2 * Math.PI; offscreenCtx.arc(centerX,centerY, half, angle1, angle2); offscreenCtx.closePath(); offscreenCtx.fill(); }
        return offscreenCanvas;
    }

    function renderChainCanvas(size) {
        const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d'); const p = size * 0.1, lw = size * 0.08;
        ctx.strokeStyle = 'rgba(200, 200, 220, 0.7)'; ctx.lineWidth = lw; ctx.lineCap = 'round'; ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 4;
        ctx.beginPath(); ctx.moveTo(p, p); ctx.lineTo(size - p, size - p); ctx.moveTo(size - p, p); ctx.lineTo(p, size - p); ctx.stroke();
        return canvas;
    }
    
    // --- MODULE: CORE GAME LOGIC ---
    async function handleSuccessfulMove() {
        if (gameMode === 'balance') {
            balanceMovesMade++;
            if (!hasPossibleMoves(board)) {
                await reshuffleBoard();
            }
            return;
        }

        if (DOMElements.gameOverModal.classList.contains('hidden') && DOMElements.winModal.classList.contains('hidden') && DOMElements.finalWinModal.classList.contains('hidden')) {
            await moveCigarette();
            if (checkGameOver()) return;
            spawnHeartIfNeeded();
            checkWinCondition();
            if (!hasPossibleMoves(board)) {
                await reshuffleBoard();
            }
        }
    }

    async function triggerSpecialCombo(gemA, gemB) {
        // This function is for combos that DO NOT involve a Hypercube.
        const gemsToClear = new Set([gemA, gemB]);
        const { row, col } = gemA; // The combo is centered on the gem that was moved.
        
        const typeA = gemA.special;
        const typeB = gemB.special;

        const isBomb = (type) => type === SPECIAL_TYPES.BOMB;
        const isBeam = (type) => type === SPECIAL_TYPES.H_BEAM || type === SPECIAL_TYPES.V_BEAM;

        // Bomb + Bomb
        if (isBomb(typeA) && isBomb(typeB)) {
            AudioManager.playSfx('bomb');
            for (let r = row - 2; r <= row + 2; r++) {
                for (let c = col - 2; c <= col + 2; c++) {
                    if (r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) {
                        gemsToClear.add(board[r][c]);
                    }
                }
            }
        }
        // Beam + Beam
        else if (isBeam(typeA) && isBeam(typeB)) {
             AudioManager.playSfx('beam');
             for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (board[row][c]) gemsToClear.add(board[row][c]); }
             for (let r = 0; r < CONFIG.GRID_SIZE; r++) { if (board[r][col]) gemsToClear.add(board[r][col]); }
        }
        // Bomb + Beam
        else if ((isBomb(typeA) && isBeam(typeB)) || (isBeam(typeA) && isBomb(typeB))) {
            AudioManager.playSfx('bomb');
            AudioManager.playSfx('beam');
            for (let r = row - 1; r <= row + 1; r++) {
                if (r >= 0 && r < CONFIG.GRID_SIZE) {
                    for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (board[r][c]) gemsToClear.add(board[r][c]); }
                }
            }
            for (let c = col - 1; c <= col + 1; c++) {
                if (c >= 0 && c < CONFIG.GRID_SIZE) {
                    for (let r = 0; r < CONFIG.GRID_SIZE; r++) { if (board[r][c]) gemsToClear.add(board[r][c]); }
                }
            }
        }

        if (gemsToClear.size > 2) {
            await cascadeMatches(Array.from(gemsToClear));
        }
    }

    async function processSwap(gem1, gem2) {
        if (isAnimating || isPaused || gem1.isLocked || gem2.isLocked) return;
        isAnimating = true; 
        selectedGem = null;
        
        if (animationWatchdog) clearTimeout(animationWatchdog);
        animationWatchdog = setTimeout(() => {
            console.error("WATCHDOG: Game logic took too long. Forcing state reset.");
            isAnimating = false; isPaused = false; resetHintTimer();
        }, CONFIG.WATCHDOG_TIMEOUT);

        try {
            const isHyperCombo = gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE;
            const isSpecialCombo = gem1.special !== SPECIAL_TYPES.NONE && gem2.special !== SPECIAL_TYPES.NONE;

            if (isHyperCombo) {
                moves++; 
                updateMoves();
                const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
                const otherGem = hypercube === gem1 ? gem2 : gem1;
                await triggerHypercube(hypercube, otherGem);
                await handleSuccessfulMove();
            } else if (isSpecialCombo) {
                moves++;
                updateMoves();
                await swapGems(gem1, gem2);
                await triggerSpecialCombo(gem1, gem2); // Combo happens at gem1's new location
                await handleSuccessfulMove();
            } else {
                const startPos1 = { row: gem1.row, col: gem1.col }, startPos2 = { row: gem2.row, col: gem2.col };
                await swapGems(gem1, gem2);
                const matchInfo = findMatchesAndSpecial(startPos1, startPos2);
                if (matchInfo.allMatches.length > 0) {
                    moves++; 
                    updateMoves();
                    await cascadeMatches(matchInfo.allMatches, matchInfo.specialToCreate);
                    await handleSuccessfulMove();
                } else {
                    await sleep(100);
                    await swapGems(gem1, gem2);
                }
            }
        } catch(error) { 
            console.error("Error during swap process:", error); 
        } finally {
            clearTimeout(animationWatchdog);
            isAnimating = false;
            resetHintTimer();
        }
    }

    async function cascadeMatches(initialMatches, specialToCreate = null) {
        try {
            let gemsToClear = new Set(initialMatches), processedSpecials = new Set();
            while (true) {
                let newGemsFromExplosion = new Set(), foundNewExplosion = false;
                for (const gem of gemsToClear) {
                    if (gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                        foundNewExplosion = true; processedSpecials.add(gem);
                        switch (gem.special) {
                            case SPECIAL_TYPES.H_BEAM: case SPECIAL_TYPES.V_BEAM: AudioManager.playSfx('beam'); break;
                            case SPECIAL_TYPES.BOMB: AudioManager.playSfx('bomb'); break;
                        }
                        getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                    }
                }
                if (!foundNewExplosion) break;
                newGemsFromExplosion.forEach(g => gemsToClear.add(g));
            }
            const savedAHeart = await handleMatches(Array.from(gemsToClear), specialToCreate);
            await sleep(150); await shiftAndRefill();
            if (savedAHeart) await showFact();
            const matchGroups = findMatches(board, true);
            if (matchGroups.length > 0) {
                await cascadeMatches([...new Set(matchGroups.flat())], findSpecialFromCascade(matchGroups));
            } else {
                if (gameMode !== 'balance' && await moveHearts()) {
                    const newMatchesFromHeartsGroups = findMatches(board, true);
                    if (newMatchesFromHeartsGroups.length > 0) {
                        await cascadeMatches([...new Set(newMatchesFromHeartsGroups.flat())], findSpecialFromCascade(newMatchesFromHeartsGroups));
                    }
                }
            }
        } catch (err) { console.error('Error in cascadeMatches:', err); if (!currentModal) { isAnimating = false; isPaused = false; resetHintTimer(); } }
    }

    async function handleMatches(matches, specialToCreate) {
        if (matches.length > 0) AudioManager.playSfx('match');
        const promises = []; let heartSaved = false; let collectedForQuest = {};
        let unlockedGems = new Set();
        matches.forEach(gem => {
            const neighbors = [{ r: gem.row - 1, c: gem.col }, { r: gem.row + 1, c: gem.col }, { r: gem.row, c: gem.col - 1 }, { r: gem.row, c: gem.col + 1 }];
            neighbors.forEach(n => { if (n.r >= 0 && n.r < CONFIG.GRID_SIZE && n.c >= 0 && n.c < CONFIG.GRID_SIZE) { const neighborGem = board[n.r][n.c]; if (neighborGem && neighborGem.isLocked) unlockedGems.add(neighborGem); } });
        });
        
        for (const gem of unlockedGems) {
            gem.isLocked = false;
            const unlockAnimation = async () => {
                await animate(gem, { scale: 1.2 }, 100);
                await animate(gem, { scale: 1 }, 100);
            };
            promises.push(unlockAnimation());
        }

        if (unlockedGems.size > 0) AudioManager.playSfx('unlock');
        
        let studyGemsCount = 0;
        let playGemsCount = 0;

        matches.forEach(gem => {
            if (!gem || !board[gem.row] || board[gem.row][gem.col] !== gem) return;
            if (specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) return;
            
            if (gameMode !== 'balance' && gem.isHeart) { 
                score++; quest.heartsSaved++; updateScore(); heartSaved = true; 
            }

            const colorIdx = gem.colorIndex;

            if (gameMode === 'balance') {
                if (colorIdx === CONFIG.BALANCE_MODE.STUDY_GEM_INDEX) studyGemsCount++;
                if (colorIdx === CONFIG.BALANCE_MODE.PLAY_GEM_INDEX) playGemsCount++;
            } else if (quest.targets[colorIdx] !== undefined) {
                collectedForQuest[colorIdx] = (collectedForQuest[colorIdx] || 0) + 1;
            }

            createParticleBurst(gem.x + gemSize / 2, gem.y + gemSize / 2, CONFIG.GEM_COLORS[gem.colorIndex]);
            promises.push(new Promise(async (resolve) => {
                if (gem) {
                    await animate(gem, { scale: 0, alpha: 0 }, CONFIG.ANIM_CLEAR_SPEED, easing.easeInQuad).catch(console.error);
                    if (board[gem.row] && board[gem.row][gem.col] === gem) board[gem.row][gem.col] = null;
                } resolve();
            }));
        });
        await Promise.all(promises);

        if (gameMode === 'balance') {
            // Logic m·ªõi: ƒÇn m√†u n√†y, gi·∫£m thanh kia
            const reductionAmount = CONFIG.BALANCE_MODE.POINTS_PER_GEM_REDUCTION;
            studyValue -= playGemsCount * reductionAmount;
            playValue -= studyGemsCount * reductionAmount;

            updateBalanceBars();
        } else {
            updateQuestProgress(collectedForQuest);
        }

        if (specialToCreate) {
            let gem = board[specialToCreate.row] && board[specialToCreate.row][specialToCreate.col];
            if (!gem) {
                gem = { row: specialToCreate.row, col: specialToCreate.col, x: specialToCreate.col * gemSize, y: specialToCreate.row * gemSize, colorIndex: specialToCreate.colorIndex ?? Math.floor(Math.random() * CONFIG.GEM_COLORS.length), isHeart: false, isLocked: false, special: SPECIAL_TYPES.NONE, scale: 0, alpha: 1 };
                board[specialToCreate.row][specialToCreate.col] = gem;
            }
            gem.special = specialToCreate.special;
            if (specialToCreate.special !== SPECIAL_TYPES.HYPERCUBE) gem.colorIndex = specialToCreate.colorIndex;
            gem.isHeart = false;
            await animate(gem, { scale: 1.5 }, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad);
            await animate(gem, { scale: 1 }, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad);
        }
        return heartSaved;
    }

    function findMatches(currentBoard, returnGroups = false) { const matches = new Set(); const groups = []; for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE - 2;) { const gem = currentBoard[r][c]; if (gem) { let match = [gem]; for (let i = c + 1; i < CONFIG.GRID_SIZE; i++) { const nextGem = currentBoard[r][i]; if (nextGem && nextGem.colorIndex === gem.colorIndex) { match.push(nextGem); } else { break; } } if (match.length >= 3) { match.forEach(m => matches.add(m)); if (returnGroups) groups.push(match); } c += match.length > 1 ? match.length : 1; } else { c++; } } } for (let c = 0; c < CONFIG.GRID_SIZE; c++) { for (let r = 0; r < CONFIG.GRID_SIZE - 2;) { const gem = currentBoard[r][c]; if (gem) { let match = [gem]; for (let i = r + 1; i < CONFIG.GRID_SIZE; i++) { const nextGem = currentBoard[i][c]; if (nextGem && nextGem.colorIndex === gem.colorIndex) { match.push(nextGem); } else { break; } } if (match.length >= 3) { match.forEach(m => matches.add(m)); if (returnGroups) groups.push(match); } r += match.length > 1 ? match.length : 1; } else { r++; } } } return returnGroups ? groups : Array.from(matches); }
    function findSpecialFromCascade(matchGroups) { let bestSpecial = null; let bestRank = 0; let processedInGroups = new Set(); for (const group of matchGroups) { if (group.length >= 5) { const middleGem = group[Math.floor(group.length / 2)]; if (processedInGroups.has(middleGem)) continue; bestRank = 3; bestSpecial = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: middleGem.colorIndex, row: middleGem.row, col: middleGem.col }; group.forEach(g => processedInGroups.add(g)); return bestSpecial; } } for (let i = 0; i < matchGroups.length; i++) { for (let j = i + 1; j < matchGroups.length; j++) { const group1 = matchGroups[i]; const group2 = matchGroups[j]; const intersection = group1.find(gem1 => group2.some(gem2 => gem1 === gem2)); if (intersection && !processedInGroups.has(intersection)) { if (bestRank < 2) { bestRank = 2; bestSpecial = { special: SPECIAL_TYPES.BOMB, colorIndex: intersection.colorIndex, row: intersection.row, col: intersection.col }; group1.forEach(g => processedInGroups.add(g)); group2.forEach(g => processedInGroups.add(g)); } } } } if (bestRank < 2) { for (const group of matchGroups) { if (group.length === 4) { const gemToReplace = group[1]; if (processedInGroups.has(gemToReplace)) continue; if (bestRank < 1) { bestRank = 1; const isHorizontal = group[0].row === group[1].row; bestSpecial = { special: isHorizontal ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: gemToReplace.colorIndex, row: gemToReplace.row, col: gemToReplace.col }; group.forEach(g => processedInGroups.add(g)); } } } } return bestSpecial; }
    
    function findMatchesAndSpecial(startPos1, startPos2) {
        const allMatches = new Set();
        const checkLine = (line) => {
            const res = [];
            for (let i = 0; i < line.length - 2; i++) {
                const g = line[i];
                if (!g) continue;
                let len = 1;
                while (i + len < line.length && line[i + len] && line[i + len].colorIndex === g.colorIndex) len++;
                if (len >= 3) {
                    const matchGroup = line.slice(i, i + len);
                    res.push(matchGroup);
                    i += len - 1;
                }
            }
            return res;
        };
        const h1 = checkLine(board[startPos1.row] || []);
        const v1 = checkLine(board.map(r => r[startPos1.col]) || []);
        const h2 = checkLine(board[startPos2.row] || []);
        const v2 = checkLine(board.map(r => r[startPos2.col]) || []);
        const groups = [h1, v1, h2, v2];
        for (const gArr of groups) {
            for (const match of gArr) {
                for (const gem of match) {
                    allMatches.add(gem);
                }
            }
        }
        let specialToCreate = null;
        const matchesArray = Array.from(allMatches);
        let intersectionGem = null;
        const movedGem = board[startPos1.row][startPos1.col];
        const otherGem = board[startPos2.row][startPos2.col];
        const checkGems = [movedGem, otherGem];
        for (const gem of checkGems) {
            if (!gem || !matchesArray.includes(gem)) continue;
            const horizontalMatch = matchesArray.filter(g => g.row === gem.row && g.colorIndex === gem.colorIndex);
            const verticalMatch = matchesArray.filter(g => g.col === gem.col && g.colorIndex === gem.colorIndex);
            if (horizontalMatch.length >= 3 && verticalMatch.length >= 3) {
                intersectionGem = gem;
                break;
            }
        }
        if (intersectionGem) {
            specialToCreate = { special: SPECIAL_TYPES.BOMB, colorIndex: intersectionGem.colorIndex, row: intersectionGem.row, col: intersectionGem.col };
        } else {
            const allLineMatches = [...h1, ...v1, ...h2, ...v2].filter(match => match.some(g => g === movedGem || g === otherGem));
            allLineMatches.sort((a, b) => b.length - a.length);
            if (allLineMatches.length > 0) {
                const longestMatch = allLineMatches[0];
                const pivotGem = longestMatch.includes(movedGem) ? movedGem : otherGem;
                if (longestMatch.length >= 5) {
                    specialToCreate = { special: SPECIAL_TYPES.HYPERCUBE, colorIndex: pivotGem.colorIndex, row: pivotGem.row, col: pivotGem.col };
                } else if (longestMatch.length === 4) {
                    const isHorizontal = longestMatch[0].row === longestMatch[1].row;
                    specialToCreate = { special: isHorizontal ? SPECIAL_TYPES.H_BEAM : SPECIAL_TYPES.V_BEAM, colorIndex: pivotGem.colorIndex, row: pivotGem.row, col: pivotGem.col };
                }
            }
        }
        return { allMatches: matchesArray, specialToCreate };
    }

    async function shiftAndRefill() { const shiftPromises = []; for (let c = 0; c < CONFIG.GRID_SIZE; c++) { let emptySlots = 0; for (let r = CONFIG.GRID_SIZE - 1; r >= 0; r--) { if (board[r][c] === null) { emptySlots++; } else if (emptySlots > 0) { const gem = board[r][c]; board[r + emptySlots][c] = gem; board[r][c] = null; gem.row += emptySlots; shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300, easing.easeOutQuad)); } } } await Promise.all(shiftPromises); const refillPromises = []; for (let c = 0; c < CONFIG.GRID_SIZE; c++) { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { if (board[r][c] === null) { const newGem = { colorIndex: Math.floor(Math.random() * CONFIG.GEM_COLORS.length), isHeart: false, isLocked: false, special: SPECIAL_TYPES.NONE, row: r, col: c, x: c * gemSize, y: (r - CONFIG.GRID_SIZE) * gemSize, scale: 1, alpha: 1, }; if (gameMode !== 'balance' && currentLevel >= 1 && isFreePlayMode && Math.random() < 0.05 * Math.min(currentLevel, 4)) { newGem.isLocked = true; } board[r][c] = newGem; refillPromises.push(animate(newGem, { y: r * gemSize }, CONFIG.ANIM_FALL_SPEED, easing.easeOutQuad)); } } } await Promise.all(refillPromises); }
    async function reshuffleBoard() { isAnimating = true; const promises = []; board.flat().forEach(gem => { if (gem) { promises.push(animate(gem, { alpha: 0, scale: 0 }, 300)); } }); await Promise.all(promises); let attempts = 0; do { createBoard(); attempts++; if (attempts > 100) { console.error("Could not generate a board with possible moves."); break; } } while (!hasPossibleMoves(board)); const refillPromises = []; board.flat().forEach(gem => { if (gem) { gem.alpha = 0; gem.scale = 0; refillPromises.push(animate(gem, { alpha: 1, scale: 1 }, 300)); } }); await Promise.all(refillPromises); isAnimating = false; resetHintTimer(); }
    
    function checkWinCondition() {
        const objectivesMet = quest.totalDamage >= quest.maxDamage && quest.heartsSaved >= quest.heartsToSave;
        if (objectivesMet) {
            if (isFreePlayMode) {
                goToNextLevel(true);
            } else {
                isAnimating = true;
                isPaused = true;
                if (threatInterval) clearInterval(threatInterval);

                // Save progress
                if (currentDifficulty === 'easy' && currentLevel === 1) {
                    localStorage.setItem('kimcuong_easy_completed', 'true');
                }
                if (currentDifficulty === 'hard' && currentLevel === 3) {
                    localStorage.setItem('kimcuong_hard_completed', 'true');
                }

                if (currentLevel >= CONFIG.FINAL_LEVEL) {
                    showModal(DOMElements.finalWinModal, DOMElements.restartGameButton);
                } else {
                    DOMElements.winLevelText.textContent = `B·∫°n ƒë√£ ho√†n th√†nh m√†n ${currentLevel}!`;
                    showModal(DOMElements.winModal, DOMElements.nextLevelButton);
                }
            }
        }
    }
    
    function handlePointerStart(e) {
        e.preventDefault();
        if (isPausedForFact) {
            isPaused = false;
            isPausedForFact = false;
            resetHintTimer();
        }
        if (isAnimating || isPaused) return;
        resetHintTimer();
        hintGems = [];
        const pos = getEventPos(e);
        const col = Math.floor(pos.x / gemSize);
        const row = Math.floor(pos.y / gemSize);
        if (row < 0 || row >= CONFIG.GRID_SIZE || col < 0 || col >= CONFIG.GRID_SIZE) {
            selectedGem = null;
            return;
        }
        const clickedGem = board[row][col];
        if (clickedGem.isLocked) {
            AudioManager.playSfx('unlock');
            return;
        }
        isDragging = true;
        startDragPos = pos;
        startGem = clickedGem;
        if (selectedGem) {
            if (selectedGem === clickedGem) {
                selectedGem = null;
                return;
            }
            const isAdjacent = Math.abs(selectedGem.row - clickedGem.row) + Math.abs(selectedGem.col - clickedGem.col) === 1;
            if (isAdjacent) {
                processSwap(selectedGem, clickedGem);
            } else {
                AudioManager.playSfx('select');
                selectedGem = clickedGem;
            }
        } else {
            AudioManager.playSfx('select');
            selectedGem = clickedGem;
        }
    }
    
    function handlePointerMove(e) { e.preventDefault(); if (!isDragging || isAnimating || isPaused) return; const pos = getEventPos(e); const deltaX = pos.x - startDragPos.x; const deltaY = pos.y - startDragPos.y; if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) { let endGem = null; if (Math.abs(deltaX) > Math.abs(deltaY)) { const endCol = startGem.col + (deltaX > 0 ? 1 : -1); if (endCol >= 0 && endCol < CONFIG.GRID_SIZE) { endGem = board[startGem.row][endCol]; } } else { const endRow = startGem.row + (deltaY > 0 ? 1 : -1); if (endRow >= 0 && endRow < CONFIG.GRID_SIZE) { endGem = board[endRow][startGem.col]; } } if (endGem && !endGem.isLocked && startGem !== endGem) { isDragging = false; selectedGem = null; processSwap(startGem, endGem); } } }
    function handlePointerEnd(e) { isDragging = false; startGem = null; }
    const easing = { easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t, easeInQuad: t => t * t, easeOutQuad: t => t * (2 - t) }; function animate(target, toProperties, duration, easeFunc = easing.easeInOutQuad) { return new Promise(resolve => { const startProps = {}; const endProps = {}; for (const key in toProperties) { const cur = typeof target[key] === 'number' && !isNaN(target[key]) ? target[key] : 0; startProps[key] = cur; endProps[key] = Number(toProperties[key]); } animations.push({ target, startProperties: startProps, endProperties: endProps, duration, easeFunc, startTime: performance.now(), onComplete: resolve }); }); }
    function handleAnimations(time) { const now = performance.now(); for (let i = animations.length - 1; i >= 0; i--) { const anim = animations[i]; const elapsed = now - (anim.startTime || now); const duration = Number(anim.duration) || 0; const t = duration > 0 ? Math.min(elapsed / duration, 1) : 1; const progress = (typeof anim.easeFunc === 'function') ? anim.easeFunc(t) : t; if (t >= 1) { for (const key in anim.endProperties) { if (anim.target) anim.target[key] = anim.endProperties[key]; } try { if (anim.onComplete) anim.onComplete(); } catch (err) { console.error('Error in animation onComplete:', err); } animations.splice(i, 1); } else { for (const key in anim.endProperties) { if (anim.target) { const start = anim.startProperties[key] || 0; const end = anim.endProperties[key]; anim.target[key] = start + (end - start) * progress; } } } } }
    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    function toggleFullScreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`); }); } else { if (document.exitFullscreen) { document.exitFullscreen(); } } }
    function updateFullscreenIcons() { const fullscreenIconOpen = document.getElementById('fullscreen-icon-open'); const fullscreenIconClose = document.getElementById('fullscreen-icon-close'); if (document.fullscreenElement) { fullscreenIconOpen.classList.add('hidden'); fullscreenIconClose.classList.remove('hidden'); } else { fullscreenIconOpen.classList.remove('hidden'); fullscreenIconClose.classList.add('hidden'); } }
    
    function trackPupil(pupilElement, e) {
        if (!DOMElements || !DOMElements.characterContainerEl) return;
        const svgRect = DOMElements.characterContainerEl.getBoundingClientRect();
        if (!svgRect || svgRect.width === 0) return;

        const pupilData = { 
            cx: parseFloat(pupilElement.getAttribute('cx')), 
            cy: parseFloat(pupilElement.getAttribute('cy')) 
        }; 
        const pupilX = svgRect.left + (pupilData.cx / 200) * svgRect.width; 
        const pupilY = svgRect.top + (pupilData.cy / 100) * svgRect.height; 
        const angle = Math.atan2(e.clientY - pupilY, e.clientX - pupilX); 
        const maxMove = 4; 
        const moveX = Math.cos(angle) * maxMove; 
        const moveY = Math.sin(angle) * maxMove; 
        pupilElement.setAttribute('transform', `translate(${moveX} ${moveY})`);
    }

    function getParticle() { for (let i = 0; i < particlePool.length; i++) { if (!particlePool[i].active) return particlePool[i]; } return null; }
    function createParticleBurst(x, y, color) { for (let i = 0; i < 10; i++) { const p = getParticle(); if (p) { p.active = true; p.x = x; p.y = y; p.vx = (Math.random() - 0.5) * 6; p.vy = (Math.random() - 0.5) * 6; p.size = Math.random() * 4 + 2; p.color = color; p.alpha = 1; } } }
    function setupLevel(level) { currentLevel = level; DOMElements.levelEl.textContent = level; const baseRequirement = 15 + (level - 1) * 8; const numTargets = Math.min(2 + Math.floor(level / 2), 5); quest = { targets: {}, collected: {}, totalDamage: 0, maxDamage: 0, heartsToSave: level, heartsSaved: 0 }; let availableColors = Array.from({ length: CONFIG.GEM_COLORS.length }, (_, i) => i); for (let i = 0; i < numTargets; i++) { if (availableColors.length === 0) break; const colorIndex = availableColors.splice(Math.floor(Math.random() * availableColors.length), 1)[0]; const requirement = Math.floor(baseRequirement * (Math.random() * 0.4 + 0.8)); quest.targets[colorIndex] = requirement; quest.collected[colorIndex] = 0; quest.maxDamage += requirement; } updateQuestUI(); updateHealthBar(); }
    async function resizeCanvas() { 
        const container = DOMElements.canvas.parentElement;
        if (!container) return;
        const containerWidth = container.clientWidth;
        const dpr = window.devicePixelRatio || 1; 
        DOMElements.canvas.style.width = containerWidth + 'px'; 
        DOMElements.canvas.style.height = containerWidth + 'px'; 
        DOMElements.canvas.width = Math.floor(containerWidth * dpr); 
        DOMElements.canvas.height = Math.floor(containerWidth * dpr); 
        DOMElements.ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
        gemSize = containerWidth / CONFIG.GRID_SIZE; 
        await preRenderGems(); 
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if(board[r] && board[r][c]) { board[r][c].x = c * gemSize; board[r][c].y = r * gemSize; } } } 
        if (gameMode !== 'balance') updateCigarettePosition(); 
    }
    function onResizeDebounced() { if (resizeTimer) clearTimeout(resizeTimer); resizeTimer = setTimeout(() => { resizeCanvas(); }, 150); }
    function updateCigarettePosition(col = cigarette.col, isLunging = false) { const columnCenter = (col * gemSize) + (gemSize / 2); const svgScaledWidth = 200 * 0.7; const translateX = columnCenter - (svgScaledWidth / 2); let scale = 0.7; let rotate = 0; let translateY = 0; if (isLunging) { scale = 0.8; translateY = 10; } else if (DOMElements.characterContainerEl.classList.contains('attacking')) { scale = 0.8; rotate = -5; } DOMElements.characterContainerEl.style.transform = `translateX(${translateX}px) translateY(${translateY}px) scale(${scale}) rotate(${rotate}deg)`; }
    function createBoard() { board = []; for (let row = 0; row < CONFIG.GRID_SIZE; row++) { board[row] = []; for (let col = 0; col < CONFIG.GRID_SIZE; col++) { let possibleColors = Array.from({ length: CONFIG.GEM_COLORS.length }, (_, i) => i); if (col >= 2 && board[row][col-1].colorIndex === board[row][col-2].colorIndex) { const colorToRemove = board[row][col-1].colorIndex; possibleColors = possibleColors.filter(c => c !== colorToRemove); } if (row >= 2 && board[row-1][col].colorIndex === board[row-2][col].colorIndex) { const colorToRemove = board[row-1][col].colorIndex; possibleColors = possibleColors.filter(c => c !== colorToRemove); } const colorIndex = possibleColors[Math.floor(Math.random() * possibleColors.length)]; board[row][col] = { colorIndex: colorIndex, isHeart: false, isLocked: false, special: SPECIAL_TYPES.NONE, row: row, col: col, x: col * gemSize, y: row * gemSize, scale: 1, alpha: 1, }; } } }
    function swapGems(gem1, gem2) { const r1 = gem1.row, c1 = gem1.col; const r2 = gem2.row, c2 = gem2.col; board[r1][c1] = gem2; board[r2][c2] = gem1; gem1.row = r2; gem1.col = c2; gem2.row = r1; gem2.col = c1; const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad); const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad); return Promise.all([p1, p2]); }
    function getSpecialEffectGems(gem) { let affected = new Set(); if (gem.special === SPECIAL_TYPES.H_BEAM) { for(let c=0; c<CONFIG.GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); } } else if (gem.special === SPECIAL_TYPES.V_BEAM) { for(let r=0; r<CONFIG.GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); } } else if (gem.special === SPECIAL_TYPES.BOMB) { for(let r = gem.row - 1; r <= gem.row + 1; r++) { for(let c = gem.col - 1; c <= gem.col + 1; c++) { if(r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) { affected.add(board[r][c]); } } } } return affected; }
    async function triggerHypercube(hypercube, otherGem) {
        AudioManager.playSfx('hypercube');
        let gemsToClear = new Set([hypercube, otherGem]);

        // Hypercube + Hypercube: Clear the whole board
        if (otherGem.special === SPECIAL_TYPES.HYPERCUBE) {
            board.flat().forEach(g => { if (g) gemsToClear.add(g); });
        }
        // Hypercube + Special (Bomb or Beam)
        else if (otherGem.special !== SPECIAL_TYPES.NONE) {
            const specialTypeToCreate = otherGem.special;
            const targetColorIndex = otherGem.colorIndex;
            const transformationPromises = [];

            board.flat().forEach(g => {
                if (g && g.colorIndex === targetColorIndex) {
                    g.special = specialTypeToCreate;
                    // Add a small visual pulse to indicate transformation
                    transformationPromises.push(animate(g, { scale: 1.2 }, 100).then(() => animate(g, { scale: 1 }, 100)));
                    gemsToClear.add(g); // These will be activated in the cascade
                }
            });
            await Promise.all(transformationPromises);
        }
        // Hypercube + Normal Gem
        else {
            const targetColorIndex = otherGem.colorIndex;
            board.flat().forEach(g => {
                if (g && g.colorIndex === targetColorIndex) {
                    gemsToClear.add(g);
                }
            });
        }

        await cascadeMatches(Array.from(gemsToClear));
    }
    function spawnHeartIfNeeded(isFirst = false) { if (isFirst || (moves > 0 && moves % CONFIG.MOVES_PER_HEART_SPAWN === 0)) { let availableCols = []; for (let c = 0; c < CONFIG.GRID_SIZE; c++) { const gem = board[CONFIG.GRID_SIZE - 1][c]; const gemAbove = board[CONFIG.GRID_SIZE - 2] ? board[CONFIG.GRID_SIZE - 2][c] : null; const canSpawn = gem && !gem.isHeart && gem.special === SPECIAL_TYPES.NONE; const isNotBlockedByLock = !gemAbove || !gemAbove.isLocked; if (canSpawn && isNotBlockedByLock) { availableCols.push(c); } } if (availableCols.length > 0) { const col = availableCols[Math.floor(Math.random() * availableCols.length)]; const gem = board[CONFIG.GRID_SIZE - 1][col]; gem.isHeart = true; gem.special = SPECIAL_TYPES.NONE; animate(gem, {scale: 1.5}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad) .then(() => animate(gem, {scale: 1}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad)); } } }
    async function moveHearts() { const movePromises = []; let movedGems = new Set(); let heartsDidMove = false; for (let r = 1; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { const gem = board[r][c]; if (gem && gem.isHeart && !movedGems.has(gem)) { const gemAbove = board[r - 1][c]; if (gemAbove && !gemAbove.isHeart) { heartsDidMove = true; board[r - 1][c] = gem; board[r][c] = gemAbove; gem.row = r - 1; gemAbove.row = r; movePromises.push(animate(gem, { y: gem.row * gemSize }, 200, easing.easeInOutQuad)); movePromises.push(animate(gemAbove, { y: gemAbove.row * gemSize }, 200, easing.easeInOutQuad)); movedGems.add(gem); movedGems.add(gemAbove); } } } } await Promise.all(movePromises); return heartsDidMove; }
    async function moveCigarette() { let highestHeart = null; let minRow = CONFIG.GRID_SIZE; board.flat().filter(g => g && g.isHeart).forEach(g => { if (g.row < minRow) { minRow = g.row; highestHeart = g; } }); if (highestHeart) { if (Math.random() < CONFIG.CIGARETTE_LUNGE_CHANCE) { const originalCol = cigarette.col; const targetCol = highestHeart.col; updateCigarettePosition(targetCol, true); await sleep(150); updateCigarettePosition(originalCol); await sleep(400); } if (cigarette.col < highestHeart.col) cigarette.col++; else if (cigarette.col > highestHeart.col) cigarette.col--; } updateCigarettePosition(); }
    function checkGameOver() { if(gameMode !== 'balance' && board[0][cigarette.col] && board[0][cigarette.col].isHeart) { showGameOver("Thu·ªëc l√° ƒë√£ l√†m h·∫°i m·ªôt tr√°i tim."); return true; } return false; }
    function updateQuestProgress(collected) { for (const key in collected) { const colorIdx = parseInt(key, 10); const amount = collected[key]; if (!quest.targets.hasOwnProperty(colorIdx)) continue; const before = quest.collected[colorIdx] || 0; const remaining = Math.max(0, quest.targets[colorIdx] - before); const used = Math.min(remaining, amount); quest.collected[colorIdx] += used; quest.totalDamage += used; } updateHealthBar(); updateQuestUI(); }
    function goToNextLevel(isFreeModeLevelUp = false) {
        if (!isFreeModeLevelUp) {
            hideModal(DOMElements.winModal);
        } else {
            // C·∫≠p nh·∫≠t v√† l∆∞u ƒëi·ªÉm cao cho ch·∫ø ƒë·ªô T·ª± do
            const highscore = parseInt(localStorage.getItem('kimcuong_free_highscore') || '1');
            if (currentLevel + 1 > highscore) {
                localStorage.setItem('kimcuong_free_highscore', currentLevel + 1);
                DOMElements.freeModeHighscoreEl.textContent = `K·ª∑ l·ª•c: C·∫•p ${currentLevel + 1}`;
            }
        }
        isAnimating = false;
        isPaused = false;
        setupLevel(currentLevel + 1);
        moves = 0;
        updateMoves(); do { createBoard(); } while(!hasPossibleMoves(board)); spawnHeartIfNeeded(true); if (threatInterval) clearInterval(threatInterval); threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL); }
    function hasPossibleMoves(currentBoard) { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (c < CONFIG.GRID_SIZE - 1) { const gem1 = currentBoard[r][c]; const gem2 = currentBoard[r][c+1]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [currentBoard[r][c], currentBoard[r][c+1]] = [gem2, gem1]; const matches = findMatches(currentBoard); [currentBoard[r][c], currentBoard[r][c+1]] = [gem1, gem2]; if (matches.length > 0) return true; } if (r < CONFIG.GRID_SIZE - 1) { const gem1 = currentBoard[r][c]; const gem2 = currentBoard[r+1][c]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [currentBoard[r][c], currentBoard[r+1][c]] = [gem2, gem1]; const matches = findMatches(currentBoard); [currentBoard[r][c], currentBoard[r+1][c]] = [gem1, gem2]; if (matches.length > 0) return true; } } } return false; }
    function findFirstPossibleMove() { for (let r = 0; r < CONFIG.GRID_SIZE; r++) { for (let c = 0; c < CONFIG.GRID_SIZE; c++) { if (c < CONFIG.GRID_SIZE - 1) { const gem1 = board[r][c]; const gem2 = board[r][c+1]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [board[r][c], board[r][c+1]] = [gem2, gem1]; const matches = findMatches(board); [board[r][c], board[r][c+1]] = [gem1, gem2]; if (matches.length > 0) return { gem1, gem2 }; } if (r < CONFIG.GRID_SIZE - 1) { const gem1 = board[r][c]; const gem2 = board[r+1][c]; if (!gem1 || !gem2 || gem1.isLocked || gem2.isLocked) continue; [board[r][c], board[r+1][c]] = [gem2, gem1]; const matches = findMatches(board); [board[r][c], board[r+1][c]] = [gem1, gem2]; if (matches.length > 0) return { gem1, gem2 }; } } } return null; }
    function resetHintTimer() { if (hintTimeout) clearTimeout(hintTimeout); hintGems = []; hintTimeout = setTimeout(() => { if (!isAnimating && !isPaused) { const move = findFirstPossibleMove(); if (move) { hintGems = [move.gem1, move.gem2]; } } }, CONFIG.HINT_TIMEOUT); }
    function getEventPos(e) { const rect = DOMElements.canvas.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
    async function init() { await resizeCanvas(); DOMElements.ctx.font = `${gemSize * 0.7}px sans-serif`; cigarette.col = Math.floor(CONFIG.GRID_SIZE / 2); score = 0; moves = 0; setupLevel(1); do { createBoard(); } while (!hasPossibleMoves(board)); spawnHeartIfNeeded(true); updateCigarettePosition(); selectedGem = null; isAnimating = false; isPaused = false; animations = []; particlePool = []; for (let i = 0; i < CONFIG.MAX_PARTICLES; i++) { particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', alpha: 0 }); } factsShown = []; if (threatInterval) clearInterval(threatInterval); threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL); updateScore(); updateMoves(); updateQuestUI(); updateHealthBar(); DOMElements.levelEl.textContent = currentLevel; requestAnimationFrame(gameLoop); resetHintTimer(); }
    
    function startInfoPanelAnimation() {
        if (infoPanelInterval) clearInterval(infoPanelInterval);

        const facts = Array.from(DOMElements.factsList.children);
        const skills = Array.from(DOMElements.skillsList.children);
        let currentFactIndex = 0;
        let currentSkillIndex = 0;

        // Hide all initially
        facts.forEach(fact => fact.classList.remove('visible'));
        skills.forEach(skill => skill.classList.remove('visible'));

        const cycleInfo = () => {
            facts.forEach((fact, index) => {
                fact.classList.toggle('visible', index === currentFactIndex);
            });
            skills.forEach((skill, index) => {
                skill.classList.toggle('visible', index === currentSkillIndex);
            });

            currentFactIndex = (currentFactIndex + 1) % facts.length;
            currentSkillIndex = (currentSkillIndex + 1) % skills.length;
        };

        cycleInfo(); // Show the first items immediately
        infoPanelInterval = setInterval(cycleInfo, CONFIG.BALANCE_MODE.INFO_PANEL_INTERVAL);
    }
    
    async function initBalanceMode() {
        await resizeCanvas();
        DOMElements.ctx.font = `${gemSize * 0.7}px sans-serif`;
        createBoard();
        while (!hasPossibleMoves(board)) { createBoard(); }
        
        selectedGem = null; isAnimating = false; isPaused = false; animations = [];
        particlePool = []; for (let i = 0; i < CONFIG.MAX_PARTICLES; i++) { particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', alpha: 0 }); }
        
        setupBalanceLevel(1);
        startInfoPanelAnimation();
        
        requestAnimationFrame(gameLoop);
        resetHintTimer();
    }

    function setupBalanceLevel(level) {
        currentBalanceLevel = level;
        balanceTimeLeft = 60 + (level - 1) * 30;
        studyValue = 30; // B·∫Øt ƒë·∫ßu ·ªü m·ª©c th·∫•p h∆°n ƒë·ªÉ c√≥ kh√¥ng gian tƒÉng
        playValue = 30;
        balanceMovesMade = 0;
        
        DOMElements.balanceLevelEl.textContent = level;
        DOMElements.balanceTimerEl.textContent = balanceTimeLeft;
        updateBalanceBars();
        
        if (balanceTimerInterval) clearInterval(balanceTimerInterval);
        balanceTimerInterval = setInterval(tickBalanceTimer, 1000);
        
        if (passiveIncreaseInterval) clearInterval(passiveIncreaseInterval);
        passiveIncreaseInterval = setInterval(triggerPassiveIncrease, CONFIG.BALANCE_MODE.PASSIVE_INCREASE_INTERVAL); 
    }
    
    function tickBalanceTimer() {
        if(isPaused) return;
        balanceTimeLeft--;
        DOMElements.balanceTimerEl.textContent = balanceTimeLeft;

        if (balanceTimeLeft <= 0) {
            if(balanceMovesMade > 0) {
                handleBalanceWin();
            } else {
                showGameOver("H·∫øt gi·ªù! B·∫°n ch∆∞a th·ª±c hi·ªán n∆∞·ªõc ƒëi n√†o.");
            }
        }
    }

    function triggerPassiveIncrease() {
        if (isPaused || isAnimating || currentModal) return;

        const increaseAmount = Math.random() * 10 + 5; // TƒÉng ng·∫´u nhi√™n t·ª´ 5% ƒë·∫øn 15%
        let tubeToFlash;

        if (Math.random() < 0.5) {
            // TƒÉng thanh H·ªçc T·∫≠p
            studyValue += increaseAmount;
            tubeToFlash = DOMElements.studyLiquid.closest('.balance-tube');
        } else {
            // TƒÉng thanh Gi·∫£i Tr√≠
            playValue += increaseAmount;
            tubeToFlash = DOMElements.playLiquid.closest('.balance-tube');
        }

        // Th√™m hi·ªáu ·ª©ng flash cho ·ªëng nghi·ªám ƒë∆∞·ª£c ch·ªçn
        if(tubeToFlash) {
            tubeToFlash.classList.add('flash-warning-effect');
            setTimeout(() => {
                tubeToFlash.classList.remove('flash-warning-effect');
            }, 600);
        }
        
        updateBalanceBars();
    }

    function updateBalanceBars() {
        studyValue = Math.min(100, Math.max(0, studyValue));
        playValue = Math.min(100, Math.max(0, playValue));
        
        DOMElements.studyLiquid.style.height = `${studyValue}%`;
        DOMElements.playLiquid.style.height = `${playValue}%`;
        DOMElements.studyPercentage.textContent = `${Math.round(studyValue)}%`;
        DOMElements.playPercentage.textContent = `${Math.round(playValue)}%`;

        // ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô v√† ƒë·ªô s√°ng c·ªßa plasma d·ª±a tr√™n %
        // C√†ng cao, xung nh·ªãp c√†ng nhanh
        const studyPulseDuration = Math.max(0.5, 3 - (studyValue / 100) * 2.5);
        const playPulseDuration = Math.max(0.5, 3 - (playValue / 100) * 2.5);
        DOMElements.studyLiquid.style.animationDuration = `${studyPulseDuration}s`;
        DOMElements.playLiquid.style.animationDuration = `${playPulseDuration}s`;


        // Update Chain Tilt
        const difference = playValue - studyValue; // ƒê√£ s·ª≠a: (ph·∫£i - tr√°i) ƒë·ªÉ nghi√™ng ƒë√∫ng h∆∞·ªõng
        const tiltPercentage = difference / 100; // -1 to 1
        const tiltAngle = tiltPercentage * CONFIG.BALANCE_MODE.MAX_TILT_ANGLE;
        DOMElements.balanceScaleContainer.style.transform = `rotate(${tiltAngle}deg)`;

        // Update Danger Icons & Animations
        const studyWrapper = DOMElements.studyLiquid.closest('.balance-tube-wrapper');
        const playWrapper = DOMElements.playLiquid.closest('.balance-tube-wrapper');
        
        DOMElements.studyDangerIcon.classList.toggle('visible', studyValue > CONFIG.BALANCE_MODE.WARNING_THRESHOLD);
        studyWrapper.classList.toggle('warning-study', studyValue > CONFIG.BALANCE_MODE.WARNING_THRESHOLD);

        DOMElements.playDangerIcon.classList.toggle('visible', playValue > CONFIG.BALANCE_MODE.WARNING_THRESHOLD);
        playWrapper.classList.toggle('warning-play', playValue > CONFIG.BALANCE_MODE.WARNING_THRESHOLD);

        // Logic thua m·ªõi
        if (studyValue >= 100) {
            showGameOver("H·ªçc t·∫≠p qu√° t·∫£i! C·∫ßn gi·∫£i tr√≠ ngay!");
        } else if (playValue >= 100) {
            showGameOver("Gi·∫£i tr√≠ qu√° ƒë√†! C·∫ßn t·∫≠p trung h·ªçc l·∫°i!");
        } else if (studyValue <= 0 && balanceMovesMade > 0) { // Th√™m `balanceMovesMade > 0` ƒë·ªÉ kh√¥ng b·ªã thua ngay t·ª´ ƒë·∫ßu
            showGameOver("B·ªè b√™ h·ªçc t·∫≠p! M·∫•t c√¢n b·∫±ng r·ªìi!");
        } else if (playValue <= 0 && balanceMovesMade > 0) {
            showGameOver("Kh√¥ng c√≤n ni·ªÅm vui! Cu·ªôc s·ªëng qu√° √°p l·ª±c!");
        }
    }

    function handleBalanceWin() {
        clearInterval(balanceTimerInterval);
        clearInterval(passiveIncreaseInterval);
        if (infoPanelInterval) clearInterval(infoPanelInterval);
        isPaused = true;
        DOMElements.winLevelText.textContent = `Tuy·ªát v·ªùi! C√¢n b·∫±ng h·ªçc t·∫≠p v√† vui ch∆°i gi√∫p b·∫°n kh·ªèe m·∫°nh, kh√¥ng c·∫ßn thu·ªëc l√°.`;
        showModal(DOMElements.winModal, DOMElements.nextLevelButton);
        
        const nextLevelHandler = () => {
            hideModal(DOMElements.winModal);
            isPaused = false;
            setupBalanceLevel(currentBalanceLevel + 1);
            reshuffleBoard();
        };
        
        const nextLevelButton = DOMElements.nextLevelButton;
        const newNextLevelButton = nextLevelButton.cloneNode(true);
        nextLevelButton.parentNode.replaceChild(newNextLevelButton, nextLevelButton);
        DOMElements.nextLevelButton = newNextLevelButton;
        
        newNextLevelButton.addEventListener('click', nextLevelHandler, { once: true });
    }

    function gameLoop(time) { requestAnimationFrame(gameLoop); handleAnimations(time); const { ctx, canvas } = DOMElements; ctx.clearRect(0, 0, canvas.width, canvas.height); drawBoard(time); drawParticles(); drawSelection(time); drawHint(time); if (isPaused) { return; } }
    
    function returnToMenu() {
        [DOMElements.winModal, DOMElements.gameOverModal, DOMElements.finalWinModal, DOMElements.factModal, DOMElements.tutorialModal].forEach(modal => {
            if (modal && !modal.classList.contains('hidden')) {
                hideModal(modal);
            }
        });

        // Chuy·ªÉn canvas tr·ªü l·∫°i m√†n h√¨nh game ch√≠nh
        if (DOMElements.canvas.parentElement !== DOMElements.gameContainer) {
            DOMElements.gameContainer.appendChild(DOMElements.canvas);
        }

        isPaused = true;
        if (threatInterval) clearInterval(threatInterval);
        if (hintTimeout) clearTimeout(hintTimeout);
        if (balanceTimerInterval) clearInterval(balanceTimerInterval);
        if (passiveIncreaseInterval) clearInterval(passiveIncreaseInterval);
        if (infoPanelInterval) clearInterval(infoPanelInterval);

        DOMElements.startScreen.style.display = 'flex';
        DOMElements.gameUI.classList.add('hidden');
        DOMElements.gameUI.classList.remove('flex');
        DOMElements.balanceModeScreen.classList.add('hidden');
        DOMElements.balanceModeScreen.classList.remove('flex');
        DOMElements.backToMenuBtn.classList.add('hidden');
        updateButtonLocks(); // C·∫≠p nh·∫≠t l·∫°i kh√≥a khi v·ªÅ menu
    }

    function updateButtonLocks() {
        const easyCompleted = localStorage.getItem('kimcuong_easy_completed') === 'true';
        const hardCompleted = localStorage.getItem('kimcuong_hard_completed') === 'true';

        // Kh√≥a ch·∫ø ƒë·ªô Kh√≥
        if (easyCompleted) {
            DOMElements.hardModeBtn.classList.remove('locked-button');
            DOMElements.hardLockIcon.classList.add('hidden');
        } else {
            DOMElements.hardModeBtn.classList.add('locked-button');
            DOMElements.hardLockIcon.classList.remove('hidden');
        }

        // Kh√≥a ch·∫ø ƒë·ªô T·ª± do & C√¢n b·∫±ng
        if (hardCompleted) {
            DOMElements.freeModeBtn.classList.remove('locked-button');
            DOMElements.freeLockIcon.classList.add('hidden');
            DOMElements.balanceModeBtn.classList.remove('locked-button');
            DOMElements.balanceLockIcon.classList.add('hidden');
        } else {
            DOMElements.freeModeBtn.classList.add('locked-button');
            DOMElements.freeLockIcon.classList.remove('hidden');
            DOMElements.balanceModeBtn.classList.add('locked-button');
            DOMElements.balanceLockIcon.classList.remove('hidden');
        }
    }

    // --- MODULE: EVENT LISTENERS & INITIALIZATION ---
    window.addEventListener('DOMContentLoaded', () => {
        DOMElements = {
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            scoreEl: document.getElementById('score'),
            levelEl: document.getElementById('level'),
            movesEl: document.getElementById('moves'),
            winModal: document.getElementById('winModal'),
            nextLevelButton: document.getElementById('nextLevelButton'),
            winLevelText: document.getElementById('win-level-text'),
            gameOverModal: document.getElementById('gameOverModal'),
            gameOverReason: document.getElementById('gameOverReason'),
            gameOverMessageContainer: document.getElementById('gameOverMessageContainer'),
            factModal: document.getElementById('factModal'),
            factText: document.getElementById('factText'),
            adviceText: document.getElementById('adviceText'),
            closeFactButton: document.getElementById('closeFactButton'),
            healthBar: document.getElementById('health-bar'),
            questList: document.getElementById('quest-list'),
            startScreen: document.getElementById('start-screen'),
            gameUI: document.getElementById('game-ui'),
            customCursor: document.getElementById('custom-cursor'),
            tutorialModal: document.getElementById('tutorial-modal'),
            tutorialSteps: document.querySelectorAll('.tutorial-step'),
            tutorialNextBtns: document.querySelectorAll('.tutorial-next-btn'),
            tutorialFinishBtn: document.getElementById('tutorial-finish-btn'),
            balanceTutorialFinishBtn: document.getElementById('balance-tutorial-finish-btn'),
            finalWinModal: document.getElementById('finalWinModal'),
            restartGameButton: document.getElementById('restartGameButton'),
            easyModeBtn: document.getElementById('easy-mode-btn'),
            hardModeBtn: document.getElementById('hard-mode-btn'),
            freeModeBtn: document.getElementById('free-mode-btn'),
            balanceModeBtn: document.getElementById('balance-mode-btn'),
            hardLockIcon: document.getElementById('hard-lock-icon'),
            freeLockIcon: document.getElementById('free-lock-icon'),
            balanceLockIcon: document.getElementById('balance-lock-icon'),
            freeModeHighscoreEl: document.getElementById('free-mode-highscore'),
            backToMenuBtn: document.getElementById('back-to-menu-btn'),
            tutorialStartBtn: document.getElementById('tutorial-start-btn'),
            characterContainerEl: document.getElementById('character-container'),
            threatBubble: document.getElementById('threat-bubble'),
            threatText: document.getElementById('threat-text'),
            mouth: document.getElementById('mouth-path'),
            pupil1: document.getElementById('pupil1'),
            pupil2: document.getElementById('pupil2'),
            copyrightYear: document.getElementById('year'),
            
            // UI cho ch·∫ø ƒë·ªô C√¢n B·∫±ng
            balanceModeScreen: document.getElementById('balance-mode-screen'),
            balanceGameBoard: document.getElementById('balance-game-board'),
            balanceScaleContainer: document.getElementById('balance-scale-container'),
            studyLiquid: document.getElementById('study-liquid'),
            playLiquid: document.getElementById('play-liquid'),
            studyPercentage: document.getElementById('study-percentage'),
            playPercentage: document.getElementById('play-percentage'),
            studyDangerIcon: document.getElementById('study-danger-icon'),
            playDangerIcon: document.getElementById('play-danger-icon'),
            balanceLevelEl: document.getElementById('balance-level'),
            balanceTimerEl: document.getElementById('balance-timer'),
            factsList: document.getElementById('facts-list'),
            skillsList: document.getElementById('skills-list'),
            
            // C√°c th√†nh ph·∫ßn c·∫ßn ·∫©n/hi·ªán
            objectivePanel: document.getElementById('objective-panel'),
            storyModeStats: document.getElementById('story-mode-stats'),
            gameContainer: document.getElementById('game-container'),

        };

        const originalNextLevelHandler = () => goToNextLevel(false);

        function attachCanvasListeners() {
            const { canvas } = DOMElements; 
            if (!canvas.dataset.listenersAdded) { 
                const eventOptions = { passive: false };
                canvas.addEventListener('pointerdown', handlePointerStart, eventOptions); 
                canvas.addEventListener('pointermove', handlePointerMove, eventOptions); 
                canvas.addEventListener('pointerup', handlePointerEnd, eventOptions); 
                canvas.addEventListener('pointercancel', handlePointerEnd, eventOptions); 
                
                canvas.addEventListener('touchstart', handlePointerStart, eventOptions);
                canvas.addEventListener('touchmove', handlePointerMove, eventOptions);
                canvas.addEventListener('touchend', handlePointerEnd, eventOptions);
                canvas.addEventListener('touchcancel', handlePointerEnd, eventOptions);
                
                window.addEventListener('resize', onResizeDebounced); 
                canvas.dataset.listenersAdded = '1'; 
            } 
        }

        DOMElements.copyrightYear.textContent = new Date().getFullYear();
        let currentTutorialStep = 0;
        let firstInteraction = true;
        async function handleFirstInteraction() { if (firstInteraction) { firstInteraction = false; await AudioManager.init(); AudioManager.startMusic(); } }
        function showTutorialStep(index, maxSteps = 4) { // Add maxSteps to limit the regular tutorial
            DOMElements.tutorialSteps.forEach((step, i) => { 
                step.classList.toggle('hidden', i !== index); 
            }); 
            if (index === maxSteps - 1) { 
                if (isTutorialOnly) { DOMElements.tutorialFinishBtn.textContent = 'Quay L·∫°i'; DOMElements.tutorialFinishBtn.classList.replace('bg-green-600', 'bg-blue-600'); } 
                else { DOMElements.tutorialFinishBtn.textContent = 'B·∫Øt ƒë·∫ßu ch∆°i!'; DOMElements.tutorialFinishBtn.classList.replace('bg-blue-600', 'bg-green-600'); } 
            } 
        }
        
        function startGame(finalLevel, isFree = false, difficulty = 'easy') {
            gameMode = isFree ? 'free' : 'story';
            currentDifficulty = difficulty;
            isTutorialOnly = false;
            CONFIG.FINAL_LEVEL = finalLevel;
            isFreePlayMode = isFree;
            
            // --- QU·∫¢N L√ù B·ªê C·ª§C ---
            if (DOMElements.canvas.parentElement !== DOMElements.gameContainer) {
                DOMElements.gameContainer.appendChild(DOMElements.canvas);
            }

            DOMElements.startScreen.style.display = 'none';
            DOMElements.balanceModeScreen.classList.add('hidden');
            DOMElements.balanceModeScreen.classList.remove('flex', 'md:flex-row', 'flex-col');

            DOMElements.gameUI.classList.remove('hidden');
            DOMElements.gameUI.classList.add('flex');
            
            DOMElements.tutorialModal.classList.remove('hidden');
            showTutorialStep(0);
        }

        function showBalanceTutorial() {
            gameMode = 'balance';
            isTutorialOnly = false;
            isFreePlayMode = false;
            DOMElements.startScreen.style.display = 'none';
            DOMElements.tutorialSteps.forEach(step => step.classList.add('hidden'));
            const balanceStepIndex = Array.from(DOMElements.tutorialSteps).findIndex(step => step.id === 'tutorial-step-balance');
            if (balanceStepIndex !== -1) {
                DOMElements.tutorialSteps[balanceStepIndex].classList.remove('hidden');
            }
            DOMElements.tutorialModal.classList.remove('hidden');
        }

        function startBalanceMode() {
            // --- QU·∫¢N L√ù B·ªê C·ª§C ---
            DOMElements.balanceGameBoard.appendChild(DOMElements.canvas);

            DOMElements.startScreen.style.display = 'none';
            DOMElements.gameUI.classList.add('hidden');
            DOMElements.gameUI.classList.remove('flex');
            
            DOMElements.balanceModeScreen.classList.remove('hidden');
            DOMElements.balanceModeScreen.classList.add('flex', 'flex-col'); 
            
            DOMElements.backToMenuBtn.classList.remove('hidden');
            initBalanceMode();
            attachCanvasListeners();
        }

        DOMElements.easyModeBtn.addEventListener('click', () => { handleFirstInteraction(); startGame(1, false, 'easy'); });
        DOMElements.hardModeBtn.addEventListener('click', () => {
            if (DOMElements.hardModeBtn.classList.contains('locked-button')) return;
            handleFirstInteraction(); 
            startGame(3, false, 'hard'); 
        });
        DOMElements.freeModeBtn.addEventListener('click', () => { 
            if (DOMElements.freeModeBtn.classList.contains('locked-button')) return;
            handleFirstInteraction(); 
            startGame(Infinity, true, 'free'); 
        });
        DOMElements.balanceModeBtn.addEventListener('click', () => { 
            if (DOMElements.balanceModeBtn.classList.contains('locked-button')) return;
            handleFirstInteraction(); 
            showBalanceTutorial(); 
        });
        
        DOMElements.tutorialStartBtn.addEventListener('click', () => { handleFirstInteraction(); isTutorialOnly = true; DOMElements.startScreen.style.display = 'none'; DOMElements.tutorialModal.classList.remove('hidden'); showTutorialStep(0); });
        DOMElements.tutorialNextBtns.forEach(btn => btn.addEventListener('click', () => { currentTutorialStep++; if (currentTutorialStep < 4) showTutorialStep(currentTutorialStep); }));
        DOMElements.tutorialFinishBtn.addEventListener('click', async () => { 
            hideModal(DOMElements.tutorialModal); 
            currentTutorialStep = 0; 
            if (isTutorialOnly) { 
                DOMElements.startScreen.style.display = 'flex'; 
            } else if (gameMode === 'balance') {
                 // Kh√¥ng l√†m g√¨ c·∫£ v√¨ startBalanceMode ƒë√£ init game
            }
            else { 
                DOMElements.backToMenuBtn.classList.remove('hidden'); 
                await init(); 
                attachCanvasListeners();
            } 
        });

        DOMElements.balanceTutorialFinishBtn.addEventListener('click', () => {
            hideModal(DOMElements.tutorialModal);
            startBalanceMode();
        });
        
        DOMElements.closeFactButton.addEventListener('click', () => {
            hideModal(DOMElements.factModal);
            isPaused = false;
            isPausedForFact = false;
            resetHintTimer();
        });
        
        DOMElements.nextLevelButton.addEventListener('click', originalNextLevelHandler);
        document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
        document.getElementById('backToIndexButton').addEventListener('click', returnToMenu);
        document.getElementById('gameOverHomeButton').addEventListener('click', returnToMenu);
        DOMElements.backToMenuBtn.addEventListener('click', returnToMenu);
        document.getElementById('gameOverRestartButton').addEventListener('click', () => {
             hideModal(DOMElements.gameOverModal);
             if (gameMode === 'balance') {
                initBalanceMode();
             } else {
                init();
             }
        });
        DOMElements.restartGameButton.addEventListener('click', () => {
            hideModal(DOMElements.finalWinModal);
            returnToMenu();
        });
        document.getElementById('continueToNextGameButton').addEventListener('click', () => window.location.href = 'kimcuongquatraloicauhoi.html');

        document.addEventListener('fullscreenchange', updateFullscreenIcons);
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && currentModal) { const closeButton = currentModal.querySelector('button'); if (closeButton) closeButton.click(); } });
        
        if (!window.matchMedia('(pointer: coarse)').matches) {
            document.body.style.cursor = 'none'; 
            if(DOMElements.customCursor) DOMElements.customCursor.style.display = 'block';
            if(DOMElements.canvas) DOMElements.canvas.style.cursor = 'none';
            
            let rafScheduled = false, lastMouseEvent = null;
            document.addEventListener('mousemove', (e) => {
                lastMouseEvent = e;
                if (!rafScheduled) { 
                    rafScheduled = true; 
                    requestAnimationFrame(() => { 
                        if (lastMouseEvent && DOMElements) { 
                            if (DOMElements.customCursor) {
                                DOMElements.customCursor.style.left = lastMouseEvent.clientX + 'px'; 
                                DOMElements.customCursor.style.top = lastMouseEvent.clientY + 'px'; 
                            }
                            if (DOMElements.startScreen && DOMElements.startScreen.style.display === 'none' && gameMode !== 'balance') { 
                                if (DOMElements.pupil1 && DOMElements.pupil2) {
                                    trackPupil(DOMElements.pupil1, lastMouseEvent); 
                                    trackPupil(DOMElements.pupil2, lastMouseEvent); 
                                }
                            } 
                        } 
                        rafScheduled = false; 
                    }); 
                }
            });
        }
        updateButtonLocks(); // Ki·ªÉm tra kh√≥a ngay khi game t·∫£i xong
        // T·∫£i v√† hi·ªÉn th·ªã ƒëi·ªÉm cao
        const highscore = parseInt(localStorage.getItem('kimcuong_free_highscore') || '0');
        if (highscore > 0) {
            DOMElements.freeModeHighscoreEl.textContent = `K·ª∑ l·ª•c: C·∫•p ${highscore}`;
        }
    });
    window.addEventListener('beforeunload', () => { if (threatInterval) clearInterval(threatInterval); if (hintTimeout) clearTimeout(hintTimeout); if(animationWatchdog) clearTimeout(animationWatchdog); });

})(); 
</script>
</body>
</html>

