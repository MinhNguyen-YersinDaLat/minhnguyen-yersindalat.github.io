<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chiến Dịch Lá Phổi Xanh (Đã tối ưu hóa)</title>
    <!-- Import Tone.js for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&display=swap');
        :root {
            --primary-color: #00b4d8;
            --dark-color: #0d1b2a;
            --light-blue: #90e0ef;
            --glow-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
        }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrolling */
            background: var(--dark-color);
            font-family: 'Roboto Condensed', sans-serif;
            color: white;
        }
        .screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }
        .hidden {
            display: none !important;
        }

        /* Main Menu Screen */
        #main-menu {
             background: linear-gradient(rgba(13, 27, 42, 0.8), rgba(13, 27, 42, 1)), url('https://placehold.co/1200x800/0d1b2a/00b4d8?text=Battleground') no-repeat center center;
             background-size: cover;
        }
        .start-container {
            background: rgba(17, 24, 39, 0.8);
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 40px rgba(0, 180, 216, 0.3), inset 0 0 15px rgba(0, 180, 216, 0.2);
            color: #e5e7eb;
            max-width: 600px;
            text-align: center;
            border-radius: 15px;
            padding: 40px 50px;
        }
        .start-title {
            font-size: 3.5em;
            line-height: 1.1;
            margin: 0 0 15px 0;
            color: #f9fafb;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
            font-weight: 700;
        }
        .start-title .subtitle {
            color: var(--primary-color);
            text-shadow: var(--glow-shadow);
        }
        .mission-desc {
            font-family: Arial, sans-serif;
            font-size: 1.1em;
            color: #d1d5db;
            line-height: 1.6;
            max-width: 90%;
            margin: 0 auto 30px auto;
            border-top: 1px solid rgba(144, 224, 239, 0.3);
            border-bottom: 1px solid rgba(144, 224, 239, 0.3);
            padding: 15px 0;
        }
        .start-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 24px;
            border-radius: 8px;
            border: 2px solid var(--primary-color);
            background: transparent;
            color: var(--light-blue);
            font-weight: bold;
            cursor:pointer;
            margin: 0 8px;
            transition: all 0.2s ease;
            text-shadow: 0 0 8px var(--primary-color);
            font-family: 'Roboto Condensed', sans-serif;
            font-size: 16px;
        }
        button:hover {
            background: var(--primary-color);
            color: var(--dark-color);
            transform: translateY(-3px);
            box-shadow: 0 4px 20px rgba(0, 180, 216, 0.4);
        }
         #main-menu button#btnStartGame {
            background: var(--primary-color);
            color: var(--dark-color);
        }
         #main-menu button#btnStartGame:hover {
            background: var(--light-blue);
            transform: translateY(-2px) scale(1.05);
        }
         #main-menu button#btnShowInstructions:hover {
            background: rgba(0, 180, 216, 0.2);
            transform: translateY(-2px);
        }

        /* Instructions Screen */
        #instructions-screen {
            position: absolute;
            top: 0; left: 0;
            background: rgba(0,0,0,0.95);
            z-index: 200;
        }
        .instructions-content {
            background: #1f2937;
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            padding: 30px;
            width: 90%;
            max-width: 900px;
            color: #d1d5db;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .instructions-content h2 {
            color: var(--primary-color);
            text-shadow: var(--glow-shadow);
            margin-top: 0;
            text-align: center;
            font-size: 2.5em;
        }
        .instruction-step {
            width: 100%;
        }
        .instruction-step h3 {
             font-size: 1.8em;
             color: #fff;
             text-align: center;
             margin-bottom: 20px;
        }
        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }
        .instruction-item {
            background: #111827;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 1px solid #374151;
        }
        .instruction-item h4 {
            color: var(--light-blue);
            margin-top: 0;
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: 10px;
        }
        .instruction-item canvas {
            background: #0d1b2a;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .instruction-item p {
            font-size: 0.95em;
            line-height: 1.5;
            margin: 0;
        }
        #btnNextInstruction {
            display: block;
            margin: 20px auto 0 auto;
        }

        /* Game Area */
        #game-wrapper {
            justify-content: center; 
            overflow-y: auto;
        }
        
        #notification-bar {
            width: 800px;
            max-width: 95vw;
            box-sizing: border-box;
            padding: 12px;
            margin-bottom: 10px;
            background: rgba(13, 27, 42, 0.9);
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            text-align: center;
            color: #e5e7eb;
            font-size: 1em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            visibility: hidden;
            z-index: 50;
        }
        #notification-bar.visible {
            opacity: 1;
            transform: translateY(0);
            visibility: visible;
        }
        #notification-bar h3 {
            margin: 0 0 5px 0;
            color: var(--light-blue);
            font-size: 1.1em;
        }
         #notification-bar p {
            margin: 0;
            font-family: Arial, sans-serif;
            font-size: 0.9em;
         }

        #gameContainer {
            position: relative;
            border: 3px solid #0077b6;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 180, 216, 0.5);
            width: 800px;
            max-width: 95vw;
            background: #000;
            overflow: hidden;
            flex-shrink: 0;
            /* Added for screen shake effect */
            transition: transform 0.1s;
        }
        #gameCanvas {
            background: #1b263b;
            display: block;
            width: 100%;
            height: auto;
            aspect-ratio: 800 / 600;
            border-radius: 8px;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            line-height: 1.5;
            background: rgba(0,0,0,0.4);
            padding: 8px 12px;
            border-radius: 5px;
            border-left: 3px solid var(--primary-color);
            width: 280px; /* Tăng chiều rộng để chứa điểm */
        }
        #bossHealthContainer { display: none; margin-top: 5px; }
        #bossHealthBar { width: 100%; height: 15px; background-color: #555; border-radius: 5px; border: 1px solid #aaa; overflow: hidden; }
        #bossHealthFill { width: 100%; height: 100%; background: linear-gradient(90deg, #d32f2f, #fbc02d, #388e3c); background-size: 200% 100%; transition: width 0.5s ease-in-out, background-position 0.5s ease-in-out; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); color: #333; display: flex; justify-content: center; align-items: center; text-align: center; z-index: 100; border-radius: 8px; flex-direction: column; gap: 20px; }
        .overlay-box { background: linear-gradient(135deg, #e0e0e0, #ffffff); padding: 35px 45px; border-radius: 10px; box-shadow: 0 5px 25px rgba(0,0,0,0.5); border-top: 5px solid #0077b6; }
        .overlay-box.clickable { cursor: pointer; }
        .overlay-box button { color: var(--dark-color); border-color: #0077b6; text-shadow: none; }
        .overlay-box button:hover { background: #0077b6; color: white; }
        .overlay-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }
        
        #buttons {
            margin-top: 15px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .base-name {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            padding: 4px 12px;
            border-radius: 4px;
            z-index: 5;
            letter-spacing: 1px;
            opacity: 0.9;
        }
        #enemyBaseName {
            top: 15px;
            background: rgba(189, 4, 4, 0.6);
            border-bottom: 2px solid #ff4757;
            color: #f1f1f1;
        }
        #playerBaseName {
            bottom: 15px;
            background: rgba(0, 100, 0, 0.6);
            border-bottom: 2px solid #22c55e;
            color: #f1f1f1;
        }
    </style>
</head>
<div id="copyright">
    © <span id="year"></span> Thầy Thái Minh Nguyên - Trường Tiểu học, THCS & THPT Yersin Đà Lạt. All rights reserved.
</div>

<style>
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap');

#copyright {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 13px;
    padding: 6px 0;
    font-family: 'Roboto', Arial, Helvetica, sans-serif;
    z-index: 9999;
    pointer-events: none;

    color: rgba(255, 255, 255, 0.85);
    background: transparent;

    opacity: 0;
    animation: fadeIn 2s ease forwards;
}

@keyframes fadeIn {
    to { opacity: 1; }
}
</style>

<script>
document.getElementById("year").textContent = new Date().getFullYear();
</script>

<body>

    <!-- Main Menu Screen -->
    <div id="main-menu" class="screen">
        <div class="start-container">
            <h2 class="start-title">CHIẾN DỊCH<br><span class="subtitle">LÁ PHỔI XANH</span></h2>
            <p class="mission-desc">Nhiệm vụ của bạn: Điều khiển siêu xe tăng O₂, phá hủy các nhà máy khói độc và bảo vệ trung tâm sức khỏe của hành tinh.</p>
            <div class="start-buttons">
              <button id="btnStartGame">Bắt đầu Chiến dịch</button>
              <button id="btnShowInstructions">Xem Hướng dẫn</button>
              <button id="btnMainMenuStart">Về Menu Chính</button>
            </div>
        </div>
    </div>

    <!-- Instructions Screen -->
    <div id="instructions-screen" class="screen hidden">
        <div class="instructions-content">
            <h2>HƯỚNG DẪN CHIẾN DỊCH</h2>
            
            <div class="instruction-step">
                <h3>Bước 1: Nắm Rõ Mục Tiêu</h3>
                <div class="instructions-grid" style="grid-template-columns: 1fr;">
                     <div class="instruction-item">
                        <h4>Nhiệm Vụ Chính</h4>
                        <canvas id="instr-bases" width="200" height="100"></canvas>
                        <p>Bảo vệ <strong>Trung tâm Phổi Xanh</strong> (xanh lá) và phá hủy <strong>Nhà máy Khói Độc</strong> (xám).</p>
                    </div>
                </div>
            </div>

            <div class="instruction-step hidden">
                <h3>Bước 2: Làm Chủ Xe Tăng</h3>
                <div class="instructions-grid">
                    <div class="instruction-item">
                        <h4>Điều Khiển</h4>
                        <canvas id="instr-movement" width="100" height="100"></canvas>
                        <p>Dùng <strong>phím mũi tên</strong> hoặc <strong>WASD</strong> để di chuyển. Dùng <strong>Spacebar</strong> để bắn đạn.</p>
                    </div>
                    <div class="instruction-item">
                        <h4>Vật Phẩm Nâng Cấp</h4>
                        <canvas id="instr-powerups" width="100" height="100"></canvas>
                        <p>Thu thập vật phẩm từ gạch bị phá hủy để nhận hiệu ứng đặc biệt.</p>
                    </div>
                </div>
            </div>

            <div class="instruction-step hidden">
                <h3>Bước 3: Nhận Diện Kẻ Địch</h3>
                <div class="instructions-grid">
                    <div class="instruction-item">
                        <h4>Kẻ Địch: Thuốc Lá</h4>
                        <canvas id="instr-enemy-normal" width="100" height="100"></canvas>
                        <p>Xe tăng cơ bản, di chuyển chậm và ít nguy hiểm.</p>
                    </div>
                    <div class="instruction-item">
                        <h4>Kẻ Địch: Vape</h4>
                        <canvas id="instr-enemy-vape" width="100" height="100"></canvas>
                        <p>Di chuyển nhanh, khó đoán và bắn thường xuyên.</p>
                    </div>
                    <div class="instruction-item">
                        <h4>Kẻ Địch: Thuốc Lào</h4>
                        <canvas id="instr-enemy-tough" width="100" height="100"></canvas>
                        <p>Trâu bò, cần nhiều phát đạn để hạ gục.</p>
                    </div>
                     <div class="instruction-item">
                        <h4>Kẻ Địch: Cảm Tử</h4>
                        <canvas id="instr-enemy-kamikaze" width="100" height="100"></canvas>
                        <p>Lao thẳng về phía bạn và phát nổ. Hãy tiêu diệt từ xa!</p>
                    </div>
                </div>
            </div>

            <div class="instruction-step hidden">
                <h3>Bước 4: Thử Thách Đặc Biệt</h3>
                <div class="instructions-grid">
                    <div class="instruction-item">
                        <h4>Trùm Cuối: Xì Gà Độc Hại</h4>
                        <canvas id="instr-boss" width="100" height="100"></canvas>
                        <p>Nhiều máu và tấn công đa dạng, bao gồm cả la-de. Luôn di chuyển!</p>
                    </div>
                    <div class="instruction-item">
                        <h4>Khiên Phản Đạn</h4>
                        <canvas id="instr-powerup-shield" width="100" height="100"></canvas>
                        <p>Vật phẩm hiếm giúp phản lại đạn của kẻ thù trong thời gian ngắn.</p>
                    </div>
                </div>
            </div>
            
            <button id="btnNextInstruction">Tiếp tục</button>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-wrapper" class="screen hidden">
        <div id="notification-bar"></div>
        
        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="enemyBaseName" class="base-name hidden">NHÀ MÁY KHÓI ĐỘC</div>
            <div id="playerBaseName" class="base-name hidden">TRUNG TÂM PHỔI XANH</div>

            <div id="hud" class="hidden">
                <div>❤️ Mạng: <span id="lives">3</span></div>
                <div>⭐ Cấp độ Xe: <span id="level">1</span></div>
                <div>Màn: <span id="stage">1</span></div>
                <div>Điểm: <span id="score">0</span></div>
                <div>Cao nhất: <span id="highScore">0</span></div>
                <div id="enemiesLeftContainer">Kẻ địch còn lại: <span id="enemiesLeft">20</span></div>
                <div id="bossHealthContainer">
                    <div>TRÙM CUỐI</div>
                    <div id="bossHealthBar">
                        <div id="bossHealthFill"></div>
                    </div>
                </div>
            </div>
            
            <div id="difficultyScreen" class="overlay hidden">
                <div class="overlay-box">
                    <h2>CHỌN ĐỘ KHÓ</h2>
                    <button id="btnEasy">Dễ (2 Đồng minh, Trùm yếu sau Màn 1)</button>
                    <button id="btnHard">Khó (Chơi đơn, Trùm cuối hùng mạnh)</button>
                </div>
            </div>

            <div id="messageOverlay" class="overlay hidden">
                <div id="messageBox" class="overlay-box"></div>
            </div>
        </div>
        <div id="buttons">
             <button id="btnReset">Về Menu Chính (R)</button>
             <button id="btnPause">Tạm dừng (Enter)</button>
             <button id="btnMainMenu">Về Màn Hình Chính</button>
        </div>
    </div>

<script>
// ==================================================================
// GAME SCRIPT - STAGE 3: GAMEPLAY DEPTH
// Reviewed by a 50-year experience developer.
// ==================================================================

// --- GAME CONFIGURATION ---
const GAME_CONFIG = {
    TILE_SIZE: 40,
    PLAYER: {
        BASE_SPEED: 180,
        SPEED_INCREMENT: 45,
        MAX_LEVEL: 4,
        BULLET_SPEED_BASE: 420,
        BULLET_SPEED_INCREMENT: 60,
        INVINCIBILITY_DURATION: 10000,
        REFLECT_SHIELD_DURATION: 8000,
        RESPAWN_INVINCIBILITY: 3000,
        SHOT_COOLDOWN: 300
    },
    ENEMY: {
        NORMAL: { SPEED: 60, HEALTH: 1, SHOT_COOLDOWN: 2500 },
        VAPE:   { SPEED: 120, HEALTH: 1, SHOT_COOLDOWN: 1800 },
        TOUGH:  { SPEED: 48, HEALTH: 3, SHOT_COOLDOWN: 1500 },
        KAMIKAZE: { SPEED: 140, HEALTH: 1, EXPLOSION_RADIUS: 60 },
        AI_TANK: { SPEED: 100, SHOT_COOLDOWN: 800, BULLET_SPEED: 480 },
        BOSS: { SPEED: 50, MAX_HEALTH: 100, EASY_MAX_HEALTH: 30, SHOT_COOLDOWN: 1000, LASER_COOLDOWN: 2500, EASY_MODE_ATTACK_DELAY: 2000 },
        MAX_ON_SCREEN: 5,
        SPAWN_INTERVAL: 3000,
        FROZEN_DURATION: 7000
    },
    POWERUP: {
        LIFESPAN: 10000,
        SPAWN_CHANCE_ON_BRICK_DESTROY: 0.35,
        SPAWN_CHANCE_ON_ENEMY_KILL: 0.25
    },
    BASE: {
        PLAYER_MAX_HEALTH: 20,
        ENEMY_MAX_HEALTH: 50
    },
    SCORE: { 
        NORMAL: 100,
        VAPE: 200,
        TOUGH: 300,
        KAMIKAZE: 150,
        BOSS_HIT: 50,
        BOSS_KILL: 5000
    }
};

// --- LEVEL DATA ---
const LEVEL_DATA_HARD = [ { normal: 10, vape: 5, tough: 5 }, { normal: 8, vape: 4, tough: 4, kamikaze: 4 }, { normal: 5, vape: 10, tough: 5 }, { normal: 5, vape: 5, tough: 5, kamikaze: 5 }, { normal: 0, vape: 10, tough: 5, kamikaze: 5 }, { boss: 1 } ];
const LEVEL_DATA_EASY = [ { normal: 10, vape: 5, tough: 3, kamikaze: 2 }, { boss: 1 } ];


// --- MAP LAYOUTS ---
const MAP_LAYOUTS = [ [ 'SSSSSSSSSSSSSSSSSSSS', 'S..................S', 'S.B.T.T......T.T.B.S', 'S.B................B.S', 'S.T..BB.B..B.BB..T.S', 'S....B.B.WW.B.B....S', 'S.BB...WWWWWW...BB.S', 'S.T....WWWWWW....T.S', 'S.B....B.SS.B....B.S', 'S......B.SS.B......S', 'S.T..BB......BB..T.S', 'S.B..B........B..B.S', 'S....T........T....S', 'S.B..B........B..B.S', 'SSSSSS........SSSSSS' ], [ 'SSSSSSSSSSSSSSSSSSSS', 'S.B.B.B.B..B.B.B.B.S', 'S.T........SS........S', 'S.B.B.B.B..B.B.B.B.S', 'S..................S', 'S.B....WWWWWW....B.S', 'S.T....W.SS.W....T.S', 'S......W.SS.W......S', 'S.B.B..W.SS.W..B.B.S', 'S.T.T..WWWWWW..T.T.S', 'S..................S', 'S.B.B.B.B..B.B.B.B.S', 'S.T...T....T...T.S', 'S..B.B......B.B..S', 'SSSSSS........SSSSSS' ], [ 'SSSSSSSSSSSSSSSSSSSS', 'S.T.T.T.T..T.T.T.T.S', 'S..................S', 'S.B.SS.B.WW.B.SS.B.S', 'S.B.SS.B.WW.B.SS.B.S', 'S..................S', 'S.B.B.B.B..B.B.B.B.S', 'S.T.T.T.T..T.T.T.T.S', 'S..................S', 'S.WW.B.B.SS.B.B.WW.S', 'S.WW.B.B.SS.B.B.WW.S', 'S..................S', 'S.T.SS.T.SS.T.SS.T.S', 'S.B....B....B....B.S', 'SSSSSS........SSSSSS' ], [ 'SSSSSSSSSSSSSSSSSSSS', 'S.T.B.T.B..........S', 'S.B.T.B.T.WWWW.B.B.S', 'S.T.B.T.B.WWWW.T.T.S', 'S.B.T.B.T......B.B.S', 'S..................S', 'S.SS.SS.SS.SS.SS.SS.S', 'S..................S', 'S.B.B......T.B.T.B.S', 'S.T.T.WWWW.B.T.B.T.S', 'S.B.B.WWWW.T.B.T.B.S', 'S..........B.T.B.T.S', 'S.SS.B.B.B.B.B.B.SS.S', 'S.T..T.T.T.T.T.T..T.S', 'SSSSSS........SSSSSS' ], [ 'SSSSSSSSSSSSSSSSSSSS', 'S.B.B.B.B..B.B.B.B.S', 'S.B.S.S.B..B.S.S.B.S', 'S.B.S.S.B..B.S.S.B.S', 'S.B.B.B.B..B.B.B.B.S', 'S..................S', 'S.WWWW.B.SS.B.WWWW.S', 'S.WWWW.B.SS.B.WWWW.S', 'S......B.SS.B......S', 'S.B.B..B....B..B.B.S', 'S.T.T..B....B..T.T.S', 'S..................S', 'S.B.S.S.B..B.S.S.B.S', 'S.T.B.B.T..T.B.B.T.S', 'SSSSSS........SSSSSS' ] ];
const BOSS_MAP_LAYOUT = [ 'SSSSSSSSSSSSSSSSSSSS', 'S                  S', 'S S S            S S S', 'S                  S', 'S B B            B B S', 'S                  S', 'S                  S', 'S                  S', 'S                  S', 'S B B            B B S', 'S                  S', 'S S S            S S S', 'S                  S', 'S                  S', 'SSSSSS..B.B..SSSSSS' ];

// --- SVG SPRITES ---
const SVG_SPRITES = {
    player: `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><filter id="superGlow"><feGaussianBlur stdDeviation="4" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter><linearGradient id="heroGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#00ff88;stop-opacity:1" /><stop offset="30%" style="stop-color:#2ecc71;stop-opacity:1" /><stop offset="70%" style="stop-color:#27ae60;stop-opacity:1" /><stop offset="100%" style="stop-color:#1e8449;stop-opacity:1" /></linearGradient><linearGradient id="superCannonGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#3498db;stop-opacity:1" /><stop offset="50%" style="stop-color:#2980b9;stop-opacity:1" /><stop offset="100%" style="stop-color:#1f4e79;stop-opacity:1" /></linearGradient><linearGradient id="armorGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#ecf0f1;stop-opacity:1" /><stop offset="100%" style="stop-color:#bdc3c7;stop-opacity:1" /></linearGradient><radialGradient id="energyCore" cx="50%" cy="50%" r="50%"><stop offset="0%" style="stop-color:#00ff88;stop-opacity:1" /><stop offset="70%" style="stop-color:#2ecc71;stop-opacity:0.8" /><stop offset="100%" style="stop-color:#27ae60;stop-opacity:0.3" /></radialGradient><filter id="energyPulse"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><ellipse cx="21" cy="36" rx="15" ry="4" fill="rgba(0,0,0,0.4)"/><ellipse cx="21" cy="35" rx="12" ry="2" fill="rgba(0,0,0,0.2)"/><rect x="6" y="16" width="28" height="18" rx="6" fill="url(#heroGradient)" stroke="#00ff88" stroke-width="2" filter="url(#superGlow)"/><rect x="8" y="18" width="24" height="14" rx="4" fill="url(#armorGradient)" stroke="#ffffff" stroke-width="1" opacity="0.9"/><rect x="10" y="20" width="20" height="2" rx="1" fill="#00ff88" opacity="0.8"/><rect x="10" y="23" width="20" height="2" rx="1" fill="#ffffff" opacity="0.6"/><rect x="10" y="26" width="20" height="2" rx="1" fill="#00ff88" opacity="0.8"/><rect x="10" y="29" width="20" height="2" rx="1" fill="#ffffff" opacity="0.6"/><rect x="2" y="17" width="8" height="16" rx="4" fill="#2c3e50" stroke="#34495e" stroke-width="1.5"/><rect x="30" y="17" width="8" height="16" rx="4" fill="#2c3e50" stroke="#34495e" stroke-width="1.5"/><circle cx="6" cy="20" r="1.5" fill="#00ff88" filter="url(#energyPulse)"/><circle cx="6" cy="25" r="1.5" fill="#00ff88" filter="url(#energyPulse)"/><circle cx="6" cy="30" r="1.5" fill="#00ff88" filter="url(#energyPulse)"/><circle cx="34" cy="20" r="1.5" fill="#00ff88" filter="url(#energyPulse)"/><circle cx="34" cy="25" r="1.5" fill="#00ff88" filter="url(#energyPulse)"/><circle cx="34" cy="30" r="1.5" fill="#00ff88" filter="url(#energyPulse)"/><circle cx="20" cy="20" r="10" fill="url(#heroGradient)" stroke="#00ff88" stroke-width="2" filter="url(#superGlow)"/><circle cx="20" cy="20" r="8" fill="url(#energyCore)" opacity="0.9"/><circle cx="20" cy="20" r="6" fill="#2ecc71" opacity="0.7"/><rect class="cannon" x="17.5" y="4" width="5" height="16" rx="2.5" fill="url(#superCannonGradient)" stroke="#ffffff" stroke-width="1.5" filter="url(#superGlow)"/><rect x="18" y="2" width="4" height="4" rx="2" fill="#e74c3c" filter="url(#energyPulse)"/><rect x="18.5" y="6" width="3" height="2" rx="1" fill="#00ff88"/><rect x="15" y="8" width="2" height="12" rx="1" fill="#7f8c8d" stroke="#95a5a6" stroke-width="0.5"/><rect x="23" y="8" width="2" height="12" rx="1" fill="#7f8c8d" stroke="#95a5a6" stroke-width="0.5"/><g transform="translate(20, 20)"><circle cx="0" cy="0" r="5" fill="#ffffff" opacity="0.95" filter="url(#energyPulse)"/><circle cx="0" cy="0" r="4" fill="url(#energyCore)" opacity="0.8"/><path d="M-3,-2.5 Q-5,-4 -2.5,-4 Q-1,-4 -1,-2 Q-1,1 -2,2 Q-3,1.5 -3,-2.5" fill="#00ff88" stroke="#ffffff" stroke-width="0.5"/><path d="M3,-2.5 Q5,-4 2.5,-4 Q1,-4 1,-2 Q1,1 2,2 Q3,1.5 3,-2.5" fill="#00ff88" stroke="#ffffff" stroke-width="0.5"/><rect x="-0.4" y="-1.5" width="0.8" height="4" fill="#00ff88"/><rect x="-1.5" y="-0.4" width="3" height="0.8" fill="#ffffff" filter="url(#energyPulse)"/><rect x="-0.4" y="-1.5" width="0.8" height="3" fill="#ffffff" filter="url(#energyPulse)"/></g><circle cx="20" cy="20" r="11" fill="none" stroke="#00ff88" stroke-width="1.5" opacity="0.7" filter="url(#energyPulse)"/><circle cx="20" cy="20" r="12" fill="none" stroke="#ffffff" stroke-width="1" opacity="0.5"/><circle cx="20" cy="20" r="13" fill="none" stroke="#2ecc71" stroke-width="0.5" opacity="0.3"/><rect x="19" y="12" width="2" height="6" fill="#f39c12" stroke="#e67e22" stroke-width="0.5"/><circle cx="20" cy="11" r="1.5" fill="#e74c3c" filter="url(#energyPulse)"/><circle cx="20" cy="11" r="1" fill="#ffffff" opacity="0.8"/><g transform="translate(20, 11)"><circle cx="0" cy="0" r="3" fill="none" stroke="#00ff88" stroke-width="0.5" opacity="0.6"/><line x1="0" y1="0" x2="2" y2="-1" stroke="#00ff88" stroke-width="1" opacity="0.8"/></g><circle cx="12" cy="16" r="1" fill="#00ff88" filter="url(#energyPulse)"/><circle cx="28" cy="16" r="1" fill="#00ff88" filter="url(#energyPulse)"/><circle cx="12" cy="32" r="1" fill="#2ecc71" filter="url(#energyPulse)"/><circle cx="28" cy="32" r="1" fill="#2ecc71" filter="url(#energyPulse)"/><g opacity="0.6"><line x1="14" y1="22" x2="26" y2="22" stroke="#34495e" stroke-width="0.5"/><line x1="14" y1="24" x2="26" y2="24" stroke="#34495e" stroke-width="0.5"/><line x1="14" y1="26" x2="26" y2="26" stroke="#34495e" stroke-width="0.5"/><line x1="14" y1="28" x2="26" y2="28" stroke="#34495e" stroke-width="0.5"/></g><rect x="8" y="14" width="3" height="2" rx="1" fill="#3498db" opacity="0.8"/><rect x="29" y="14" width="3" height="2" rx="1" fill="#3498db" opacity="0.8"/><rect x="8" y="32" width="3" height="2" rx="1" fill="#3498db" opacity="0.8"/><rect x="29" y="32" width="3" height="2" rx="1" fill="#3498db" opacity="0.8"/></svg>`,
    aiTank: `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><filter id="aiGlow"><feGaussianBlur stdDeviation="3" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter><linearGradient id="aiGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#4a00e0;stop-opacity:1" /><stop offset="100%" style="stop-color:#8e2de2;stop-opacity:1" /></linearGradient><linearGradient id="aiCannonGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#3498db;stop-opacity:1" /><stop offset="100%" style="stop-color:#2980b9;stop-opacity:1" /></linearGradient></defs><rect x="6" y="16" width="28" height="18" rx="6" fill="url(#aiGradient)" stroke="#8e2de2" stroke-width="2" filter="url(#aiGlow)"/><rect x="2" y="17" width="8" height="16" rx="4" fill="#2c3e50" /><rect x="30" y="17" width="8" height="16" rx="4" fill="#2c3e50" /><circle cx="20" cy="20" r="10" fill="url(#aiGradient)" stroke="#fff" stroke-width="1.5" /><rect x="17.5" y="4" width="5" height="16" rx="2.5" fill="url(#aiCannonGradient)" stroke="#fff" stroke-width="1.5" /><circle cx="20" cy="20" r="4" fill="#fff" /></svg>`,
    boss: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><defs><linearGradient id="cigarGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#a0522d;stop-opacity:1" /><stop offset="50%" style="stop-color:#8b4513;stop-opacity:1" /><stop offset="100%" style="stop-color:#654321;stop-opacity:1" /></linearGradient><filter id="fireGlow"><feGaussianBlur stdDeviation="4" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><ellipse cx="22" cy="37" rx="16" ry="3" fill="rgba(0,0,0,0.5)"/><rect x="4" y="14" width="32" height="20" rx="4" fill="url(#cigarGradient)" stroke="#654321" stroke-width="2"/><rect x="4" y="16" width="32" height="4" fill="#d2691e" opacity="0.8"/><rect x="4" y="28" width="32" height="4" fill="#d2691e" opacity="0.8"/><rect x="1" y="16" width="8" height="18" rx="4" fill="#2c3e50" stroke="#34495e" stroke-width="1.5"/><rect x="31" y="16" width="8" height="18" rx="4" fill="#2c3e50" stroke="#34495e" stroke-width="1.5"/><circle cx="5" cy="20" r="1.5" fill="#7f8c8d"/><circle cx="5" cy="25" r="1.5" fill="#7f8c8d"/><circle cx="5" cy="30" r="1.5" fill="#7f8c8d"/><circle cx="35" cy="20" r="1.5" fill="#7f8c8d"/><circle cx="35" cy="25" r="1.5" fill="#7f8c8d"/><circle cx="35" cy="30" r="1.5" fill="#7f8c8d"/><ellipse cx="20" cy="18" rx="10" ry="8" fill="url(#cigarGradient)" stroke="#654321" stroke-width="1.5"/><ellipse cx="20" cy="18" rx="8" ry="6" fill="#a0522d" opacity="0.8"/><ellipse cx="20" cy="8" rx="6" ry="4" fill="#ff4500" filter="url(#fireGlow)"/><ellipse cx="20" cy="6" rx="5" ry="3" fill="#ff6347"/><ellipse cx="20" cy="4" rx="4" ry="2" fill="#ff0000"/><ellipse cx="20" cy="3" rx="3" ry="1.5" fill="#dc143c"/><rect x="16" y="6" width="3" height="12" rx="1.5" fill="#654321" stroke="#8b4513" stroke-width="1"/><rect x="21" y="6" width="3" height="12" rx="1.5" fill="#654321" stroke="#8b4513" stroke-width="1"/><g opacity="0.9"><circle cx="14" cy="2" r="2.5" fill="#ff4500"/><circle cx="26" cy="1" r="2" fill="#ff6347"/><circle cx="20" cy="0" r="3" fill="#2c3e50"/><circle cx="17" cy="1" r="1.5" fill="#ff4500"/><circle cx="23" cy="2" r="1.8" fill="#ff6347"/><circle cx="12" cy="3" r="1.2" fill="#2c3e50"/><circle cx="28" cy="3" r="1.2" fill="#2c3e50"/></g><circle cx="15" cy="20" r="2" fill="#ff0000"/><circle cx="25" cy="20" r="2" fill="#ff0000"/><path d="M12,26 Q20,28 28,26" stroke="#ff0000" stroke-width="2.5" fill="none"/><path d="M14,24 Q20,25 26,24" stroke="#dc143c" stroke-width="1.5" fill="none"/><circle cx="20" cy="18" r="11" fill="none" stroke="#ff4500" stroke-width="1" opacity="0.5"/><circle cx="20" cy="18" r="12" fill="none" stroke="#ff6347" stroke-width="0.5" opacity="0.3"/><g transform="translate(20, 24)"><circle cx="0" cy="0" r="3" fill="#000000" opacity="0.8"/><path d="M-2,-2 L2,2 M2,-2 L-2,2" stroke="#ff0000" stroke-width="2"/><circle cx="0" cy="0" r="2.5" fill="none" stroke="#ff0000" stroke-width="1.5"/></g></svg>`,
    enemy: {
        normal: `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><defs><linearGradient id="cigaretteGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#f39c12;stop-opacity:1" /><stop offset="100%" style="stop-color:#d35400;stop-opacity:1" /></linearGradient><filter id="toxicGlow"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><ellipse cx="21" cy="35" rx="10" ry="2" fill="rgba(0,0,0,0.4)"/><rect x="10" y="16" width="20" height="18" rx="2" fill="url(#cigaretteGradient)" stroke="#d35400" stroke-width="1.5"/><rect x="10" y="12" width="20" height="6" rx="2" fill="#ecf0f1" stroke="#bdc3c7" stroke-width="1"/><rect x="12" y="13" width="16" height="4" rx="1" fill="#f8f9fa"/><rect x="7" y="18" width="5" height="16" rx="2" fill="#2c3e50" stroke="#34495e" stroke-width="1"/><rect x="28" y="18" width="5" height="16" rx="2" fill="#2c3e50" stroke="#34495e" stroke-width="1"/><ellipse cx="20" cy="10" rx="4" ry="3" fill="#e74c3c" filter="url(#toxicGlow)"/><ellipse cx="20" cy="9" rx="3" ry="2" fill="#c0392b"/><ellipse cx="20" cy="8" rx="2" ry="1" fill="#a93226"/><g opacity="0.8"><circle cx="17" cy="6" r="2" fill="#2c3e50"/><circle cx="23" cy="4" r="1.5" fill="#34495e"/><circle cx="20" cy="2" r="2.5" fill="#2c3e50"/><circle cx="25" cy="6" r="1" fill="#34495e"/><circle cx="15" cy="3" r="1.5" fill="#2c3e50"/></g><rect x="19" y="8" width="2" height="10" fill="#95a5a6" stroke="#7f8c8d" stroke-width="0.5"/><g transform="translate(20, 25)"><circle cx="0" cy="0" r="3" fill="#e74c3c" opacity="0.9"/><path d="M-2,-2 L2,2 M2,-2 L-2,2" stroke="#ffffff" stroke-width="1.5"/><circle cx="0" cy="0" r="2" fill="none" stroke="#ffffff" stroke-width="1"/></g><circle cx="16" cy="22" r="1" fill="#c0392b"/><circle cx="24" cy="22" r="1" fill="#c0392b"/><path d="M14,28 Q20,30 26,28" stroke="#c0392b" stroke-width="1.5" fill="none"/><text x="20" y="32" text-anchor="middle" font-size="6" fill="#e74c3c" font-weight="bold">⚠</text></svg>`,
        vape: `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><defs><linearGradient id="vapeGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#9b59b6;stop-opacity:1" /><stop offset="100%" style="stop-color:#8e44ad;stop-opacity:1" /></linearGradient><filter id="neonGlow"><feGaussianBlur stdDeviation="3" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><ellipse cx="21" cy="36" rx="12" ry="2" fill="rgba(0,0,0,0.4)"/><rect x="8" y="14" width="24" height="20" rx="4" fill="url(#vapeGradient)" stroke="#bb6bd9" stroke-width="1.5" filter="url(#neonGlow)"/><rect x="10" y="16" width="20" height="8" rx="2" fill="#2c3e50" stroke="#34495e" stroke-width="1"/><rect x="11" y="17" width="18" height="6" rx="1" fill="#00ff88" opacity="0.9"/><text x="20" y="21" text-anchor="middle" font-size="4" fill="#2c3e50" font-weight="bold">VAPE</text><rect x="5" y="18" width="6" height="16" rx="3" fill="#2c3e50" stroke="#34495e" stroke-width="1"/><rect x="29" y="18" width="6" height="16" rx="3" fill="#2c3e50" stroke="#34495e" stroke-width="1"/><rect x="14" y="8" width="12" height="8" rx="2" fill="#34495e" stroke="#2c3e50" stroke-width="1"/><rect x="16" y="6" width="8" height="4" rx="2" fill="#7f8c8d"/><g opacity="0.9"><circle cx="15" cy="4" r="2.5" fill="#e8daef"/><circle cx="25" cy="2" r="2" fill="#e8daef"/><circle cx="20" cy="1" r="3" fill="#d5dbdb"/><circle cx="18" cy="3" r="1.5" fill="#e8daef"/><circle cx="22" cy="4" r="1.8" fill="#d5dbdb"/></g><rect x="8" y="14" width="24" height="20" rx="4" fill="none" stroke="#bb6bd9" stroke-width="1" opacity="0.6"/><rect x="7" y="13" width="26" height="22" rx="5" fill="none" stroke="#e8daef" stroke-width="0.5" opacity="0.4"/><circle cx="13" cy="28" r="2" fill="#ecf0f1" stroke="#bdc3c7" stroke-width="1"/><circle cx="27" cy="28" r="2" fill="#ecf0f1" stroke="#bdc3c7" stroke-width="1"/><rect x="18" y="32" width="4" height="2" rx="1" fill="#34495e"/><g transform="translate(20, 26)"><circle cx="0" cy="0" r="2.5" fill="#e74c3c" opacity="0.9"/><text x="0" y="1" text-anchor="middle" font-size="3" fill="#ffffff" font-weight="bold">!</text></g><rect x="19" y="4" width="2" height="12" fill="#7f8c8d" stroke="#95a5a6" stroke-width="0.5"/></svg>`,
        tough: `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><rect x="8" y="18" width="24" height="16" rx="2" fill="#34495e" stroke="#2c3e50" stroke-width="1"/><rect x="6" y="19" width="5" height="14" rx="2" fill="#2c3e50"/><rect x="29" y="19" width="5" height="14" rx="2" fill="#2c3e50"/><circle cx="20" cy="22" r="6" fill="#2c3e50" stroke="#34495e" stroke-width="1"/><rect x="19" y="8" width="4" height="14" rx="1" fill="#7f8c8d"/><g opacity="0.9"><circle cx="17" cy="4" r="2" fill="#2c3e50"/><circle cx="23" cy="3" r="1.5" fill="#34495e"/><circle cx="20" cy="1" r="2.5" fill="#2c3e50"/></g><g transform="translate(20, 22)"><circle cx="0" cy="0" r="3" fill="#e74c3c" opacity="0.8"/><path d="M-1,-1 L1,1 M1,-1 L-1,1" stroke="#ffffff" stroke-width="1"/></g></svg>`,
        kamikaze: `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><defs><linearGradient id="kamikazeGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#e74c3c;stop-opacity:1"/><stop offset="100%" style="stop-color:#c0392b;stop-opacity:1"/></linearGradient></defs><rect x="8" y="18" width="24" height="16" rx="2" fill="url(#kamikazeGradient)" stroke="#2c3e50" stroke-width="1.5"/><path d="M8 18 L2 10 L8 10 Z" fill="#c0392b"/><path d="M32 18 L38 10 L32 10 Z" fill="#c0392b"/><path d="M8 34 L2 42 L8 42 Z" fill="#c0392b"/><path d="M32 34 L38 42 L32 42 Z" fill="#c0392b"/><rect x="6" y="19" width="5" height="14" rx="2" fill="#2c3e50"/><rect x="29" y="19" width="5" height="14" rx="2" fill="#2c3e50"/><circle cx="20" cy="22" r="8" fill="#2c3e50"/><circle cx="20" cy="22" r="5" fill="#e74c3c"/><circle cx="20" cy="22" r="2" fill="yellow"/><rect x="18" y="4" width="4" height="14" rx="1" fill="#c0392b"/><path d="M20 4 L16 0 L24 0 Z" fill="yellow"/></svg>`
    },
    obstacle: {
        brick: `<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="40" height="40" fill="#a05a2c"/><line x1="0" y1="20" x2="40" y2="20" stroke="#6b3e1c" stroke-width="1.5"/><line x1="20" y1="0" x2="20" y2="20" stroke="#6b3e1c" stroke-width="1.5"/><line x1="20" y1="20" x2="20" y2="40" stroke="#6b3e1c" stroke-width="1.5"/><line x1="0" y1="0" x2="40" y2="0" stroke="#6b3e1c" stroke-width="1.5"/><line x1="0" y1="0" x2="0" y2="40" stroke="#6b3e1c" stroke-width="1.5"/><line x1="40" y1="0" x2="40" y2="40" stroke="#6b3e1c" stroke-width="1.5"/><line x1="0" y1="40" x2="40" y2="40" stroke="#6b3e1c" stroke-width="1.5"/></svg>`,
        steel: `<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="40" height="40" fill="#708090" stroke="#2F4F4F" stroke-width="3"/><rect x="5" y="5" width="30" height="30" fill="#778899" /><circle cx="8" cy="8" r="2" fill="#2F4F4F"/><circle cx="32" cy="8" r="2" fill="#2F4F4F"/><circle cx="8" cy="32" r="2" fill="#2F4F4F"/><circle cx="32" cy="32" r="2" fill="#2F4F4F"/></svg>`,
        tree: `<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><circle cx="20" cy="20" r="18" fill="#228B22" opacity="0.6"/><circle cx="15" cy="15" r="10" fill="#32CD32" opacity="0.6"/><circle cx="25" cy="15" r="8" fill="#32CD32" opacity="0.6"/><circle cx="20" cy="25" r="9" fill="#006400" opacity="0.6"/></svg>`
    },
    base: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><defs><filter id="baseGlow"><feGaussianBlur stdDeviation="1.5" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><g filter="url(#baseGlow)"><rect x="4" y="12" width="32" height="20" fill="#22c55e" stroke="#ffffff" stroke-width="1.5"/><rect x="18" y="16" width="4" height="12" fill="#ffffff"/><rect x="14" y="20" width="12" height="4" fill="#ffffff"/><rect x="2" y="10" width="36" height="3" fill="#f8fafc" stroke="#22c55e" stroke-width="1"/><rect x="2" y="29" width="36" height="3" fill="#f8fafc" stroke="#22c55e" stroke-width="1"/><path d="M10 18 Q12 16 14 18 Q16 16 18 18 Q17 24 14 22 Q11 24 10 18" fill="#ffffff" stroke="#22c55e" stroke-width="0.5" opacity="0.8"/><path d="M22 18 Q24 16 26 18 Q28 16 30 18 Q29 24 26 22 Q23 24 22 18" fill="#ffffff" stroke="#22c55e" stroke-width="0.5" opacity="0.8"/><circle cx="20" cy="22" r="18" fill="none" stroke="#4ade80" stroke-width="0.8" opacity="0.4"/><circle cx="20" cy="22" r="15" fill="none" stroke="#22c55e" stroke-width="0.5" opacity="0.6"/></g></svg>`,
    enemyBase: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><defs><filter id="enemyBaseGlow"><feGaussianBlur stdDeviation="1.5" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><g filter="url(#enemyBaseGlow)"><rect x="4" y="12" width="32" height="20" fill="#374151" stroke="#6b7280" stroke-width="1.5"/><rect x="10" y="6" width="3" height="8" fill="#1f2937" stroke="#4b5563" stroke-width="1"/><rect x="16" y="8" width="3" height="6" fill="#1f2937" stroke="#4b5563" stroke-width="1"/><rect x="22" y="7" width="3" height="7" fill="#1f2937" stroke="#4b5563" stroke-width="1"/><rect x="28" y="5" width="3" height="9" fill="#1f2937" stroke="#4b5563" stroke-width="1"/><path d="M11.5 6 Q10 4 11.5 2 Q13 0 11.5 -2" stroke="#4b5563" stroke-width="1" fill="none"/><path d="M17.5 8 Q16 6 17.5 4 Q19 2 17.5 0" stroke="#6b7280" stroke-width="1" fill="none"/><path d="M23.5 7 Q22 5 23.5 3 Q25 1 23.5 -1" stroke="#4b5563" stroke-width="1" fill="none"/><path d="M29.5 5 Q28 3 29.5 1 Q31 -1 29.5 -3" stroke="#6b7280" stroke-width="1" fill="none"/><rect x="2" y="10" width="36" height="3" fill="#1f2937" stroke="#4b5563" stroke-width="1"/><rect x="2" y="29" width="36" height="3" fill="#1f2937" stroke="#4b5563" stroke-width="1"/><circle cx="20" cy="22" r="18" fill="none" stroke="#ef4444" stroke-width="0.8" opacity="0.4"/><circle cx="20" cy="22" r="15" fill="none" stroke="#dc2626" stroke-width="0.5" opacity="0.5"/></g></svg>`,
};

// --- CORE CLASSES ---

/**
 * A simple particle for visual effects.
 */
class Particle {
    constructor(x, y, color = '#FFF', speed = 2, size = 3, life = 0.5) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * size + 1;
        this.life = Math.random() * life + 0.2;
        this.initialLife = this.life;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * speed;
        this.vx = Math.cos(angle) * velocity;
        this.vy = Math.sin(angle) * velocity;
        this.active = true;
    }

    update(dt) {
        if (!this.active) return;
        this.life -= dt / 1000;
        if (this.life <= 0) {
            this.active = false;
            return;
        }
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95; // friction
        this.vy *= 0.95;
    }

    draw(ctx) {
        if (!this.active) return;
        ctx.save();
        ctx.globalAlpha = this.life / this.initialLife;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.restore();
    }
}

/**
 * Manages the instructions screen flow.
 */
class InstructionManager {
    constructor(game) {
        this.game = game;
        this.screen = document.getElementById('instructions-screen');
        this.steps = this.screen.querySelectorAll('.instruction-step');
        this.nextButton = document.getElementById('btnNextInstruction');
        this.currentStep = 0;
        this.isForcedFlow = false;
        this.nextButton.addEventListener('click', () => this.next());
    }
    start(isForced = false) {
        this.isForcedFlow = isForced;
        this.currentStep = 0;
        document.getElementById('main-menu').classList.add('hidden');
        this.screen.classList.remove('hidden');
        if(!this.game.isInstructionsInitialized) {
            this.game.initInstructionCanvases();
            this.game.isInstructionsInitialized = true;
        }
        this.updateView();
    }
    next() {
        this.currentStep++;
        if (this.currentStep >= this.steps.length) { this.close(); } else { this.updateView(); }
    }
    close() {
        this.screen.classList.add('hidden');
        if (this.isForcedFlow) {
            document.getElementById('game-wrapper').classList.remove('hidden');
            document.getElementById('difficultyScreen').classList.remove('hidden');
        } else {
             document.getElementById('main-menu').classList.remove('hidden');
        }
    }
    updateView() {
        this.steps.forEach((step, index) => {
            step.classList.toggle('hidden', index !== this.currentStep);
        });
        if (this.currentStep >= this.steps.length - 1) {
            this.nextButton.textContent = this.isForcedFlow ? 'Bắt đầu Chiến dịch!' : 'Đã hiểu';
        } else {
            this.nextButton.textContent = 'Tiếp tục';
        }
    }
}

/**
 * Manages background music using Tone.js.
 */
class MusicManager {
    constructor() {
        this.isReady = false;
        Tone.Destination.volume.value = -9;
        const kick = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } }).toDestination();
        const hihat = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
        const bass = new Tone.MonoSynth({ oscillator: { type: 'fmsquare' }, envelope: { attack: 0.01, decay: 0.2, release: 0.2 }, filterEnvelope: { attack: 0.02, decay: 0.1, sustain: 0.5, baseFrequency: 200, octaves: 7 } }).toDestination();
        bass.volume.value = -8;
        const leadSynth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.2, release: 0.2 } }).toDestination();
        leadSynth.volume.value = -10;
        new Tone.Sequence((time, note) => { kick.triggerAttackRelease(note, '8n', time); }, ['C1', null, 'C1', null], '4n').start(0);
        new Tone.Loop((time) => { hihat.triggerAttackRelease('16n', time); }, '8n').start('8n');
        new Tone.Sequence((time, note) => { bass.triggerAttackRelease(note, '8n', time); }, [ 'C2', 'C2', 'G1', 'C2', 'A#1', 'A#1', 'F1', 'A#1', 'G#1', 'G#1', 'D#1', 'G#1', 'G1', 'G1', 'D1', 'G1' ], '4n').start(0);
        new Tone.Sequence((time, note) => { leadSynth.triggerAttackRelease(note, '16n', time); }, [ 'C4', 'E4', 'G4', 'C5', 'G4', 'E4', 'C4', null, 'A#3', 'D4', 'F4', 'A#4', 'F4', 'D4', 'A#3', null, 'G#3', 'C4', 'D#4', 'G#4', 'D#4', 'C4', 'G#3', null, 'G3', 'B3', 'D4', 'G4', 'D4', 'B3', 'G3', null ], '16n').start(0);
        Tone.Transport.bpm.value = 140;
    }
    async start() {
        if (Tone.context.state !== 'running') { await Tone.start(); }
        this.isReady = true;
    }
    startMusic() { if (this.isReady) Tone.Transport.start(); }
    stopMusic() { if (this.isReady) Tone.Transport.stop(); }
    toggleMusic(paused) { if (this.isReady) { if (paused) Tone.Transport.pause(); else Tone.Transport.start(); } }
}

/**
 * Manages sound effects using the Web Audio API.
 */
class SFXManager {
    constructor() { this.audioCtx = null; }
    start() { if (!this.audioCtx) this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    playShoot() { if (this.audioCtx) this._playNote(880, 0, 0.1, 'triangle'); }
    playLaserCharge() { if (this.audioCtx) this._playNote(200, 0, 0.5, 'sawtooth'); }
    playLaserFire() {
        if (!this.audioCtx) return;
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.type = 'sawtooth';
        gain.gain.setValueAtTime(0.5, this.audioCtx.currentTime);
        osc.frequency.setValueAtTime(1000, this.audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.audioCtx.currentTime + 0.3);
        gain.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 0.3);
        osc.start();
        osc.stop(this.audioCtx.currentTime + 0.3);
    }
    playExplosion() {
        if (!this.audioCtx) return;
        const bufferSize = this.audioCtx.sampleRate * 0.5;
        const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
        const source = this.audioCtx.createBufferSource();
        source.buffer = buffer;
        const gainNode = this.audioCtx.createGain();
        gainNode.gain.setValueAtTime(0.3, this.audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.5);
        source.connect(gainNode);
        gainNode.connect(this.audioCtx.destination);
        source.start();
    }
    playPowerUp() { if (this.audioCtx) { this._playNote(523.25, 0); this._playNote(659.25, 0.1); this._playNote(783.99, 0.2); } }
    playGameOver() { if (this.audioCtx) { this._playNote(261.63, 0, 0.2); this._playNote(220.00, 0.2, 0.2); this._playNote(174.61, 0.4, 0.2); this._playNote(146.83, 0.6, 0.4); } }
    playLevelComplete() { if (this.audioCtx) { this._playNote(261.63, 0); this._playNote(392.00, 0.15); this._playNote(523.25, 0.3); this._playNote(659.25, 0.45, 0.4); } }
    _playNote(frequency, startTimeOffset, duration = 0.1, type = 'sine') {
        const oscillator = this.audioCtx.createOscillator();
        const gainNode = this.audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(this.audioCtx.destination);
        const now = this.audioCtx.currentTime;
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, now + startTimeOffset);
        gainNode.gain.setValueAtTime(0.3, now + startTimeOffset);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + startTimeOffset + duration);
        oscillator.start(now + startTimeOffset);
        oscillator.stop(now + startTimeOffset + duration);
    }
}

/**
 * Caches rendered SVG sprites for performance.
 */
class SpriteManager {
    constructor() { this.cache = {}; this.pending = {}; }
    get(key, width, height, drawFunction) {
        if (this.cache[key]) return Promise.resolve(this.cache[key]);
        if (this.pending[key]) return this.pending[key];
        const promise = new Promise((resolve, reject) => {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            const img = new Image();
            const blob = new Blob([drawFunction()], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            img.onload = () => {
                ctx.drawImage(img, 0, 0, width, height);
                URL.revokeObjectURL(url);
                this.cache[key] = canvas;
                delete this.pending[key];
                resolve(canvas);
            };
            img.onerror = () => {
                URL.revokeObjectURL(url);
                delete this.pending[key];
                reject(new Error(`SpriteManager Error: Could not load image for key: ${key}`));
            };
            img.src = url;
        });
        this.pending[key] = promise;
        return promise;
    }
}
const spriteManager = new SpriteManager();

/**
 * Base class for all tank-like objects.
 */
class Tank {
    constructor(x, y) { this.x = x; this.y = y; this.width = GAME_CONFIG.TILE_SIZE - 2; this.height = GAME_CONFIG.TILE_SIZE - 2; this.direction = 'up'; this.sprite = null; this.active = true; }
    draw(ctx) { if (!this.active || !this.sprite) return; ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); switch(this.direction) { case 'right': ctx.rotate(Math.PI/2); break; case 'down': ctx.rotate(Math.PI); break; case 'left': ctx.rotate(-Math.PI/2); break; } ctx.translate(-GAME_CONFIG.TILE_SIZE/2, -GAME_CONFIG.TILE_SIZE/2); ctx.drawImage(this.sprite, 0, 0); ctx.restore(); }
    move(direction, dt, canvasWidth, canvasHeight, obstacles) {
        this.direction = direction;
        const moveDistance = this.speed * (dt / 1000);
        let moveX = 0, moveY = 0;
        switch(direction) {
            case 'up': moveY = -moveDistance; break;
            case 'down':  moveY = moveDistance; break;
            case 'left':  moveX = -moveDistance; break;
            case 'right': moveX = moveDistance; break;
        }
        const futureBounds = { x: this.x + moveX, y: this.y + moveY, width: this.width, height: this.height };
        let canMoveX = true;
        let canMoveY = true;
        for (const obstacle of obstacles) {
            if (obstacle !== this && obstacle.active && obstacle.blocksMovement() && this.checkCollisionWith(futureBounds, obstacle)) {
                if (this.checkCollisionWith({ ...futureBounds, y: this.y }, obstacle)) canMoveX = false;
                if (this.checkCollisionWith({ ...futureBounds, x: this.x }, obstacle)) canMoveY = false;
            }
        }
        if(canMoveX) this.x += moveX;
        if(canMoveY) this.y += moveY;
        this.x = Math.max(0, Math.min(this.x, canvasWidth - this.width));
        this.y = Math.max(0, Math.min(this.y, canvasHeight - this.height));
    }
    checkCollisionWith(obj1, obj2) { return obj1.x < obj2.x + obj2.width && obj1.x + obj1.width > obj2.x && obj1.y < obj2.y + obj2.height && obj1.y + obj1.height > obj2.y; }
    checkCollision(obj) { return this.checkCollisionWith(this, obj); }
    blocksMovement() { return true; }
}

class Player extends Tank {
    constructor(x, y) { 
        super(x, y); 
        this.baseSpeed = GAME_CONFIG.PLAYER.BASE_SPEED; 
        this.speed = this.baseSpeed; 
        this.level = 1; 
        this.isInvincible = false; 
        this.invincibilityTimer = 0; 
        this.isReflectShieldActive = false;
        this.reflectShieldTimer = 0;
        this.loadSprite(); 
    }
    loadSprite() { spriteManager.get(`player_tank_super`, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE, () => SVG_SPRITES.player).then(sprite => { this.sprite = sprite; }); }
    draw(ctx) { 
        super.draw(ctx); 
        const time = Date.now() * 0.01;
        ctx.save(); 
        ctx.translate(this.x + this.width/2, this.y + this.height/2); 
        if (this.isInvincible) { 
            ctx.beginPath(); 
            ctx.arc(0, 0, 22, 0, Math.PI * 2); 
            ctx.fillStyle = `rgba(0, 180, 216, ${0.3 + Math.sin(time) * 0.2})`; 
            ctx.fill(); 
            ctx.strokeStyle = "#90e0ef"; 
            ctx.lineWidth = 2.5; 
            ctx.stroke(); 
        }
        if (this.isReflectShieldActive) {
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 100, 255, ${0.5 + Math.sin(time * 1.5) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        ctx.restore(); 
    }
    levelUp() { if (this.level < GAME_CONFIG.PLAYER.MAX_LEVEL) { this.level++; this.speed = this.baseSpeed + (this.level - 1) * GAME_CONFIG.PLAYER.SPEED_INCREMENT; return true; } return false; }
    getBulletSpeed() { return GAME_CONFIG.PLAYER.BULLET_SPEED_BASE + this.level * GAME_CONFIG.PLAYER.BULLET_SPEED_INCREMENT; }
    getBulletCount() { return this.level >= 3 ? 2 : 1; }
    canBreakSteel() { return this.level >= GAME_CONFIG.PLAYER.MAX_LEVEL; }
}

class AITank extends Tank {
    constructor(x, y, id) { super(x, y); this.id = id; this.speed = GAME_CONFIG.ENEMY.AI_TANK.SPEED; this.level = 1; this.loadSprite(); this.aiState = 'wandering'; this.stateTimer = 0; this.changeStateInterval = Math.random() * 2000 + 2000; this.shootCooldown = GAME_CONFIG.ENEMY.AI_TANK.SHOT_COOLDOWN; this.lastShotTime = 0; }
    loadSprite() { spriteManager.get(`ai_tank`, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE, () => SVG_SPRITES.aiTank).then(sprite => { this.sprite = sprite; }); }
    update(dt, game) { if (!this.active) return; this.stateTimer += dt; if (this.stateTimer > this.changeStateInterval) { this.stateTimer = 0; const directions = ['up', 'down', 'left', 'right']; this.direction = directions[Math.floor(Math.random() * directions.length)]; } const allObstacles = [game.player, ...game.allies, ...game.enemies, ...game.obstacles, game.base, game.enemyBase].filter(Boolean); this.move(this.direction, dt, game.canvas.width, game.canvas.height, allObstacles); if (Date.now() - this.lastShotTime > this.shootCooldown) { const sightRange = 300; for (const enemy of game.enemies) { let inSight = false; switch (this.direction) { case 'up': inSight = Math.abs(enemy.x - this.x) < this.width && this.y > enemy.y && this.y - enemy.y < sightRange; break; case 'down': inSight = Math.abs(enemy.x - this.x) < this.width && this.y < enemy.y && enemy.y - this.y < sightRange; break; case 'left': inSight = Math.abs(enemy.y - this.y) < this.height && this.x > enemy.x && this.x - enemy.x < sightRange; break; case 'right': inSight = Math.abs(enemy.y - this.y) < this.height && this.x < enemy.x && enemy.x - this.x < sightRange; break; } if (inSight) { game.shoot(this, 'ai'); this.lastShotTime = Date.now(); break; } } } }
    getBulletSpeed() { return GAME_CONFIG.ENEMY.AI_TANK.BULLET_SPEED; }
    getBulletCount() { return 1; }
    canBreakSteel() { return false; }
}

class Bullet {
    constructor(x, y, direction, owner, speed = 420) { this.x = x; this.y = y; this.width = 8; this.height = 16; this.speed = speed; this.direction = direction; this.active = true; this.owner = owner; this.pulseTimer = 0; }
    update(dt, canvasWidth, canvasHeight) { this.pulseTimer += dt; const moveDistance = this.speed * (dt / 1000); switch(this.direction) { case 'up': this.y -= moveDistance; break; case 'down': this.y += moveDistance; break; case 'left': this.x -= moveDistance; break; case 'right': this.x += moveDistance; break; } if (this.x < -20 || this.x > canvasWidth + 20 || this.y < -20 || this.y > canvasHeight + 20) this.active = false; }
    draw(ctx) { if (!this.active) return; ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); switch(this.direction) { case 'right': ctx.rotate(Math.PI/2); break; case 'down': ctx.rotate(Math.PI); break; case 'left': ctx.rotate(-Math.PI/2); break; } ctx.translate(-this.width / 2, -this.height / 2); const gradient = ctx.createLinearGradient(0, 0, 0, this.height); if (this.owner === 'player' || this.owner === 'ai') { gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(0.3, '#00ff88'); gradient.addColorStop(0.6, '#2ecc71'); gradient.addColorStop(1, '#f1c40f'); } else { gradient.addColorStop(0, '#ff4757'); gradient.addColorStop(1, '#ff6b81'); } ctx.fillStyle = gradient; const pulse = 0.5 + Math.sin(this.pulseTimer / 100) * 0.5; ctx.shadowColor = (this.owner === 'player' || this.owner === 'ai') ? `rgba(0, 255, 136, ${0.6 + pulse * 0.4})` : `rgba(255, 71, 87, ${0.6 + pulse * 0.4})`; ctx.shadowBlur = 12 + pulse * 8; ctx.beginPath(); ctx.rect(0, 0, this.width, this.height); ctx.fill(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 1.5; ctx.stroke(); ctx.restore(); }
    checkCollision(obj) { return this.x < obj.x + obj.width && this.x + this.width > obj.x && this.y < obj.y + obj.height && this.y + this.height > obj.y; }
}

class Laser {
    constructor(boss, owner) { this.boss = boss; this.owner = owner; this.active = true; this.timer = 0; this.chargeDuration = 500; this.activeDuration = 300; this.fadeDuration = 200; this.totalDuration = this.chargeDuration + this.activeDuration + this.fadeDuration; this.width = 16; this.length = 1000; this.startX = 0; this.startY = 0; this.direction = 'up'; }
    updateOrigin() {
        const centerX = this.boss.x + this.boss.width / 2;
        const centerY = this.boss.y + this.boss.height / 2;
        const barrelOffset = this.boss.height / 2 - 10;
        this.direction = this.boss.direction;
        switch(this.direction) {
            case 'up': this.startX = centerX; this.startY = centerY - barrelOffset; break;
            case 'down': this.startX = centerX; this.startY = centerY + barrelOffset; break;
            case 'left': this.startX = centerX - barrelOffset; this.startY = centerY; break;
            case 'right': this.startX = centerX + barrelOffset; this.startY = centerY; break;
        }
    }
    update(dt) { this.updateOrigin(); this.timer += dt; if (this.timer >= this.totalDuration) { this.active = false; } }
    isDamaging() { return this.timer > this.chargeDuration && this.timer < (this.chargeDuration + this.activeDuration); }
    getBounds() {
        switch(this.direction) {
            case 'up': return { x: this.startX - this.width / 2, y: this.startY - this.length, width: this.width, height: this.length };
            case 'down': return { x: this.startX - this.width / 2, y: this.startY, width: this.width, height: this.length };
            case 'left': return { x: this.startX - this.length, y: this.startY - this.width / 2, width: this.length, height: this.width };
            case 'right': return { x: this.startX, y: this.startY - this.width / 2, width: this.length, height: this.width };
        }
    }
    checkCollision(obj) {
        if (!this.isDamaging()) return false;
        const bounds = this.getBounds();
        return bounds.x < obj.x + obj.width && bounds.x + bounds.width > obj.x && bounds.y < obj.y + obj.height && bounds.y + bounds.height > obj.y;
    }
    draw(ctx) {
        if (!this.active) return;
        ctx.save();
        let opacity = 1.0;
        let beamWidth = this.width;
        if (this.timer < this.chargeDuration) {
            const chargeProgress = this.timer / this.chargeDuration;
            beamWidth = 2 + Math.sin(chargeProgress * Math.PI) * 4;
            opacity = 0.5 + Math.sin(chargeProgress * Math.PI) * 0.5;
        } else if (this.timer >= this.chargeDuration + this.activeDuration) {
            const fadeProgress = (this.timer - (this.chargeDuration + this.activeDuration)) / this.fadeDuration;
            opacity = 1.0 - fadeProgress;
        }
        ctx.globalAlpha = opacity;
        ctx.translate(this.startX, this.startY);
        switch(this.direction) {
            case 'right': ctx.rotate(Math.PI / 2); break;
            case 'down': ctx.rotate(Math.PI); break;
            case 'left': ctx.rotate(-Math.PI / 2); break;
        }
        const gradient = ctx.createLinearGradient(0, 0, beamWidth, 0);
        gradient.addColorStop(0, "rgba(255, 100, 100, 0)");
        gradient.addColorStop(0.2, "rgba(255, 150, 150, 0.8)");
        gradient.addColorStop(0.5, "rgba(255, 255, 255, 1)");
        gradient.addColorStop(0.8, "rgba(255, 150, 150, 0.8)");
        gradient.addColorStop(1, "rgba(255, 100, 100, 0)");
        ctx.fillStyle = gradient;
        ctx.shadowColor = "red";
        ctx.shadowBlur = 20;
        ctx.fillRect(-beamWidth/2, 0, beamWidth, -this.length);
        ctx.restore();
    }
}

class Enemy extends Tank {
    constructor(x, y, type = 'normal') { super(x, y); this.direction = 'down'; this.changeDirectionTimer = 0; this.changeDirectionInterval = 2000; this.enemyType = type; const conf = GAME_CONFIG.ENEMY[type.toUpperCase()]; this.speed = conf.SPEED; this.health = conf.HEALTH; this.shotCooldown = conf.SHOT_COOLDOWN; this.lastShotTime = Date.now() + Math.random() * this.shotCooldown; this.loadSprite(); }
    getBulletCount() { return 1; }
    getBulletSpeed() { return 420; }
    loadSprite() { spriteManager.get(`enemy_new_${this.enemyType}`, this.width, this.height, () => SVG_SPRITES.enemy[this.enemyType]).then(sprite => { this.sprite = sprite; }); }
    getRandomDirection() { return ['up','down','left','right'][Math.floor(Math.random()*4)]; }
    hit() { this.health--; this.isHit = true; setTimeout(() => this.isHit = false, 100); if (this.health <= 0) this.active = false; }
    update(dt, canvasWidth, canvasHeight, obstacles, game) { 
        if (game.enemiesFrozen) return;
        this.changeDirectionTimer += dt;
        if (this.changeDirectionTimer >= this.changeDirectionInterval) {
            this.changeDirectionTimer = 0;
            const rand = Math.random();
            if (rand < 0.7) { 
                 this.direction = this.getRandomDirection();
            } else { 
                const target = game.base.active ? game.base : game.player;
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.direction = dx > 0 ? 'right' : 'left';
                } else {
                    this.direction = dy > 0 ? 'down' : 'up';
                }
            }
        } 
        this.move(this.direction, dt, canvasWidth, canvasHeight, obstacles);
        const now = Date.now(); 
        if (now - this.lastShotTime > this.shotCooldown) { 
            this.lastShotTime = now; 
            game.shoot(this, 'enemy'); 
        } 
    }
    draw(ctx) { if (!this.active || !this.sprite) return; ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); switch(this.direction) { case 'up': ctx.rotate(0); break; case 'right': ctx.rotate(Math.PI/2); break; case 'down': ctx.rotate(Math.PI); break; case 'left': ctx.rotate(-Math.PI/2); break; } ctx.translate(-this.width/2, -this.height/2); if (this.isHit) ctx.globalAlpha = 0.5; ctx.drawImage(this.sprite, 0, 0); ctx.globalAlpha = 1.0; ctx.restore(); }
}

class KamikazeEnemy extends Enemy {
    constructor(x, y) {
        super(x, y, 'kamikaze');
        this.shotCooldown = 999999; // Does not shoot
    }

    update(dt, canvasWidth, canvasHeight, obstacles, game) {
        if (game.enemiesFrozen) return;

        // Check for proximity to explode before moving.
        // We use a slightly larger bounding box for detection to ensure the explosion triggers on contact.
        const detectionBox = {
            x: this.x - 2,
            y: this.y - 2,
            width: this.width + 4,
            height: this.height + 4
        };

        if (game.player.active && game.player.checkCollision(detectionBox)) {
            this.active = false; // Deactivate and explode
            game.triggerShake(12, 400);
            
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            game.createParticles(centerX, centerY, 50, '#e74c3c', 5);
            
            // Define the explosion area of effect, centered on the kamikaze tank
            const explosionRadius = GAME_CONFIG.ENEMY.KAMIKAZE.EXPLOSION_RADIUS;
            const damageArea = {
                x: centerX - explosionRadius / 2,
                y: centerY - explosionRadius / 2,
                width: explosionRadius,
                height: explosionRadius
            };

            // Damage the player if they are in the blast radius and not invincible
            if (!game.player.isInvincible && game.player.checkCollision(damageArea)) {
                 game.lives--;
                 if (game.lives <= 0) { 
                     game.gameOver("Bạn đã bị dính vụ nổ cảm tử!"); 
                 } else { 
                     game.respawnPlayer(); 
                 }
            }

            // The explosion should also damage allies
            game.allies.forEach(ally => {
                if (ally.active && ally.checkCollision(damageArea)) {
                    ally.active = false;
                    game.triggerShake(8, 250);
                    game.createParticles(ally.x + ally.width / 2, ally.y + ally.height / 2, 20, '#8e2de2');
                    setTimeout(() => game.respawnAlly(ally), 5000);
                }
            });
            return; // Stop further processing for this frame
        }

        // If not exploding, determine direction and move
        const target = game.player;
        const dx = target.x - this.x;
        const dy = target.y - this.y;

        if (Math.abs(dx) > Math.abs(dy)) {
            this.direction = dx > 0 ? 'right' : 'left';
        } else {
            this.direction = dy > 0 ? 'down' : 'up';
        }
        
        this.move(this.direction, dt, canvasWidth, canvasHeight, obstacles);
    }
}


class Boss extends Enemy {
    constructor(x, y, maxHealth, difficulty) {
        super(x, y, 'boss');
        this.width = GAME_CONFIG.TILE_SIZE * 2;
        this.height = GAME_CONFIG.TILE_SIZE * 2;
        this.maxHealth = maxHealth;
        this.health = this.maxHealth;
        this.speed = GAME_CONFIG.ENEMY.BOSS.SPEED;
        this.direction = 'down';
        this.attackPatterns = ['singleShot', 'doubleShot', 'tripleShot', 'laser'];
        this.currentAttackPattern = 'singleShot';
        this.shotCooldown = GAME_CONFIG.ENEMY.BOSS.SHOT_COOLDOWN;
        this.lastShotTime = Date.now();
        this.changeDirectionTimer = 0;
        this.changeDirectionInterval = 3500;
        this.difficulty = difficulty;
        this.isTargeting = false;
        this.targetingTimer = 0;
    }
    loadSprite() { spriteManager.get('boss_cigar_super', 80, 80, () => SVG_SPRITES.boss).then(sprite => { this.sprite = sprite; }); }
    update(dt, canvasWidth, canvasHeight, obstacles, game) {
        if (game.enemiesFrozen) return;
        if(this.isTargeting) {
            this.targetingTimer -= dt;
            if(this.targetingTimer <= 0) {
                this.isTargeting = false;
            }
        }
        this.changeDirectionTimer += dt;
        if (this.changeDirectionTimer >= this.changeDirectionInterval) {
            this.changeDirectionTimer = 0;
            const rand = Math.random();
            const oldDirection = this.direction;
            if (rand < 0.5) {
                this.direction = this.getRandomDirection();
            } else {
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.direction = dx > 0 ? 'right' : 'left';
                } else {
                    this.direction = dy > 0 ? 'down' : 'up';
                }
            }
            if(this.direction !== oldDirection && this.difficulty === 'easy') {
                this.isTargeting = true;
                this.targetingTimer = GAME_CONFIG.ENEMY.BOSS.EASY_MODE_ATTACK_DELAY;
            }
        }
        this.move(this.direction, dt, canvasWidth, canvasHeight, obstacles);
        const now = Date.now();
        if (!this.isTargeting && now - this.lastShotTime > this.shotCooldown) {
            this.lastShotTime = now;
            this.currentAttackPattern = this.attackPatterns[Math.floor(Math.random() * this.attackPatterns.length)];
            if (this.currentAttackPattern === 'laser') {
                this.shotCooldown = GAME_CONFIG.ENEMY.BOSS.LASER_COOLDOWN;
                game.sfxManager.playLaserCharge();
            } else {
                this.shotCooldown = GAME_CONFIG.ENEMY.BOSS.SHOT_COOLDOWN;
            }
            game.bossShoot(this, this.currentAttackPattern);
        }
    }
    draw(ctx) {
        if (!this.active || !this.sprite) return;
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        switch (this.direction) {
            case 'right': ctx.rotate(Math.PI / 2); break;
            case 'down': ctx.rotate(Math.PI); break;
            case 'left': ctx.rotate(-Math.PI / 2); break;
        }
        ctx.translate(-this.width / 2, -this.height / 2);
        if (this.isHit) ctx.globalAlpha = 0.5;
        if (this.isTargeting) {
            const pulse = 0.5 + Math.sin(Date.now() / 100) * 0.5;
            ctx.fillStyle = `rgba(255, 0, 0, ${pulse * 0.5})`;
            ctx.beginPath();
            ctx.arc(this.width/2, this.height/2, this.width/2 + 5, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.drawImage(this.sprite, 0, 0, this.width, this.height);
        ctx.globalAlpha = 1.0;
        ctx.restore();
    }
}

class Obstacle {
    static dynamicSpriteCache = {};
    static lastDynamicUpdate = 0;
    static DYNAMIC_UPDATE_INTERVAL = 100;
    constructor(x, y, type) { this.x = x; this.y = y; this.width = GAME_CONFIG.TILE_SIZE; this.height = GAME_CONFIG.TILE_SIZE; this.type = type; this.active = true; this.sprite = null; this.isDynamic = this.type === 'water'; if (!this.isDynamic) { this.loadSprite(); } else { if (!Obstacle.dynamicSpriteCache[this.type]) { const canvas = document.createElement('canvas'); canvas.width = this.width; canvas.height = this.height; Obstacle.dynamicSpriteCache[this.type] = canvas; } } }
    loadSprite() { spriteManager.get(this.type, this.width, this.height, () => SVG_SPRITES.obstacle[this.type]).then(sprite => { this.sprite = sprite; }); }
    static updateDynamicSprites(timestamp) { if (timestamp - this.lastDynamicUpdate < this.DYNAMIC_UPDATE_INTERVAL) return; this.lastDynamicUpdate = timestamp; const t = timestamp * 0.003; const waterCanvas = this.dynamicSpriteCache['water']; if (waterCanvas) { const ctx = waterCanvas.getContext('2d'); ctx.clearRect(0,0,GAME_CONFIG.TILE_SIZE,GAME_CONFIG.TILE_SIZE); ctx.fillStyle = "#4169E1"; ctx.fillRect(0, 0, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE); ctx.globalAlpha = 0.8; ctx.strokeStyle = "#87CEEB"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, 20 + Math.sin(t) * 3); ctx.quadraticCurveTo(10, 15 + Math.cos(t * 1.2) * 2, 20, 20 + Math.sin(t * 0.8) * 3); ctx.quadraticCurveTo(30, 25 + Math.sin(t * 1.1) * 3, 40, 20 + Math.sin(t * 1.1) * 3); ctx.stroke(); ctx.globalAlpha = 0.6; ctx.strokeStyle = "#ADD8E6"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, 25 + Math.cos(t * 1.3) * 2); ctx.quadraticCurveTo(15, 20 + Math.sin(t * 0.9) * 2, 30, 25 + Math.cos(t * 1.4) * 2); ctx.quadraticCurveTo(35, 28 + Math.cos(t * 1.2) * 2, 40, 25 + Math.cos(t * 1.6) * 2); ctx.stroke(); } }
    draw(ctx) { if (!this.active) return; if (this.isDynamic) { const sprite = Obstacle.dynamicSpriteCache[this.type]; if (sprite) ctx.drawImage(sprite, this.x, this.y); } else if (this.sprite) { ctx.drawImage(this.sprite, this.x, this.y); } }
    checkCollision(obj) { return this.x < obj.x + obj.width && this.x + this.width > obj.x && this.y < obj.y + obj.height && this.y + this.height > obj.y; }
    canDestroy() { return this.type === 'brick'; }
    blocksMovement() { return this.type !== 'tree'; }
    blocksBullets() { return this.type === 'brick' || this.type === 'steel'; }
}

class PowerUp {
    constructor(x, y, type) { this.x = x; this.y = y; this.width = 30; this.height = 30; this.type = type; this.active = true; this.spawnTime = Date.now(); this.lifeSpan = GAME_CONFIG.POWERUP.LIFESPAN; }
    draw(ctx) { 
        if (!this.active) return; 
        const timeSinceSpawn = Date.now() - this.spawnTime; 
        if (this.lifeSpan - timeSinceSpawn < 2000) { 
            if (Math.floor(timeSinceSpawn / 200) % 2 !== 0) return; 
        } 
        ctx.save(); 
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2); 
        const pulse = 0.9 + Math.sin(Date.now() * 0.005) * 0.1; 
        ctx.scale(pulse, pulse); 
        ctx.translate(-15, -15); 
        ctx.lineWidth = 2;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        switch(this.type) { 
            case 'star': ctx.fillStyle = "#FFD700"; ctx.strokeStyle = "#FFA000"; ctx.beginPath(); ctx.moveTo(15, 2); ctx.lineTo(18.09, 10.26); ctx.lineTo(27, 11.27); ctx.lineTo(20.5, 17.24); ctx.lineTo(22.18, 26); ctx.lineTo(15, 21.5); ctx.lineTo(7.82, 26); ctx.lineTo(9.5, 17.24); ctx.lineTo(3, 11.27); ctx.lineTo(11.91, 10.26); ctx.closePath(); ctx.fill(); ctx.stroke(); break; 
            case 'helmet': ctx.fillStyle = "#e0f7fa"; ctx.strokeStyle = "#00bcd4"; ctx.beginPath(); ctx.moveTo(5, 15); ctx.arcTo(15, 5, 25, 15, 12); ctx.lineTo(25, 25); ctx.lineTo(5, 25); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#b2ebf2"; ctx.strokeStyle = "#00bcd4"; ctx.lineWidth = 1.5; ctx.fillRect(4, 13, 22, 4); ctx.strokeRect(4, 13, 22, 4); break; 
            case 'timer': ctx.fillStyle = "#E1F5FE"; ctx.strokeStyle = "#0288D1"; ctx.beginPath(); ctx.arc(15, 15, 13, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = "#01579B"; ctx.beginPath(); ctx.moveTo(15, 7); ctx.lineTo(15, 15); ctx.lineTo(21, 18); ctx.stroke(); break; 
            case 'bomb': ctx.fillStyle = "#80deea"; ctx.strokeStyle = "#00acc1"; ctx.beginPath(); ctx.arc(15, 15, 12, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#006064"; ctx.font = "bold 14px 'Roboto Condensed'"; ctx.fillText("O₂", 15, 16); break; 
            case 'shield': ctx.fillStyle = "#f3e5f5"; ctx.strokeStyle = "#8e2de2"; ctx.beginPath(); ctx.arc(15, 15, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#8e2de2"; ctx.font = "bold 18px 'Roboto Condensed'"; ctx.fillText("⮌", 15, 17); break;
        } 
        ctx.restore(); 
    }
    checkCollision(obj) { return this.x < obj.x + obj.width && this.x + this.width > obj.x && this.y < obj.y + obj.height && this.y + this.height > obj.y; }
}

class Effect {
    constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.timer = 0; this.active = true; if (this.type === 'explosion') { this.duration = 800; this.maxRadius = 40; } else if (this.type === 'muzzle') { this.duration = 200; this.maxRadius = 15; } }
    update(dt) { this.timer += dt; if (this.timer >= this.duration) this.active = false; }
    draw(ctx) { if (!this.active) return; const progress = this.timer / this.duration; const currentRadius = this.maxRadius * Math.sin(progress * Math.PI); const opacity = 1 - progress; ctx.save(); ctx.globalAlpha = opacity; const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, currentRadius); gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(0.3, '#00ff88'); gradient.addColorStop(0.6, '#f1c40f'); gradient.addColorStop(1, 'rgba(230, 126, 34, 0)'); ctx.fillStyle = gradient; ctx.shadowColor = `rgba(0, 255, 136, ${opacity * 0.8})`; ctx.shadowBlur = 30 * progress; ctx.beginPath(); ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
}

class Base {
    constructor(x, y) { this.x = x; this.y = y; this.width = GAME_CONFIG.TILE_SIZE * 2; this.height = GAME_CONFIG.TILE_SIZE * 2; this.maxHealth = GAME_CONFIG.BASE.PLAYER_MAX_HEALTH; this.health = this.maxHealth; this.active = true; this.sprite = null; this.loadSprite(); }
    loadSprite() { spriteManager.get('base_health_hq', this.width, this.height, () => SVG_SPRITES.base).then(sprite => { this.sprite = sprite; }); }
    draw(ctx, timestamp) { if (!this.active || !this.sprite) return; const t = timestamp * 0.003; const scale = 1.0 + Math.sin(t * 1.5) * 0.05; ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.scale(scale, scale); ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2)); ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height); ctx.restore(); const barWidth = this.width; const barHeight = 10; const barX = this.x; const barY = this.y - barHeight - 5; ctx.fillStyle = '#555'; ctx.fillRect(barX, barY, barWidth, barHeight); const healthPercent = this.health / this.maxHealth; ctx.fillStyle = healthPercent > 0.5 ? '#388e3c' : healthPercent > 0.2 ? '#fbc02d' : '#d32f2f'; ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barWidth, barHeight); }
    hit() { if (this.health > 0) { this.health--; if (this.health <= 0) this.active = false; } }
    checkCollision(obj) { return this.x < obj.x + obj.width && this.x + this.width > obj.x && this.y < obj.y + obj.height && this.y + this.height > obj.y; }
    blocksMovement() { return true; }
}

class EnemyBase {
    constructor(x, y) { this.x = x; this.y = y; this.width = GAME_CONFIG.TILE_SIZE * 2; this.height = GAME_CONFIG.TILE_SIZE * 2; this.maxHealth = GAME_CONFIG.BASE.ENEMY_MAX_HEALTH; this.health = this.maxHealth; this.active = true; this.sprite = null; this.loadSprite(); }
    loadSprite() { spriteManager.get('base_enemy_hq', this.width, this.height, () => SVG_SPRITES.enemyBase).then(sprite => { this.sprite = sprite; }); }
    draw(ctx, timestamp) { if (!this.active || !this.sprite) return; const t = timestamp * 0.003; const scale = 1.0 + Math.sin(t * 1.2) * 0.05; ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.scale(scale, scale); ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2)); ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height); ctx.restore(); const barWidth = this.width; const barHeight = 10; const barX = this.x; const barY = this.y + this.height + 5; ctx.fillStyle = '#555'; ctx.fillRect(barX, barY, barWidth, barHeight); const healthPercent = this.health / this.maxHealth; ctx.fillStyle = healthPercent > 0.5 ? '#388e3c' : healthPercent > 0.2 ? '#fbc02d' : '#d32f2f'; ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barWidth, barHeight); }
    hit() { if (this.health > 0) { this.health--; if (this.health <= 0) this.active = false; } }
    checkCollision(obj) { return this.x < obj.x + obj.width && this.x + this.width > obj.x && this.y < obj.y + obj.height && this.y + this.height > obj.y; }
    blocksMovement() { return true; }
}

/**
 * The main Game class, orchestrating the entire game logic.
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.notificationBar = document.getElementById('notification-bar');
        this.notificationTimeout = null;
        this.musicManager = new MusicManager();
        this.sfxManager = new SFXManager();
        this.instructionManager = new InstructionManager(this);
        
        this.hudElements = {
            container: document.getElementById('hud'),
            lives: document.getElementById('lives'),
            level: document.getElementById('level'),
            stage: document.getElementById('stage'),
            score: document.getElementById('score'),
            highScore: document.getElementById('highScore'),
            enemiesLeftContainer: document.getElementById('enemiesLeftContainer'),
            enemiesLeft: document.getElementById('enemiesLeft'),
            bossHealthContainer: document.getElementById('bossHealthContainer'),
            bossHealthFill: document.getElementById('bossHealthFill'),
            playerBaseName: document.getElementById('playerBaseName'),
            enemyBaseName: document.getElementById('enemyBaseName')
        };
        
        this.setupEventListeners();
        this.gameState = 'menu';
        this.difficulty = 'hard';
        this.isInstructionsInitialized = false;
        this.score = 0;
        this.highScore = 0;
        this.levelData = [];
        this.lasers = [];
        this.particles = []; // Array to hold particle effects
        this.shakeDuration = 0; // Screen shake properties
        this.shakeIntensity = 0;
        this.shakeTimer = 0;
        this.canContinue = true;
        this.antiSmokingFacts = [
            { text: "Tổ chức Y tế Thế giới (WHO) cho biết: Hút thuốc lá là nguyên nhân của hơn 8 triệu ca tử vong mỗi năm trên toàn cầu.", duration: 5000 },
            { text: "Theo CDC Hoa Kỳ, khói thuốc chứa hơn 7.000 hóa chất, với ít nhất 70 chất được biết là gây ung thư.", duration: 5000 },
            { text: "Người hút thuốc có nguy cơ mắc bệnh tim và đột quỵ cao gấp 2 đến 4 lần người không hút thuốc.", duration: 4000 },
            { text: "Bỏ thuốc lá giúp cải thiện chức năng phổi chỉ sau 2 tuần đến 3 tháng. Hãy hành động ngay!", duration: 4500 },
            { text: "Thuốc lá điện tử (vape) không phải là giải pháp an toàn. Chúng chứa nicotine gây nghiện và các hóa chất độc hại khác.", duration: 5000 },
            { text: "Tiếp xúc với khói thuốc thụ động cũng gây ra ung thư phổi và bệnh tim ở người không hút thuốc.", duration: 5000 }
        ];
        this.backgroundCanvas = document.createElement('canvas');
        this.backgroundCanvas.width = this.canvas.width;
        this.backgroundCanvas.height = this.canvas.height;
        this.backgroundCtx = this.backgroundCanvas.getContext('2d');
        this.drawBackground();
        this.lastTime = 0;
        requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
    }
    drawBackground() {
        this.backgroundCtx.fillStyle = '#1b263b';
        this.backgroundCtx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.backgroundCtx.strokeStyle = 'rgba(255,255,255,0.08)';
        this.backgroundCtx.lineWidth = 1;
        for (let x = 0; x <= this.canvas.width; x += GAME_CONFIG.TILE_SIZE) { this.backgroundCtx.beginPath(); this.backgroundCtx.moveTo(x, 0); this.backgroundCtx.lineTo(x, this.canvas.height); this.backgroundCtx.stroke(); }
        for (let y = 0; y <= this.canvas.height; y += GAME_CONFIG.TILE_SIZE) { this.backgroundCtx.beginPath(); this.backgroundCtx.moveTo(0, y); this.backgroundCtx.lineTo(this.canvas.width, y); this.backgroundCtx.stroke(); }
    }
    setupEventListeners() {
        this.keys = {};
        document.addEventListener('keydown', (e) => { 
            if (this.gameState === 'playing') { 
                if (e.code === 'Space' || e.code.startsWith('Arrow')) e.preventDefault(); 
                this.keys[e.code] = true; 
                if (e.code === 'Enter') this.togglePause(); 
                if (e.code === 'KeyR') this.showMainMenu();
            } 
        });
        document.addEventListener('keyup', (e) => { this.keys[e.code] = false; });
        document.getElementById('btnStartGame').addEventListener('click', () => {
            this.musicManager.start(); 
            this.sfxManager.start();
            this.instructionManager.start(true);
        });
        document.getElementById('btnShowInstructions').addEventListener('click', () => {
            this.instructionManager.start(false);
        });
        document.getElementById('btnMainMenuStart').addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        document.getElementById('btnEasy').addEventListener('click', () => this.startGame('easy'));
        document.getElementById('btnHard').addEventListener('click', () => this.startGame('hard'));
        document.getElementById('btnReset').addEventListener('click', ()=> this.showMainMenu());
        document.getElementById('btnMainMenu').addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        document.getElementById('btnPause').addEventListener('click', ()=> this.togglePause());
    }
    initInstructionCanvases() {
        const baseCanvas = document.getElementById('instr-bases');
        const baseCtx = baseCanvas.getContext('2d');
        spriteManager.get('base_health_hq', 80, 80, () => SVG_SPRITES.base).then(sprite => baseCtx.drawImage(sprite, 20, 20, 60, 60));
        spriteManager.get('base_enemy_hq', 80, 80, () => SVG_SPRITES.enemyBase).then(sprite => baseCtx.drawImage(sprite, 120, 20, 60, 60));
        const moveCanvas = document.getElementById('instr-movement');
        const moveCtx = moveCanvas.getContext('2d');
        spriteManager.get('player_tank_super', 40, 40, () => SVG_SPRITES.player).then(sprite => moveCtx.drawImage(sprite, 30, 30, 40, 40));
        moveCtx.fillStyle = 'white'; moveCtx.font = 'bold 16px Arial'; moveCtx.fillText('↑', 45, 20); moveCtx.fillText('←', 10, 55); moveCtx.fillText('→', 75, 55); moveCtx.fillText('↓', 45, 90);
        const puCanvas = document.getElementById('instr-powerups');
        const puCtx = puCanvas.getContext('2d');
        let p = new PowerUp(5,5,'star'); p.draw(puCtx);
        p = new PowerUp(55,5,'helmet'); p.draw(puCtx);
        p = new PowerUp(5,55,'timer'); p.draw(puCtx);
        p = new PowerUp(55,55,'bomb'); p.draw(puCtx);
        const normalCanvas = document.getElementById('instr-enemy-normal');
        spriteManager.get('enemy_new_normal', 38, 38, () => SVG_SPRITES.enemy.normal).then(sprite => normalCanvas.getContext('2d').drawImage(sprite, 31, 31, 38, 38));
        const vapeCanvas = document.getElementById('instr-enemy-vape');
        spriteManager.get('enemy_new_vape', 38, 38, () => SVG_SPRITES.enemy.vape).then(sprite => vapeCanvas.getContext('2d').drawImage(sprite, 31, 31, 38, 38));
        const toughCanvas = document.getElementById('instr-enemy-tough');
        spriteManager.get('enemy_new_tough', 38, 38, () => SVG_SPRITES.enemy.tough).then(sprite => toughCanvas.getContext('2d').drawImage(sprite, 31, 31, 38, 38));
        
        const kamikazeCanvas = document.getElementById('instr-enemy-kamikaze');
        spriteManager.get('enemy_new_kamikaze', 38, 38, () => SVG_SPRITES.enemy.kamikaze).then(sprite => kamikazeCanvas.getContext('2d').drawImage(sprite, 31, 31, 38, 38));

        const bossCanvas = document.getElementById('instr-boss');
        spriteManager.get('boss_cigar_super', 80, 80, () => SVG_SPRITES.boss).then(sprite => bossCanvas.getContext('2d').drawImage(sprite, 10, 10, 80, 80));
        
        const shieldCanvas = document.getElementById('instr-powerup-shield');
        const shieldCtx = shieldCanvas.getContext('2d');
        const shieldPowerup = new PowerUp(35, 35, 'shield');
        shieldPowerup.draw(shieldCtx);

    }
    startGame(difficulty) {
        this.difficulty = difficulty;
        this.levelData = difficulty === 'easy' ? LEVEL_DATA_EASY : LEVEL_DATA_HARD;
        document.getElementById('difficultyScreen').classList.add('hidden');
        this.hudElements.container.classList.remove('hidden');
        this.hudElements.playerBaseName.classList.remove('hidden');
        this.resetGame(true);
    }
    togglePause() { if (this.lives > 0 && (this.gameState === 'playing' || this.gameState === 'paused')) { this.paused = !this.paused; this.gameState = this.paused ? 'paused' : 'playing'; this.musicManager.toggleMusic(this.paused); document.getElementById('btnPause').textContent = this.paused ? 'Tiếp tục (Enter)' : 'Tạm dừng (Enter)'; } }
    
    createMap() {
        this.obstacles = [];
        const levelConf = this.levelData[Math.min(this.stage - 1, this.levelData.length - 1)];
        const mapLayout = levelConf.boss 
            ? BOSS_MAP_LAYOUT 
            : MAP_LAYOUTS[Math.min(this.stage - 1, MAP_LAYOUTS.length - 1)];
            
        for (let row = 0; row < mapLayout.length; row++) {
            for (let col = 0; col < mapLayout[row].length; col++) {
                const char = mapLayout[row][col];
                const x = col * GAME_CONFIG.TILE_SIZE, y = row * GAME_CONFIG.TILE_SIZE;
                switch(char) {
                    case 'B': this.obstacles.push(new Obstacle(x,y,'brick')); break;
                    case 'S': this.obstacles.push(new Obstacle(x,y,'steel')); break;
                    case 'T': this.obstacles.push(new Obstacle(x,y,'tree')); break;
                    case 'W': this.obstacles.push(new Obstacle(x,y,'water')); break;
                }
            }
        }
    }

    handleInput(dt) { const allObstacles = [...this.allies, ...this.enemies, ...this.obstacles, this.base, this.enemyBase, this.boss].filter(Boolean); if (this.keys['ArrowUp'] || this.keys['KeyW']) this.player.move('up', dt, this.canvas.width, this.canvas.height, allObstacles); else if (this.keys['ArrowDown'] || this.keys['KeyS']) this.player.move('down', dt, this.canvas.width, this.canvas.height, allObstacles); else if (this.keys['ArrowLeft'] || this.keys['KeyA']) this.player.move('left', dt, this.canvas.width, this.canvas.height, allObstacles); else if (this.keys['ArrowRight'] || this.keys['KeyD']) this.player.move('right', dt, this.canvas.width, this.canvas.height, allObstacles); if (this.keys['Space']) this.shoot(this.player, 'player'); }
    shoot(tank, owner) { const currentTime = Date.now(); if (owner === 'player' && currentTime - this.lastShotTime < GAME_CONFIG.PLAYER.SHOT_COOLDOWN) return; const bulletCount = tank.getBulletCount(); if (owner === 'player' && this.bullets.filter(b => b.owner === 'player').length >= 2 + bulletCount) return; this.sfxManager.playShoot(); const bulletSpawnDistance = 20; const centerX = tank.x + tank.width / 2; const centerY = tank.y + tank.height / 2; let bulletX, bulletY; for (let i = 0; i < bulletCount; i++) { const offset = (i - (bulletCount - 1) / 2) * 15; switch(tank.direction) { case 'up': bulletX = centerX - 4 + offset; bulletY = centerY - bulletSpawnDistance - 8; break; case 'down': bulletX = centerX - 4 + offset; bulletY = centerY + bulletSpawnDistance - 8; break; case 'left': bulletX = centerX - bulletSpawnDistance - 4; bulletY = centerY - 8 + offset; break; case 'right': bulletX = centerX + bulletSpawnDistance - 4; bulletY = centerY - 8 + offset; break; } this.bullets.push(new Bullet(bulletX, bulletY, tank.direction, owner, tank.getBulletSpeed())); this.effects.push(new Effect(bulletX + 4, bulletY + 8, 'muzzle')); } if (owner === 'player') this.lastShotTime = currentTime; }
    
    bossShoot(boss, pattern) {
        if (pattern === 'laser') {
            setTimeout(() => {
                this.sfxManager.playLaserFire();
                this.lasers.push(new Laser(boss, 'enemy'));
            }, 500);
            return;
        }
        this.sfxManager.playShoot();
        let bulletCount = 0;
        switch(pattern) { case 'singleShot': bulletCount = 1; break; case 'doubleShot': bulletCount = 2; break; case 'tripleShot': bulletCount = 3; break; }
        const centerX = boss.x + boss.width / 2;
        const centerY = boss.y + boss.height / 2;
        for (let i = 0; i < bulletCount; i++) {
            const offset = (i - (bulletCount - 1) / 2) * 20;
            let bulletX = centerX, bulletY = centerY;
            switch(boss.direction) {
                case 'up':    bulletX += offset; bulletY -= boss.height / 2; break;
                case 'down':  bulletX += offset; bulletY += boss.height / 2; break;
                case 'left':  bulletY += offset; bulletX -= boss.width / 2; break;
                case 'right': bulletY += offset; bulletX += boss.width / 2; break;
            }
            this.bullets.push(new Bullet(bulletX-4, bulletY-8, boss.direction, 'enemy', 500));
        }
    }

    spawnEnemy() { 
        if (this.enemiesToSpawn.length === 0 || this.enemies.length >= this.maxEnemiesOnScreen) return; 
        const shuffledSpawnPoints = [...this.enemySpawnPoints].sort(() => Math.random() - 0.5); 
        let validSpawnPoint = null; 
        for (const point of shuffledSpawnPoints) { 
            const spawnArea = { x: point.x, y: point.y, width: GAME_CONFIG.TILE_SIZE, height: GAME_CONFIG.TILE_SIZE }; 
            let isOccupied = this.player.checkCollision(spawnArea) || (this.base.active && this.base.checkCollision(spawnArea)) || (this.enemyBase && this.enemyBase.active && this.enemyBase.checkCollision(spawnArea)); 
            if (!isOccupied) { for (const tank of [...this.enemies, ...this.allies]) { if (tank.checkCollision(spawnArea)) { isOccupied = true; break; } } } 
            if (!isOccupied) { validSpawnPoint = point; break; } 
        } 
        if (validSpawnPoint) { 
            const type = this.enemiesToSpawn.pop(); 
            if (type === 'kamikaze') {
                this.enemies.push(new KamikazeEnemy(validSpawnPoint.x, validSpawnPoint.y));
            } else {
                this.enemies.push(new Enemy(validSpawnPoint.x, validSpawnPoint.y, type));
            }
        } 
    }
    spawnPowerUp(x, y) { const types = ['star', 'helmet', 'timer', 'bomb', 'shield']; const type = types[Math.floor(Math.random() * types.length)]; this.powerUps.push(new PowerUp(x, y, type)); }
    
    applyPowerUp(type) {
        this.sfxManager.playPowerUp();
        const randomFact = this.antiSmokingFacts[Math.floor(Math.random() * this.antiSmokingFacts.length)];
        let effectMessage = "";
        switch(type) {
            case 'star': if (this.player.levelUp()) effectMessage = "NÂNG CẤP XE TĂNG!"; else return; break;
            case 'helmet': this.player.isInvincible = true; this.player.invincibilityTimer = GAME_CONFIG.PLAYER.INVINCIBILITY_DURATION; effectMessage = "BẬT KHIÊN BẢO VỆ!"; break;
            case 'shield': this.player.isReflectShieldActive = true; this.player.reflectShieldTimer = GAME_CONFIG.PLAYER.REFLECT_SHIELD_DURATION; effectMessage = "KHIÊN PHẢN ĐẠN!"; break;
            case 'timer': this.enemiesFrozen = true; this.enemiesFrozenTimer = GAME_CONFIG.ENEMY.FROZEN_DURATION; effectMessage = "ĐÓNG BĂNG THỜI GIAN!"; break;
            case 'bomb': 
                this.triggerShake(15, 500);
                if (this.boss) { 
                    for(let i = 0; i < 5; i++) this.boss.hit();
                    this.createParticles(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2, 50, '#FF4500', 4);
                } 
                this.enemies.forEach(e => { 
                    this.createParticles(e.x + e.width / 2, e.y + e.height / 2, 30, '#FF4500', 4);
                    e.active = false; 
                }); 
                effectMessage = "THANH LỌC KHÔNG KHÍ!"; 
                break;
        }
        const fullMessage = `<h3>${effectMessage}</h3><p>${randomFact.text}</p>`;
        this.showNotification(fullMessage, randomFact.duration);
    }
    
    update(dt) {
        if (this.gameState !== 'playing') return;
        this.handleInput(dt);
        this.allies.forEach(ally => ally.update(dt, this));

        if (this.player.invincibilityTimer > 0) {
            this.player.invincibilityTimer -= dt;
            if (this.player.invincibilityTimer <= 0) this.player.isInvincible = false;
        }
        if (this.player.reflectShieldTimer > 0) {
            this.player.reflectShieldTimer -=dt;
            if(this.player.reflectShieldTimer <= 0) this.player.isReflectShieldActive = false;
        }

        if (this.enemiesFrozenTimer > 0) {
            this.enemiesFrozenTimer -= dt;
            if (this.enemiesFrozenTimer <= 0) this.enemiesFrozen = false;
        }
        this.bullets.forEach(bullet => bullet.update(dt, this.canvas.width, this.canvas.height));
        this.effects.forEach(e => e.update(dt));
        this.lasers.forEach(l => l.update(dt));
        this.particles.forEach(p => p.update(dt));

        if (this.boss) {
            const collidablesForBoss = [...this.obstacles, this.player, ...this.allies, this.base].filter(Boolean);
            this.boss.update(dt, this.canvas.width, this.canvas.height, collidablesForBoss, this);
        } else {
            const collidablesForEnemy = [...this.obstacles, this.player, ...this.allies, this.base, this.enemyBase, ...this.enemies].filter(Boolean);
            this.enemySpawnTimer += dt;
            if (this.enemySpawnTimer >= this.enemySpawnInterval) { this.spawnEnemy(); this.enemySpawnTimer = 0; }
            this.enemies.forEach(enemy => enemy.update(dt, this.canvas.width, this.canvas.height, collidablesForEnemy, this));
        }
        this.handleCollisions();
        if (this.player.active) {
            this.powerUps.forEach(p => { if (p.active && p.checkCollision(this.player)) { this.applyPowerUp(p.type); p.active = false; } });
        }
        
        this.bullets = this.bullets.filter(b => b.active);
        this.powerUps = this.powerUps.filter(p => p.active && (Date.now() - p.spawnTime < p.lifeSpan));
        this.obstacles = this.obstacles.filter(o => o.active);
        this.effects = this.effects.filter(e => e.active);
        this.enemies = this.enemies.filter(e => e.active);
        this.lasers = this.lasers.filter(l => l.active);
        this.particles = this.particles.filter(p => p.active);

        if (this.gameState === 'playing') {
            if (this.boss && !this.boss.active) {
                this.boss = null;
                setTimeout(() => this.gameWin(), 500);
            } else if (!this.boss && this.enemyBase && !this.enemyBase.active) {
                if (this.stage >= this.levelData.length) { this.gameWin(); } else { this.levelComplete(); }
            }
        }
    }

    handleCollisions() {
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const bullet = this.bullets[i];
            if (!bullet.active) continue;
            let hit = false;
            let hitObject = null;

            if (this.base.active && this.base.checkCollision(bullet)) {
                if (bullet.owner === 'enemy') { 
                    this.base.hit(); 
                    this.triggerShake(5, 200);
                    if (!this.base.active) this.gameOver("Căn Cứ Sức Khỏe đã bị phá hủy!"); 
                }
                hit = true;
                hitObject = this.base;
            } else if (!hit && this.enemyBase && this.enemyBase.active && this.enemyBase.checkCollision(bullet)) {
                 if (bullet.owner === 'player' || bullet.owner === 'ai') { 
                    this.enemyBase.hit();
                    this.triggerShake(5, 200);
                 }
                hit = true;
                hitObject = this.enemyBase;
            }
            if (!hit) {
                if (bullet.owner === 'player' || bullet.owner === 'ai') {
                    const targets = this.boss ? [this.boss, ...this.enemies] : this.enemies;
                    for (const target of targets) {
                        if (target.active && bullet.checkCollision(target)) {
                            target.hit();
                            this.addScore(target.enemyType || 'boss_hit');
                            if (!target.active) {
                                this.triggerShake(8, 250);
                                this.createParticles(target.x + target.width/2, target.y + target.height/2, 30, '#FFA500');
                                if(target instanceof Boss) this.addScore('boss_kill');
                                if (Math.random() < GAME_CONFIG.POWERUP.SPAWN_CHANCE_ON_ENEMY_KILL) this.spawnPowerUp(target.x, target.y);
                            }
                            hit = true;
                            hitObject = target;
                            break;
                        }
                    }
                } else { 
                    if (this.player.active && bullet.checkCollision(this.player)) {
                        if (this.player.isReflectShieldActive) {
                            bullet.owner = 'player';
                            const directions = ['up', 'down', 'left', 'right'];
                            const opposite = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
                            bullet.direction = opposite[bullet.direction];
                            // No 'hit' here, the bullet continues
                        } else if (!this.player.isInvincible) {
                            this.lives--;
                            this.triggerShake(10, 300);
                            if (this.lives <= 0) { this.gameOver("Lá phổi của bạn đã bị tổn thương!"); return; }
                            this.respawnPlayer();
                            hit = true;
                            hitObject = this.player;
                        }
                    }
                    if (!hit) {
                        for (const ally of this.allies) {
                             if (ally.active && bullet.checkCollision(ally)) {
                                ally.active = false;
                                this.triggerShake(8, 250);
                                this.createParticles(ally.x + ally.width/2, ally.y + ally.height/2, 20, '#8e2de2');
                                setTimeout(() => this.respawnAlly(ally), 5000);
                                hit = true;
                                hitObject = ally;
                                break;
                            }
                        }
                    }
                }
            }
            if (!hit) {
                for (const obstacle of this.obstacles) {
                    if (obstacle.active && obstacle.blocksBullets() && bullet.checkCollision(obstacle)) {
                        if (obstacle.type === 'steel') {
                            this.createParticles(bullet.x, bullet.y, 5, '#bdc3c7', 1.5); // Sparks for steel
                        }
                        if (obstacle.canDestroy() || (obstacle.type === 'steel' && (bullet.owner === 'player' || bullet.owner === 'ai') && this.player.canBreakSteel())) {
                            obstacle.active = false;
                            if (obstacle.type === 'brick') {
                                this.createParticles(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, 10, '#a05a2c', 2);
                                if(Math.random() < GAME_CONFIG.POWERUP.SPAWN_CHANCE_ON_BRICK_DESTROY) {
                                    this.spawnPowerUp(obstacle.x + GAME_CONFIG.TILE_SIZE / 4, obstacle.y + GAME_CONFIG.TILE_SIZE / 4);
                                }
                            }
                        }
                        hit = true;
                        hitObject = obstacle;
                        break;
                    }
                }
            }
            if (hit) {
                bullet.active = false;
                this.sfxManager.playExplosion();
            }
        }
        
        for (const laser of this.lasers) {
            if (!laser.isDamaging()) continue;
            if (!this.player.isInvincible && this.player.active && laser.checkCollision(this.player)) {
                this.lives--;
                this.triggerShake(10, 300);
                if (this.lives <= 0) { this.gameOver("Lá phổi của bạn đã bị tổn thương!"); return; }
                this.respawnPlayer();
            }
            for (const ally of this.allies) {
                if (ally.active && laser.checkCollision(ally)) {
                    ally.active = false;
                    this.triggerShake(8, 250);
                    this.createParticles(ally.x + ally.width/2, ally.y + ally.height/2, 20, '#8e2de2');
                    setTimeout(() => this.respawnAlly(ally), 5000);
                }
            }
        }
    }

    addScore(enemyType) {
        let points = 0;
        switch(enemyType) {
            case 'normal': points = GAME_CONFIG.SCORE.NORMAL; break;
            case 'vape': points = GAME_CONFIG.SCORE.VAPE; break;
            case 'tough': points = GAME_CONFIG.SCORE.TOUGH; break;
            case 'kamikaze': points = GAME_CONFIG.SCORE.KAMIKAZE; break;
            case 'boss_hit': points = GAME_CONFIG.SCORE.BOSS_HIT; break;
            case 'boss_kill': points = GAME_CONFIG.SCORE.BOSS_KILL; break;
        }
        this.score += points;
    }

    showNotification(htmlContent, duration) {
        if (this.notificationTimeout) clearTimeout(this.notificationTimeout);
        this.notificationBar.innerHTML = htmlContent;
        this.notificationBar.classList.add('visible');
        this.notificationTimeout = setTimeout(() => {
            this.notificationBar.classList.remove('visible');
        }, duration);
    }
    
    showMessage(htmlContent, duration = 3000) {
        const overlay = document.getElementById('messageOverlay');
        const messageBox = document.getElementById('messageBox');
        messageBox.innerHTML = htmlContent;
        overlay.classList.remove('hidden');
        if (duration !== -1) {
            setTimeout(() => { overlay.classList.add('hidden'); }, duration);
        }
    }
    
    gameOver(reason) {
        if (this.gameState === 'gameover') return;
        this.gameState = 'gameover';
        this.musicManager.stopMusic();
        this.sfxManager.playGameOver();
        this.updateHighScore();
        this.allies.forEach(ally => ally.active = false);
        this.hudElements.enemyBaseName.classList.add('hidden');
        this.hudElements.playerBaseName.classList.add('hidden');
        
        let buttonsHTML = `<button id="btnRestartFromOver">Chơi lại từ đầu</button>`;
        if (this.canContinue) {
            buttonsHTML = `<button id="btnContinue">Tiếp tục (Hồi sinh)</button>` + buttonsHTML;
        }

        const fullMessage = `
            <h2>THẤT BẠI</h2>
            <p style="margin-bottom: 10px;">${reason}</p>
            <p style="font-weight: bold;">Điểm của bạn: ${this.score}</p>
            <div class="overlay-buttons">${buttonsHTML}</div>`;
        this.showMessage(fullMessage, -1);

        if (this.canContinue) {
            document.getElementById('btnContinue').addEventListener('click', () => this.continueGame());
        }
        document.getElementById('btnRestartFromOver').addEventListener('click', () => this.showMainMenu());
    }
    
    gameWin() {
        if (this.gameState === 'win') return;
        this.gameState = 'win';
        this.musicManager.stopMusic();
        this.sfxManager.playLevelComplete();
        this.updateHighScore();
        this.hudElements.enemyBaseName.classList.add('hidden');
        this.hudElements.playerBaseName.classList.add('hidden');
        const message = `
            <h2>🎉 CHIẾN THẮNG! 🎉</h2>
            <p>Bạn đã hoàn thành chiến dịch bảo vệ lá phổi xanh!</p>
             <p style="font-weight: bold;">Điểm cuối cùng: ${this.score}</p>
            <div class="overlay-buttons">
                <button id="btnWinRestart">Chơi lại từ đầu</button>
            </div>
        `;
        this.showMessage(message, -1);
        document.getElementById('btnWinRestart').addEventListener('click', () => this.showMainMenu());
    }
    
    continueGame() {
        document.getElementById('messageOverlay').classList.add('hidden');
        this.canContinue = false;
        this.lives = 3;
        this.respawnPlayer();
        this.gameState = 'playing';
        this.paused = false;
        this.musicManager.startMusic();
    }
    
    levelComplete() {
        if (this.gameState === 'level_complete') return;
        this.gameState = 'level_complete';
        this.sfxManager.playLevelComplete();
        this.showMessage(`Hoàn thành màn ${this.stage}!<br>Sẵn sàng cho thử thách tiếp theo...`, 3000);
        setTimeout(() => this.nextLevel(), 3000);
    }
    
    nextLevel() { this.stage++; this.startLevel(); }
    
    startLevel() {
        this.player.x = this.playerSpawnX; this.player.y = this.playerSpawnY; this.player.direction = 'up';
        if (this.difficulty === 'easy') { this.allySpawnPoints = [ { x: this.playerSpawnX - GAME_CONFIG.TILE_SIZE * 3, y: this.playerSpawnY }, { x: this.playerSpawnX + GAME_CONFIG.TILE_SIZE * 3, y: this.playerSpawnY } ]; this.allies = this.allySpawnPoints.map((pos, index) => new AITank(pos.x, pos.y, index)); } else { this.allies = []; } 
        this.bullets = []; this.enemies = []; this.powerUps = []; this.effects = []; this.lasers = []; this.particles = [];
        this.base = new Base(9 * GAME_CONFIG.TILE_SIZE, 13 * GAME_CONFIG.TILE_SIZE);
        this.enemiesFrozen = false;
        this.enemiesFrozenTimer = 0;
        
        const levelConf = this.levelData[Math.min(this.stage - 1, this.levelData.length - 1)];
        if (levelConf.boss) {
            const maxHealth = this.difficulty === 'easy' ? GAME_CONFIG.ENEMY.BOSS.EASY_MAX_HEALTH : GAME_CONFIG.ENEMY.BOSS.MAX_HEALTH;
            this.boss = new Boss(this.canvas.width / 2 - GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE, maxHealth, this.difficulty);
            this.enemyBase = null;
            this.enemiesToSpawn = [];
            this.hudElements.enemyBaseName.classList.add('hidden');
        } else {
            this.boss = null;
            this.enemyBase = new EnemyBase(9 * GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
            this.enemiesToSpawn = [];
            for(let type in levelConf) { for(let i=0; i < levelConf[type]; i++) this.enemiesToSpawn.push(type); }
            this.enemiesToSpawn.sort(() => Math.random() - 0.5);
            this.hudElements.enemyBaseName.classList.remove('hidden');
        }
        
        this.createMap();
        this.showMessage(`MÀN ${this.stage}`, 2000);
        this.gameState = 'playing';
        this.paused = false;
    }

    updateHighScore() {
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('tankGameHighScore', this.highScore);
        }
    }

    showMainMenu() {
        this.gameState = 'menu';
        this.musicManager.stopMusic();
        document.getElementById('messageOverlay').classList.add('hidden');
        document.getElementById('game-wrapper').classList.add('hidden');
        this.hudElements.container.classList.add('hidden');
        document.getElementById('difficultyScreen').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
    }

    resetGame(isFullReset = false) {
        if (isFullReset) {
            this.canContinue = true;
            this.stage = 1;
            this.score = 0;
            this.highScore = localStorage.getItem('tankGameHighScore') || 0;
            this.levelData = this.difficulty === 'easy' ? LEVEL_DATA_EASY : LEVEL_DATA_HARD;
        }
        document.getElementById('messageOverlay').classList.add('hidden');
        this.lives = 3;
        this.paused = false;
        this.musicManager.startMusic();
        this.playerSpawnX = 9 * GAME_CONFIG.TILE_SIZE;
        this.playerSpawnY = 12 * GAME_CONFIG.TILE_SIZE;
        this.maxEnemiesOnScreen = GAME_CONFIG.ENEMY.MAX_ON_SCREEN;
        this.player = new Player(0, 0);
        this.lastShotTime = 0;
        this.enemySpawnTimer = 0;
        this.enemySpawnInterval = GAME_CONFIG.ENEMY.SPAWN_INTERVAL;
        this.enemySpawnPoints = [ { x: GAME_CONFIG.TILE_SIZE, y: GAME_CONFIG.TILE_SIZE }, { x: 9 * GAME_CONFIG.TILE_SIZE, y: GAME_CONFIG.TILE_SIZE }, { x: this.canvas.width - 2 * GAME_CONFIG.TILE_SIZE, y: GAME_CONFIG.TILE_SIZE } ];
        this.hudState = { lives: -1, level: -1, stage: -1, enemiesLeft: -1, bossHealth: -1, score: -1, highScore: -1 };
        this.lastTime = 0;
        this.startLevel();
    }

    respawnPlayer() { this.player.x = this.playerSpawnX; this.player.y = this.playerSpawnY; this.player.direction = 'up'; this.player.isInvincible = true; this.player.invincibilityTimer = GAME_CONFIG.PLAYER.RESPAWN_INVINCIBILITY; }
    respawnAlly(ally) { if (this.gameState !== 'playing') return; const spawnPoint = this.allySpawnPoints[ally.id]; ally.x = spawnPoint.x; ally.y = spawnPoint.y; ally.direction = 'up'; ally.active = true; }
    
    // --- Game Feel Methods ---
    triggerShake(intensity, duration) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
        this.shakeTimer = duration;
    }

    createParticles(x, y, count, color, speed = 2, size = 3, life = 0.5) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y, color, speed, size, life));
        }
    }
    
    draw(timestamp) {
        this.ctx.save(); 

        if (this.shakeTimer > 0) {
            const shakeX = (Math.random() - 0.5) * this.shakeIntensity * (this.shakeTimer / this.shakeDuration);
            const shakeY = (Math.random() - 0.5) * this.shakeIntensity * (this.shakeTimer / this.shakeDuration);
            this.ctx.translate(shakeX, shakeY);
        }

        this.ctx.drawImage(this.backgroundCanvas, 0, 0);
        if (this.gameState === 'menu' || this.gameState === 'instructions') {
            this.ctx.restore();
            return;
        }
        Obstacle.updateDynamicSprites(timestamp);
        if (this.base) this.base.draw(this.ctx, timestamp);
        if (this.enemyBase) this.enemyBase.draw(this.ctx, timestamp);
        this.obstacles.forEach(ob => { if (ob.type !== 'tree') ob.draw(this.ctx); });
        this.powerUps.forEach(p => p.draw(this.ctx));
        if (this.boss) this.boss.draw(this.ctx);
        this.enemies.forEach(e => e.draw(this.ctx));
        if (this.player.active) this.player.draw(this.ctx);
        this.allies.forEach(ally => ally.draw(this.ctx));
        this.bullets.forEach(b => b.draw(this.ctx));
        this.lasers.forEach(l => l.draw(this.ctx));
        this.obstacles.forEach(ob => { if (ob.type === 'tree') ob.draw(this.ctx); });
        this.effects.forEach(e => e.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));

        this.ctx.restore(); 
    }
    
    updateHUD() {
        if (this.hudState.lives !== this.lives) { this.hudElements.lives.textContent = this.lives; this.hudState.lives = this.lives; }
        if (this.hudState.level !== this.player.level) { this.hudElements.level.textContent = this.player.level; this.hudState.level = this.player.level; }
        if (this.hudState.stage !== this.stage) { this.hudElements.stage.textContent = this.stage; this.hudState.stage = this.stage; }
        if (this.hudState.score !== this.score) { this.hudElements.score.textContent = this.score; this.hudState.score = this.score; }
        if (this.hudState.highScore !== this.highScore) { this.hudElements.highScore.textContent = this.highScore; this.hudState.highScore = this.highScore; }
        
        if (this.boss) {
            this.hudElements.enemiesLeftContainer.style.display = 'none';
            this.hudElements.bossHealthContainer.style.display = 'block';
            const bossHealthPercent = (this.boss.health / this.boss.maxHealth) * 100;
            if (this.hudState.bossHealth !== bossHealthPercent) {
                this.hudElements.bossHealthFill.style.width = `${bossHealthPercent}%`;
                this.hudElements.bossHealthFill.style.backgroundPosition = `${100 - bossHealthPercent}% 0`;
                this.hudState.bossHealth = bossHealthPercent;
            }
        } else {
            this.hudElements.enemiesLeftContainer.style.display = 'block';
            this.hudElements.bossHealthContainer.style.display = 'none';
            const enemiesLeft = this.enemies.length + this.enemiesToSpawn.length;
            if (this.hudState.enemiesLeft !== enemiesLeft) {
                this.hudElements.enemiesLeft.textContent = enemiesLeft;
                this.hudState.enemiesLeft = enemiesLeft;
            }
        }
    }
    
    gameLoop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const deltaTime = Math.min(100, timestamp - this.lastTime);
        this.lastTime = timestamp;

        if (this.shakeTimer > 0) {
            this.shakeTimer -= deltaTime;
        }

        if(this.gameState === 'playing' && !this.paused) {
            this.update(deltaTime);
        }
        this.draw(timestamp);
        if (this.gameState === 'playing' || this.gameState === 'paused') {
            this.updateHUD();
        }
        requestAnimationFrame((ts) => this.gameLoop(ts));
    }
}

// Entry point of the game.
window.addEventListener('load', ()=> {
    const game = new Game();
});
</script>
</body>
</html>

