<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üé≤ ƒêo√°n s·ªë theo quy lu·∫≠t d√£y s·ªë - Phi√™n b·∫£n N√¢ng cao</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Quicksand&display=swap');
  /* Reset & base */
  * {
    box-sizing: border-box;
  }
  body {
    font-family: 'Quicksand', sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    margin: 0; padding: 0;
    min-height: 100vh;
    display: flex; flex-direction: column; align-items: center;
    transition: background-color 0.3s ease, color 0.3s ease;
  }
  :root {
    --accent: #f28ab2;
    --accent-dark: #d36b91;
    --bg-color: #fff0f6;
    --text-color: #4a3c4a;
    --bg-card: #fff9fb;
    --btn-bg: var(--accent);
    --btn-hover: var(--accent-dark);
    --success: #2e7d32;
    --fail: #c62828;
    --hint: #a98ba9;
  }
  [data-theme="dark"] {
    --bg-color: #1a1a1a;
    --text-color: #ddd;
    --bg-card: #2c2c2c;
    --btn-bg: #8b5e7d;
    --btn-hover: #6d4a5e;
    --hint: #aaa;
  }
  header {
    text-align: center;
    margin: 20px 15px 0 15px;
  }
  header h1 {
    font-weight: 700;
    margin-bottom: 0;
    color: var(--accent);
  }
  header p {
    font-style: italic;
    margin-top: 0;
    color: var(--hint);
  }
  main {
    background-color: var(--bg-card);
    padding: 25px 30px 35px 30px;
    margin: 20px 15px 30px 15px;
    border-radius: 15px;
    max-width: 500px;
    width: 95vw;
    box-shadow: 0 8px 20px rgba(0,0,0,0.1);
  }
  label {
    display: block;
    margin-top: 15px;
    font-weight: 600;
    color: var(--accent-dark);
  }
  select, input[type=number] {
    width: 100%;
    padding: 8px 12px;
    margin-top: 6px;
    font-size: 1rem;
    border-radius: 8px;
    border: 2px solid #e5c9d9;
    background-color: #fff;
    transition: border-color 0.3s ease;
  }
  select:focus, input[type=number]:focus {
    outline: none;
    border-color: var(--accent);
  }
  .sequence {
    font-size: 1.3rem;
    margin: 20px 0 10px 0;
    min-height: 40px;
    word-wrap: break-word;
    text-align: center;
    font-weight: 600;
    color: var(--accent-dark);
  }
  button {
    margin-top: 15px;
    width: 100%;
    background: var(--btn-bg);
    color: white;
    border: none;
    padding: 14px 0;
    font-size: 1.2rem;
    font-weight: 600;
    border-radius: 10px;
    cursor: pointer;
    transition: background 0.3s ease;
    user-select: none;
  }
  button:hover:not(:disabled) {
    background: var(--btn-hover);
  }
  button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
  .message {
    margin: 14px 0;
    font-weight: 600;
    min-height: 30px;
    text-align: center;
  }
  .message.success {
    color: var(--success);
  }
  .message.fail {
    color: var(--fail);
  }
  .hint {
    color: var(--hint);
    font-style: italic;
    min-height: 26px;
    text-align: center;
    margin-bottom: 15px;
  }
  .scoreboard {
    margin-top: 15px;
    font-weight: 700;
    color: var(--accent);
    display: flex;
    justify-content: space-between;
    font-size: 1.1rem;
  }
  .footer {
    margin-top: auto;
    padding: 15px 20px;
    color: var(--hint);
    font-size: 0.9rem;
  }
  .btn-inline {
    width: 48%;
    margin-top: 15px;
  }
  .darkmode-toggle {
    cursor: pointer;
    font-weight: 600;
    color: var(--accent);
    user-select: none;
    margin-top: 10px;
    text-align: center;
    text-decoration: underline;
  }
  .timer {
    margin-top: 10px;
    font-size: 1.1rem;
    font-weight: 700;
    text-align: center;
    color: var(--accent);
  }
  /* animation */
  .fadeIn {
    animation: fadeInAnim 0.5s ease forwards;
  }
  @keyframes fadeInAnim {
    from {opacity: 0;}
    to {opacity: 1;}
  }
  /* Confetti */
  canvas.confetti {
    position: fixed;
    pointer-events: none;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 9999;
  }
</style>
</head>
<body data-theme="light">

<header>
  <h1>üé≤ ƒêo√°n s·ªë theo quy lu·∫≠t d√£y s·ªë</h1>
  <p>Ch·ªçn ch·ªß ƒë·ªÅ, ƒë·ªô kh√≥, s·ªë c√¢u v√† luy·ªán t∆∞ duy s·ªë h·ªçc ƒë·ªânh cao!</p>
  <div class="darkmode-toggle" id="darkModeToggle">B·∫≠t ch·∫ø ƒë·ªô t·ªëi üåô</div>
</header>

<main>
  <label for="topicSelect">Ch·ªçn ch·ªß ƒë·ªÅ d√£y s·ªë:</label>
  <select id="topicSelect" aria-label="Ch·ªçn ch·ªß ƒë·ªÅ d√£y s·ªë">
    <option value="all">T·∫•t c·∫£</option>
    <option value="csc">C·∫•p s·ªë c·ªông</option>
    <option value="csn">C·∫•p s·ªë nh√¢n</option>
    <option value="fib">Fibonacci</option>
    <option value="square">B√¨nh ph∆∞∆°ng</option>
    <option value="cube">L·∫≠p ph∆∞∆°ng</option>
    <option value="triangle">Tam gi√°c</option>
    <option value="alt">Lu√¢n phi√™n</option>
  </select>

  <label for="difficultySelect">Ch·ªçn ƒë·ªô kh√≥:</label>
  <select id="difficultySelect" aria-label="Ch·ªçn ƒë·ªô kh√≥">
    <option value="easy">D·ªÖ</option>
    <option value="medium">Trung b√¨nh</option>
    <option value="hard">Kh√≥</option>
  </select>

  <label for="questionCountInput">S·ªë c√¢u h·ªèi:</label>
  <input type="number" id="questionCountInput" min="3" max="20" step="1" value="10" aria-label="S·ªë c√¢u h·ªèi" />

  <div class="sequence" id="sequenceDisplay" aria-live="polite" aria-atomic="true">Ch·ªçn c√†i ƒë·∫∑t v√† nh·∫•n B·∫Øt ƒë·∫ßu ƒë·ªÉ ch∆°i</div>

  <input type="number" id="answerInput" placeholder="Nh·∫≠p s·ªë ti·∫øp theo..." autocomplete="off" aria-label="Nh·∫≠p s·ªë ti·∫øp theo" disabled />

  <button id="submitBtn" disabled>X√°c nh·∫≠n</button>
  <button id="hintBtn" disabled>G·ª£i √Ω (-2 ƒëi·ªÉm)</button>
  <button id="nextBtn" style="display:none;">C√¢u ti·∫øp theo</button>

  <div class="message" id="message"></div>
  <div class="hint" id="hint"></div>

  <div class="scoreboard" aria-live="polite" aria-atomic="true">
    <div>ƒêi·ªÉm: <span id="score">0</span></div>
    <div>Combo: <span id="combo">0</span></div>
    <div>Th·ªùi gian: <span id="timer">--</span> gi√¢y</div>
  </div>

  <button id="startBtn" style="margin-top: 20px;">B·∫Øt ƒë·∫ßu ch∆°i</button>

  <div style="margin-top:25px;">
    <h3>B·∫£ng x·∫øp h·∫°ng (Top 5)</h3>
    <ol id="leaderboard"></ol>
  </div>
</main>

<canvas id="confettiCanvas" class="confetti"></canvas>

<div class="footer">
  <small>Ph√°t tri·ªÉn b·ªüi Th·∫ßy Nguy√™n & ChatGPT | Phi√™n b·∫£n N√¢ng cao 2025</small>
</div>

<script>
(() => {
  // --- Bi·∫øn to√†n c·ª•c ---
  const sequenceTypes = {
    csc: {
      name: "C·∫•p s·ªë c·ªông",
      generate: (length, difficulty) => {
        const baseMin = difficulty === "easy" ? 1 : difficulty === "medium" ? 10 : 20;
        const baseMax = difficulty === "easy" ? 10 : difficulty === "medium" ? 50 : 100;
        const dMax = difficulty === "easy" ? 5 : difficulty === "medium" ? 10 : 20;

        const a1 = randInt(baseMin, baseMax);
        const d = randInt(1, dMax);
        let seq = [];
        for(let i=0; i<length; i++) seq.push(a1 + i*d);
        return {seq, answer: a1 + length*d, hint: `D√£y s·ªë c·ªông d·∫ßn v·ªõi c√¥ng sai d = ${d}. C√¥ng th·ª©c: a‚Çô = a‚ÇÅ + (n-1)d`};
      }
    },
    csn: {
      name: "C·∫•p s·ªë nh√¢n",
      generate: (length, difficulty) => {
        const baseMin = 1;
        const baseMax = difficulty === "easy" ? 5 : difficulty === "medium" ? 10 : 15;
        const qMax = difficulty === "easy" ? 3 : difficulty === "medium" ? 5 : 7;

        const a1 = randInt(baseMin, baseMax);
        const q = randInt(2, qMax);
        let seq = [];
        for(let i=0; i<length; i++) seq.push(a1 * (q**i));
        return {seq, answer: a1 * (q**length), hint: `D√£y s·ªë nh√¢n d·∫ßn v·ªõi c√¥ng b·ªôi q = ${q}. C√¥ng th·ª©c: a‚Çô = a‚ÇÅ √ó q‚Åø‚Åª¬π`};
      }
    },
    fib: {
      name: "Fibonacci",
      generate: (length, difficulty) => {
        let seq = [0, 1];
        for(let i=2; i<length; i++) seq.push(seq[i-1] + seq[i-2]);
        return {seq: seq.slice(0,length), answer: seq[length-1] + seq[length-2], hint: `D√£y s·ªë Fibonacci: m·ªói s·ªë l√† t·ªïng 2 s·ªë li·ªÅn tr∆∞·ªõc. C√¥ng th·ª©c: F‚Çô = F‚Çô‚Çã‚ÇÅ + F‚Çô‚Çã‚ÇÇ`};
      }
    },
    square: {
      name: "B√¨nh ph∆∞∆°ng",
      generate: (length, difficulty) => {
        let seq = [];
        for(let i=1; i<=length; i++) seq.push(i*i);
        return {seq, answer: (length+1)**2, hint: `D√£y s·ªë b√¨nh ph∆∞∆°ng: a‚Çô = n¬≤`};
      }
    },
    cube: {
      name: "L·∫≠p ph∆∞∆°ng",
      generate: (length, difficulty) => {
        let seq = [];
        for(let i=1; i<=length; i++) seq.push(i*i*i);
        return {seq, answer: (length+1)**3, hint: `D√£y s·ªë l·∫≠p ph∆∞∆°ng: a‚Çô = n¬≥`};
      }
    },
    triangle: {
      name: "Tam gi√°c",
      generate: (length, difficulty) => {
        let seq = [];
        for(let i=1; i<=length; i++) seq.push(i*(i+1)/2);
        return {seq, answer: (length+1)*(length+2)/2, hint: `D√£y s·ªë tam gi√°c: a‚Çô = n(n+1)/2`};
      }
    },
    alt: {
      name: "Lu√¢n phi√™n",
      generate: (length, difficulty) => {
        // Ch·ªçn s·ªë c∆° s·ªü tuy·ªát ƒë·ªëi t√πy ƒë·ªô kh√≥
        const baseMin = difficulty === "easy" ? 1 : difficulty === "medium" ? 2 : 3;
        const a1_abs = randInt(baseMin, baseMin + 2);

        // Ch·ªçn d·∫•u ph·∫ßn t·ª≠ ƒë·∫ßu: +1 ho·∫∑c -1 (ng·∫´u nhi√™n)
        const firstSign = Math.random() < 0.5 ? 1 : -1;

        // T·∫°o d√£y lu√¢n phi√™n d·∫•u, s·ªë tƒÉng d·∫ßn theo b·∫≠c
        let seq = [];
        for(let i=0; i<length; i++) {
          // d·∫•u ph·∫ßn t·ª≠ th·ª© i = firstSign * (-1)^i
          let sign = firstSign * ((i % 2 === 0) ? 1 : -1);
          seq.push(sign * a1_abs * (i+1));
        }

        // T√≠nh s·ªë ti·∫øp theo
        let nextSign = firstSign * ((length % 2 === 0) ? 1 : -1);
        let answer = nextSign * a1_abs * (length + 1);

        return {
          seq,
          answer,
          hint: `D√£y lu√¢n phi√™n d·∫•u b·∫Øt ƒë·∫ßu t·ª´ ${seq[0]}. Quy lu·∫≠t: d·∫•u xen k·∫Ω ¬±, a‚Çô = (-1)^{n+1} √ó n √ó ${a1_abs} (v·ªõi d·∫•u ph·∫ßn t·ª≠ ƒë·∫ßu l√† ${seq[0]})`
        };
      }
    }
  };

  // DOM
  const sequenceDisplay = document.getElementById('sequenceDisplay');
  const answerInput = document.getElementById('answerInput');
  const submitBtn = document.getElementById('submitBtn');
  const messageEl = document.getElementById('message');
  const hintBtn = document.getElementById('hintBtn');
  const hintEl = document.getElementById('hint');
  const nextBtn = document.getElementById('nextBtn');
  const topicSelect = document.getElementById('topicSelect');
  const difficultySelect = document.getElementById('difficultySelect');
  const questionCountInput = document.getElementById('questionCountInput');
  const scoreEl = document.getElementById('score');
  const comboEl = document.getElementById('combo');
  const timerEl = document.getElementById('timer');
  const startBtn = document.getElementById('startBtn');
  const leaderboardEl = document.getElementById('leaderboard');
  const darkModeToggle = document.getElementById('darkModeToggle');
  const confettiCanvas = document.getElementById('confettiCanvas');

  // Bi·∫øn tr·∫°ng th√°i game
  let currentSeq = [];
  let currentAnswer = null;
  let currentHint = "";
  let currentTopic = null;
  let currentDifficulty = null;
  let currentQuestionIndex = 0;
  let totalQuestions = 10;
  let score = 0;
  let combo = 0;
  let usedHints = 0;
  let questions = [];
  let timerInterval = null;
  let timePerQuestion = 20;
  let timeLeft = timePerQuestion;

  // Utility
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Hi·ªÉn th·ªã chu·ªói d√£y s·ªë
  function showSequence(seq) {
    sequenceDisplay.textContent = seq.join(', ');
  }

  // Kh·ªüi t·∫°o danh s√°ch c√¢u h·ªèi
  function generateQuestions() {
    questions = [];
    const topicVal = topicSelect.value;
    currentDifficulty = difficultySelect.value;
    totalQuestions = Number(questionCountInput.value);

    // N·∫øu ch·ªçn t·∫•t c·∫£ th√¨ random c√°c ch·ªß ƒë·ªÅ
    const topicsList = topicVal === 'all' ? Object.keys(sequenceTypes) : [topicVal];

    for(let i=0; i<totalQuestions; i++) {
      const topicKey = topicsList[randInt(0, topicsList.length - 1)];
      const gen = sequenceTypes[topicKey].generate(6, currentDifficulty); // 6 s·ªë
      questions.push({
        topic: topicKey,
        seq: gen.seq,
        answer: gen.answer,
        hint: gen.hint
      });
    }
  }

  // C·∫≠p nh·∫≠t giao di·ªán c√¢u h·ªèi hi·ªán t·∫°i
  function updateQuestionUI() {
    const q = questions[currentQuestionIndex];
    currentSeq = q.seq;
    currentAnswer = q.answer;
    currentHint = q.hint;
    showSequence(currentSeq);
    answerInput.value = '';
    messageEl.textContent = '';
    hintEl.textContent = '';
    usedHints = 0;
    hintBtn.disabled = false;
    submitBtn.disabled = false;
    answerInput.disabled = false;
    nextBtn.style.display = 'none';
    answerInput.focus();
    resetTimer();
  }

  // X·ª≠ l√Ω khi b·∫•m x√°c nh·∫≠n
  function onSubmit() {
    const userAns = answerInput.value.trim();
    if(userAns === '') {
      messageEl.textContent = 'Vui l√≤ng nh·∫≠p c√¢u tr·∫£ l·ªùi!';
      messageEl.className = 'message fail';
      return;
    }
    const userNum = Number(userAns);
    if(Number.isNaN(userNum)) {
      messageEl.textContent = 'C√¢u tr·∫£ l·ªùi ph·∫£i l√† s·ªë h·ª£p l·ªá!';
      messageEl.className = 'message fail';
      return;
    }
    // So s√°nh k·∫øt qu·∫£
    if(userNum === currentAnswer) {
      messageEl.textContent = 'üéâ ƒê√∫ng r·ªìi! B·∫°n gi·ªèi qu√°!';
      messageEl.className = 'message success fadeIn';
      score += 10 - 2*usedHints + combo * 2; // ƒëi·ªÉm th∆∞·ªüng combo
      combo++;
      updateScoreboard();
      nextBtn.style.display = 'block';
      submitBtn.disabled = true;
      answerInput.disabled = true;
      hintBtn.disabled = true;
      startConfetti();
    } else {
      messageEl.textContent = `‚ùå Sai r·ªìi! ƒê√°p √°n ƒë√∫ng l√† ${currentAnswer}`;
      messageEl.className = 'message fail fadeIn';
      combo = 0;
      updateScoreboard();
    }
  }

  // C·∫≠p nh·∫≠t ƒëi·ªÉm, combo hi·ªÉn th·ªã
  function updateScoreboard() {
    scoreEl.textContent = score < 0 ? 0 : score;
    comboEl.textContent = combo;
  }

  // X·ª≠ l√Ω g·ª£i √Ω
  function onHint() {
    if(usedHints >= 1) return; // Ch·ªâ cho 1 hint m·ªói c√¢u
    hintEl.textContent = currentHint;
    usedHints++;
    score -= 2;
    if(score < 0) score = 0;
    updateScoreboard();
    hintBtn.disabled = true;
  }

  // B·∫Øt ƒë·∫ßu c√¢u ti·∫øp theo
  function onNext() {
    currentQuestionIndex++;
    if(currentQuestionIndex >= totalQuestions) {
      endGame();
      return;
    }
    updateQuestionUI();
  }

  // B·∫Øt ƒë·∫ßu ch∆°i
  function startGame() {
    score = 0;
    combo = 0;
    currentQuestionIndex = 0;
    generateQuestions();
    updateScoreboard();
    updateQuestionUI();
    startBtn.disabled = true;
    hintBtn.disabled = false;
    submitBtn.disabled = false;
    answerInput.disabled = false;
    answerInput.focus();
    messageEl.textContent = '';
    hintEl.textContent = '';
    nextBtn.style.display = 'none';
    startTimer();
  }

  // K·∫øt th√∫c game
  function endGame() {
    messageEl.textContent = `üèÜ K·∫øt th√∫c! ƒêi·ªÉm c·ªßa b·∫°n: ${score} ƒëi·ªÉm, Combo cao nh·∫•t: ${combo}`;
    messageEl.className = 'message success';
    sequenceDisplay.textContent = 'B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√¢u h·ªèi!';
    answerInput.disabled = true;
    submitBtn.disabled = true;
    hintBtn.disabled = true;
    nextBtn.style.display = 'none';
    startBtn.disabled = false;
    stopTimer();
    saveLeaderboard(score);
    renderLeaderboard();
  }

  // X·ª≠ l√Ω chuy·ªÉn ƒë·ªïi ch·∫ø ƒë·ªô s√°ng/t·ªëi
  function toggleDarkMode() {
    const body = document.body;
    const currentTheme = body.getAttribute('data-theme');
    if(currentTheme === 'light') {
      body.setAttribute('data-theme', 'dark');
      darkModeToggle.textContent = 'T·∫Øt ch·∫ø ƒë·ªô t·ªëi ‚òÄÔ∏è';
    } else {
      body.setAttribute('data-theme', 'light');
      darkModeToggle.textContent = 'B·∫≠t ch·∫ø ƒë·ªô t·ªëi üåô';
    }
  }

  // Timer c√¢u h·ªèi
  function startTimer() {
    timeLeft = timePerQuestion;
    timerEl.textContent = timeLeft;
    stopTimer();
    timerInterval = setInterval(() => {
      timeLeft--;
      timerEl.textContent = timeLeft;
      if(timeLeft <= 0) {
        clearInterval(timerInterval);
        messageEl.textContent = `‚è∞ H·∫øt gi·ªù! ƒê√°p √°n ƒë√∫ng l√† ${currentAnswer}`;
        messageEl.className = 'message fail fadeIn';
        combo = 0;
        updateScoreboard();
        submitBtn.disabled = true;
        answerInput.disabled = true;
        hintBtn.disabled = true;
        nextBtn.style.display = 'block';
      }
    }, 1000);
  }
  function resetTimer() {
    stopTimer();
    timeLeft = timePerQuestion;
    timerEl.textContent = timeLeft;
    startTimer();
  }
  function stopTimer() {
    if(timerInterval) clearInterval(timerInterval);
  }

  // L∆∞u leaderboard v√†o localStorage
  function saveLeaderboard(score) {
    if(score <= 0) return;
    let leaderboard = JSON.parse(localStorage.getItem('sequence_leaderboard') || '[]');
    leaderboard.push({score, date: new Date().toLocaleString()});
    leaderboard.sort((a,b) => b.score - a.score);
    if(leaderboard.length > 5) leaderboard = leaderboard.slice(0,5);
    localStorage.setItem('sequence_leaderboard', JSON.stringify(leaderboard));
  }
  // Hi·ªÉn th·ªã leaderboard
  function renderLeaderboard() {
    let leaderboard = JSON.parse(localStorage.getItem('sequence_leaderboard') || '[]');
    leaderboardEl.innerHTML = '';
    if(leaderboard.length === 0) {
      leaderboardEl.innerHTML = '<li>Ch∆∞a c√≥ ƒëi·ªÉm n√†o.</li>';
      return;
    }
    leaderboard.forEach(entry => {
      let li = document.createElement('li');
      li.textContent = `${entry.score} ƒëi·ªÉm - ${entry.date}`;
      leaderboardEl.appendChild(li);
    });
  }

  // Confetti (ƒë∆°n gi·∫£n)
  function startConfetti() {
    if(!confettiCanvas) return;
    const ctx = confettiCanvas.getContext('2d');
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
    let confettis = [];
    for(let i=0; i<100; i++) {
      confettis.push({
        x: Math.random()*confettiCanvas.width,
        y: Math.random()*confettiCanvas.height - confettiCanvas.height,
        size: randInt(5, 10),
        speedY: randInt(2,5),
        color: `hsl(${randInt(0,360)}, 70%, 60%)`,
        tilt: Math.random() * 15,
        tiltSpeed: (Math.random() * 0.1) + 0.05
      });
    }
    let frames = 0;
    function draw() {
      ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
      confettis.forEach(c => {
        c.y += c.speedY;
        c.tilt += c.tiltSpeed;
        if(c.y > confettiCanvas.height) {
          c.y = -c.size;
          c.x = Math.random()*confettiCanvas.width;
        }
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.moveTo(c.x + c.tilt, c.y);
        ctx.lineTo(c.x + c.tilt + c.size/2, c.y + c.size);
        ctx.lineTo(c.x + c.tilt - c.size/2, c.y + c.size);
        ctx.closePath();
        ctx.fill();
      });
      frames++;
      if(frames > 200) {
        ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
        return; // d·ª´ng sau 200 frames
      }
      requestAnimationFrame(draw);
    }
    draw();
  }

  // Event listeners
  submitBtn.addEventListener('click', onSubmit);
  hintBtn.addEventListener('click', onHint);
  nextBtn.addEventListener('click', onNext);
  startBtn.addEventListener('click', startGame);
  darkModeToggle.addEventListener('click', toggleDarkMode);

  // Enter key submit
  answerInput.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' && !submitBtn.disabled) {
      onSubmit();
    }
  });

  // Kh·ªüi ƒë·ªông render leaderboard l√∫c ƒë·∫ßu
  renderLeaderboard();

  // Init
  sequenceDisplay.textContent = 'Ch·ªçn c√†i ƒë·∫∑t v√† nh·∫•n B·∫Øt ƒë·∫ßu ƒë·ªÉ ch∆°i';
})();
</script>

</body>
</html>
