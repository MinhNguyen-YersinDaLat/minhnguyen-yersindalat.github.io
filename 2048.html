<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>2048 — Clean & Centered</title>
<style>
  :root{
    --bg:#f4f4f3;
    --card:#ffffff;
    --muted:#8b8177;
    --accent:#06b6d4;
    --gap:12px;
    --cols:4;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#222;display:flex;align-items:center;justify-content:center;height:100vh}
  .container{width:min(520px,96vw);padding:18px;background:transparent}
  .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h1{font-size:20px;margin:0}
  .scorebox{display:flex;gap:10px}
  .score{background:var(--card);padding:8px 12px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.06);text-align:center}
  .score .label{font-size:12px;color:var(--muted)}
  .score .value{font-weight:800;font-size:18px}
  /* board card */
  .board-card{background:var(--card);padding:16px;border-radius:12px;box-shadow:0 12px 36px rgba(0,0,0,0.06)}
  .board-outer{width:100%;display:flex;flex-direction:column;align-items:center;gap:12px}
  /* grid background */
  .grid-bg{width:100%;aspect-ratio:1/1;max-width:420px;background:linear-gradient(180deg,rgba(0,0,0,0.02),rgba(0,0,0,0.01));border-radius:10px;padding:var(--gap);position:relative;overflow:hidden}
  .cells{display:grid;grid-template-columns:repeat(var(--cols),1fr);gap:var(--gap);width:100%;height:100%}
  .cell{background:rgba(0,0,0,0.04);border-radius:8px;display:flex;align-items:center;justify-content:center;color:rgba(0,0,0,0.12);font-weight:800}
  /* absolute tiles layer */
  .tiles{position:absolute;left:var(--gap);top:var(--gap);right:var(--gap);bottom:var(--gap);pointer-events:none}
  .tile{position:absolute;display:flex;align-items:center;justify-content:center;border-radius:8px;font-weight:800;transition:transform 150ms cubic-bezier(.2,.8,.2,1), left 150ms, top 150ms, background 120ms, color 120ms, width 150ms, height 150ms;box-shadow:0 6px 18px rgba(2,6,23,0.12)}
  .num{font-size:28px}
  .tile.new{animation:pop .16s ease}
  @keyframes pop{0%{transform:scale(.3)}60%{transform:scale(1.06)}100%{transform:scale(1)}}
  /* colors */
  .v2{background:#eee4da;color:#776e65}.v4{background:#ede0c8;color:#776e65}.v8{background:#f2b179;color:#f9f6f2}.v16{background:#f59563;color:#f9f6f2}
  .v32{background:#f67c5f;color:#f9f6f2}.v64{background:#f65e3b;color:#f9f6f2}.v128{background:#edcf72;color:#f9f6f2}.v256{background:#edcc61;color:#f9f6f2}
  .v512{background:#edc850;color:#f9f6f2}.v1024{background:#edc53f;color:#f9f6f2}.v2048{background:#edc22e;color:#f9f6f2}
  /* footer */
  .controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
  .btn{background:linear-gradient(90deg,#f6d365,#fda085);border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700;color:#231815}
  .small{font-size:13px;color:var(--muted);text-align:center;margin-top:8px}
  /* responsive: smaller tiles on small screens */
  @media (max-width:420px){
    :root{--gap:10px}
    .num{font-size:22px}
  }
</style>
</head>
<body>
  <div class="container" id="app">
    <div class="header">
      <div>
        <h1>2048 — Clean</h1>
        <div class="small">Bảng căn giữa, ô gọn trong khung — Open & Play</div>
      </div>
      <div class="scorebox">
        <div class="score"><div class="label">Score</div><div id="score" class="value">0</div></div>
        <div class="score"><div class="label">Best</div><div id="best" class="value">0</div></div>
      </div>
    </div>

    <div class="board-card">
      <div class="board-outer">
        <div id="gridBg" class="grid-bg" role="application" aria-label="Game board">
          <div id="cells" class="cells" style="--cols:4"></div>
          <div id="tiles" class="tiles"></div>
        </div>

        <div class="controls">
          <button id="new" class="btn">New Game</button>
          <button id="undo" class="btn" style="background:#eaeefb;color:#08306b">Undo</button>
          <button id="hint" class="btn" style="background:#dff6f0;color:#064e3b">Hint</button>
        </div>

        <div class="small">Phím: mũi tên / W A S D — Vuốt trên điện thoại</div>
      </div>
    </div>
  </div>

<script>
/* Simple, robust 2048 with clean UI */
(() => {
  const SIZE = 4;
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 12;
  const gridBg = document.getElementById('gridBg');
  const cellsEl = document.getElementById('cells');
  const tilesEl = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const newBtn = document.getElementById('new');
  const undoBtn = document.getElementById('undo');
  const hintBtn = document.getElementById('hint');

  let board = [];
  let score = 0;
  let best = parseInt(localStorage.getItem('2048_best')||'0',10) || 0;
  let prev = null; // simple 1-step undo

  bestEl.textContent = best;

  // compute tile size based on gridBg inner area
  function getTileMetrics(){
    const rect = gridBg.getBoundingClientRect();
    const inner = rect.width - gap*2;
    const tileSize = Math.floor((inner - (SIZE-1)*gap) / SIZE);
    return {tileSize, inner};
  }

  // UI: create background cells
  function createCells(){
    cellsEl.innerHTML = '';
    cellsEl.style.setProperty('--cols', SIZE);
    for(let i=0;i<SIZE*SIZE;i++){
      const d = document.createElement('div');
      d.className = 'cell';
      cellsEl.appendChild(d);
    }
  }

  // game helpers
  function emptyList(){
    const out = [];
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(board[r][c]===0) out.push([r,c]);
    return out;
  }
  function addRandom(){
    const empties = emptyList();
    if(empties.length===0) return false;
    const [r,c] = empties[Math.floor(Math.random()*empties.length)];
    board[r][c] = Math.random()<0.9?2:4;
    return {r,c, v:board[r][c]};
  }

  // render tiles absolute
  function renderTiles(){
    const {tileSize, inner} = getTileMetrics();
    tilesEl.innerHTML = '';
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const v = board[r][c];
        if(!v) continue;
        const t = document.createElement('div');
        t.className = 'tile v' + v + ' new';
        t.style.width = tileSize + 'px';
        t.style.height = tileSize + 'px';
        t.style.left = (c*(tileSize + gap)) + 'px';
        t.style.top = (r*(tileSize + gap)) + 'px';
        t.innerHTML = `<div class="num">${v}</div>`;
        tilesEl.appendChild(t);
      }
    }
    // remove "new" class after animation
    setTimeout(()=>{ document.querySelectorAll('.tile.new').forEach(x=>x.classList.remove('new')); }, 220);
    scoreEl.textContent = score;
    bestEl.textContent = best;
  }

  // move logic (left compress)
  function compressLeft(row){
    const arr = row.filter(x=>x!==0);
    let moved=false;
    for(let i=0;i<arr.length-1;i++){
      if(arr[i]===arr[i+1]){
        arr[i] *= 2;
        score += arr[i];
        arr[i+1] = 0;
        if(score > best){ best = score; localStorage.setItem('2048_best', best); }
        moved = true;
      }
    }
    const newRow = arr.filter(x=>x!==0);
    while(newRow.length < SIZE) newRow.push(0);
    if(newRow.join(',') !== row.join(',')) moved = true;
    return {newRow, moved};
  }

  function moveLeft(){
    saveUndo();
    let moved=false;
    for(let r=0;r<SIZE;r++){
      const {newRow, moved:mv} = compressLeft(board[r]);
      board[r] = newRow;
      if(mv) moved=true;
    }
    if(moved) finalizeMove();
    else undoLastSave();
  }
  function moveRight(){
    saveUndo();
    let moved=false;
    for(let r=0;r<SIZE;r++){
      const rev = board[r].slice().reverse();
      const {newRow, moved:mv} = compressLeft(rev);
      board[r] = newRow.reverse();
      if(mv) moved=true;
    }
    if(moved) finalizeMove(); else undoLastSave();
  }
  function moveUp(){
    saveUndo();
    let moved=false;
    for(let c=0;c<SIZE;c++){
      const col = [];
      for(let r=0;r<SIZE;r++) col.push(board[r][c]);
      const {newRow, moved:mv} = compressLeft(col);
      for(let r=0;r<SIZE;r++) board[r][c] = newRow[r];
      if(mv) moved=true;
    }
    if(moved) finalizeMove(); else undoLastSave();
  }
  function moveDown(){
    saveUndo();
    let moved=false;
    for(let c=0;c<SIZE;c++){
      const col = [];
      for(let r=0;r<SIZE;r++) col.push(board[r][c]);
      const rev = col.slice().reverse();
      const {newRow, moved:mv} = compressLeft(rev);
      const newCol = newRow.reverse();
      for(let r=0;r<SIZE;r++) board[r][c] = newCol[r];
      if(mv) moved=true;
    }
    if(moved) finalizeMove(); else undoLastSave();
  }

  function finalizeMove(){
    addRandom();
    renderTiles();
    checkEnd();
  }

  // undo (one-step)
  function saveUndo(){
    prev = {board: board.map(r=>r.slice()), score};
  }
  function undoLastSave(){ prev = null; }
  function doUndo(){
    if(!prev) { showTemp('Nothing to undo'); return; }
    board = prev.board.map(r=>r.slice());
    score = prev.score;
    prev = null;
    renderTiles();
    showTemp('Undone');
  }

  // small helper toast
  let toastTimer = null;
  function showTemp(msg, t=1200){
    const el = document.getElementById('app').querySelector('.small') || document.body;
    // use title bar small area: temporarily change text
    const small = document.querySelector('.small');
    const prev = small.textContent;
    small.textContent = msg;
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{ small.textContent = prev; }, t);
  }

  // check win/lose
  function canMove(){
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(board[r][c]===0) return true;
        if(c+1<SIZE && board[r][c]===board[r][c+1]) return true;
        if(r+1<SIZE && board[r][c]===board[r+1][c]) return true;
      }
    }
    return false;
  }
  function checkEnd(){
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(board[r][c]===2048){
      showTemp('You reached 2048 🎉', 2000);
      return;
    }
    if(!canMove()){
      showTemp('Game Over', 2000);
    }
  }

  // AI hint: quick try each move, pick that increases empties
  function hint(){
    const dirs = ['left','right','up','down'];
    let bestScore=-Infinity, bestDir=null;
    for(const d of dirs){
      const {moved, newBoard, gained} = simulateMove(board,d);
      if(!moved) continue;
      const empties = newBoard.flat().filter(x=>x===0).length;
      const maxT = Math.max(...newBoard.flat());
      const heur = empties*2 + Math.log2(maxT||2) + gained*0.5;
      if(heur > bestScore){ bestScore=heur; bestDir=d; }
    }
    if(bestDir) showTemp('Hint: ' + bestDir.toUpperCase(), 1400);
    else showTemp('No valid move', 1000);
  }
  function simulateMove(bd, dir){
    const b = bd.map(r=>r.slice());
    let moved=false, gained=0;
    const slide = (row)=>{
      const arr = row.filter(x=>x!==0);
      for(let i=0;i<arr.length-1;i++){
        if(arr[i]===arr[i+1]){ arr[i]*=2; gained+=arr[i]; arr[i+1]=0; }
      }
      const nr = arr.filter(x=>x!==0);
      while(nr.length < SIZE) nr.push(0);
      if(nr.join(',') !== row.join(',')) moved=true;
      return nr;
    };
    if(dir==='left'){
      for(let r=0;r<SIZE;r++) b[r]=slide(b[r]);
    } else if(dir==='right'){
      for(let r=0;r<SIZE;r++){ b[r]=slide(b[r].slice().reverse()).reverse(); }
    } else if(dir==='up'){
      for(let c=0;c<SIZE;c++){
        const col=[]; for(let r=0;r<SIZE;r++) col.push(b[r][c]);
        const nr = slide(col);
        for(let r=0;r<SIZE;r++) b[r][c]=nr[r];
      }
    } else {
      for(let c=0;c<SIZE;c++){
        const col=[]; for(let r=0;r<SIZE;r++) col.push(b[r][c]);
        const nr = slide(col.reverse()).reverse();
        for(let r=0;r<SIZE;r++) b[r][c]=nr[r];
      }
    }
    return {moved, newBoard:b, gained};
  }

  // input handlers
  window.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft' || e.key==='a') moveLeft();
    else if(e.key==='ArrowRight' || e.key==='d') moveRight();
    else if(e.key==='ArrowUp' || e.key==='w') moveUp();
    else if(e.key==='ArrowDown' || e.key==='s') moveDown();
    renderTiles();
  });
  let sx=0, sy=0;
  window.addEventListener('touchstart', e=>{ const t=e.touches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
  window.addEventListener('touchend', e=>{ const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy; if(Math.abs(dx)>Math.abs(dy) && Math.abs(dx)>20){ if(dx>0) moveRight(); else moveLeft(); } else if(Math.abs(dy)>20){ if(dy>0) moveDown(); else moveUp(); } renderTiles(); }, {passive:true});

  // controls
  newBtn.addEventListener('click', ()=>{ init(); showTemp('New Game'); });
  undoBtn.addEventListener('click', ()=>{ doUndo(); });
  hintBtn.addEventListener('click', ()=>{ hint(); });

  // init
  function init(){
    board = Array.from({length:SIZE}, ()=>Array(SIZE).fill(0));
    score = 0; prev = null;
    addRandom(); addRandom();
    renderTiles();
    // ensure grid cells exist for layout
    createCells();
  }

  // make sure grid is created first (cells size adapt)
  createCells();
  init();
  // update best display
  bestEl.textContent = best;

  // expose for debug (optional)
  window._2048 = {board, reset: init};
})();
</script>
</body>
</html>
