<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C√¥ng c·ª• tr√≠ch xu·∫•t Th·ªùi kh√≥a bi·ªÉu - Th·∫ßy Nguy√™n</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #ff9a56 0%, #ff6b35 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff7b54 0%, #ff6347 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .step {
            margin-bottom: 30px;
            padding: 25px;
            border: 2px solid #e1e8ed;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .step:hover {
            border-color: #ff7b54;
            box-shadow: 0 5px 15px rgba(255, 123, 84, 0.1);
        }

        .step-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .step-number {
            background: #ff7b54;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-weight: bold;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            background: linear-gradient(135deg, #ff9a56 0%, #ff6b35 100%);
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            transition: all 0.3s ease;
            border: none;
            font-size: 1rem;
            font-weight: 500;
        }

        .file-input-wrapper:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 123, 84, 0.4);
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        select, button {
            padding: 12px 20px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
            cursor: pointer;
        }

        select:focus, button:focus {
            outline: none;
            border-color: #ff7b54;
            box-shadow: 0 0 0 3px rgba(255, 123, 84, 0.1);
        }

        button {
            background: linear-gradient(135deg, #ff7b54 0%, #ff6347 100%);
            color: white;
            border: none;
            font-weight: 500;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 123, 84, 0.4);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .export-buttons button {
            margin: 0;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .schedule-table th {
            background: linear-gradient(135deg, #ff7b54 0%, #ff6347 100%);
            color: white;
            padding: 15px 10px;
            text-align: center;
            font-weight: 600;
        }

        .schedule-table td {
            padding: 12px 10px;
            text-align: center;
            border: 1px solid #e1e8ed;
            vertical-align: middle;
        }

        .editable-cell {
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .editable-cell:hover {
            background: #fff3cd !important;
            border-color: #ff7b54;
        }

        .editable-cell.editing {
            background: #e3f2fd !important;
            border-color: #2196f3;
        }

        .input-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
        }

        .subject-input {
            width: 100%;
            height: 100%;
            border: 2px solid #2196f3;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            box-sizing: border-box;
        }

        .subject-input:focus {
            outline: none;
            border-color: #1976d2;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #2196f3;
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            max-height: 200px;
            overflow-y: auto;
        }

        .autocomplete-option {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s ease;
        }

        .autocomplete-option:hover,
        .autocomplete-option.selected {
            background: #e3f2fd;
        }

        .autocomplete-option:last-child {
            border-bottom: none;
        }

        .edit-hint {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            color: #999;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .editable-cell:hover .edit-hint {
            opacity: 1;
        }

        .schedule-table tbody tr:nth-child(even) {
            background: #f8f9fa;
        }

        .schedule-table tbody tr:hover {
            background: #e3f2fd;
        }

        .period-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .session-header {
            background: #e8f4fd !important;
            font-weight: 600;
            color: #1976d2;
        }

        .session-break {
            height: 15px;
            background: linear-gradient(90deg, transparent 0%, #ff7b54 50%, transparent 100%);
            border: none;
        }

        .session-break td {
            border: none;
            padding: 0;
            position: relative;
        }

        .session-break td::after {
            content: '‚Ä¢ ‚Ä¢ ‚Ä¢';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff7b54;
            font-size: 12px;
            letter-spacing: 8px;
        }

        .hidden {
            display: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-info {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #6c757d;
        }



        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .export-buttons {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üóìÔ∏è C√¥ng c·ª• tr√≠ch xu·∫•t TKB</h1>
            <p>Phi√™n b·∫£n n√¢ng cao - X·ª≠ l√Ω nhi·ªÅu ƒë·ªãnh d·∫°ng file Excel kh√°c nhau</p>
        </div>

        <div class="content">
            <!-- B∆∞·ªõc 1: Ch·ªçn file -->
            <div class="step">
                <div class="step-title">
                    <span class="step-number">1</span>
                    Ch·ªçn file Excel TKB to√†n tr∆∞·ªùng
                </div>
                <label class="file-input-wrapper">
                    üìÅ Ch·ªçn file Excel (.xlsx, .xls)
                    <input type="file" id="fileInput" accept=".xlsx,.xls" />
                </label>
                <div id="fileInfo" class="file-info hidden"></div>
            </div>

            <!-- B∆∞·ªõc 2: Ch·ªçn sheet -->
            <div class="step hidden" id="sheetStep">
                <div class="step-title">
                    <span class="step-number">2</span>
                    Ch·ªçn sheet d·ªØ li·ªáu
                </div>
                <div class="controls">
                    <select id="sheetSelect">
                        <option value="">-- Ch·ªçn sheet --</option>
                    </select>
                </div>

            </div>

            <!-- B∆∞·ªõc 3: Ch·ªçn l·ªõp -->
            <div class="step hidden" id="classStep">
                <div class="step-title">
                    <span class="step-number">3</span>
                    Ch·ªçn l·ªõp h·ªçc
                </div>
                <div class="controls">
                    <select id="classSelect">
                        <option value="">-- Ch·ªçn l·ªõp --</option>
                    </select>
                    <button id="viewScheduleBtn" disabled>üëÄ Xem TKB l·ªõp</button>
                </div>

            </div>

            <!-- B∆∞·ªõc 4: Xu·∫•t file -->
            <div class="step hidden" id="exportStep">
                <div class="step-title">
                    <span class="step-number">4</span>
                    Xu·∫•t k·∫øt qu·∫£
                </div>
                <div class="export-buttons">
                    <button id="exportExcelBtn" disabled>üìä Xu·∫•t Excel</button>
                    <button id="exportHtmlBtn" disabled>üåê Xu·∫•t HTML</button>
                </div>
            </div>

            <!-- Th√¥ng b√°o tr·∫°ng th√°i -->
            <div id="statusDiv"></div>

            <!-- B·∫£ng hi·ªÉn th·ªã TKB -->
            <div id="scheduleContainer" class="hidden">
                <h3 style="margin: 20px 0; color: #2c3e50;">üìã Th·ªùi kh√≥a bi·ªÉu l·ªõp <span id="selectedClassName"></span></h3>
                <div id="scheduleTable"></div>
            </div>
        </div>
    </div>

    <script>
        let workbook = null;
        let currentSheet = null;
        let scheduleData = null;
        let selectedClass = '';
        let debugMode = false; // T·∫Øt ch·∫ø ƒë·ªô debug ƒë·ªÉ giao di·ªán g·ªçn g√†ng
        let allSubjects = new Set(); // L∆∞u t·∫•t c·∫£ m√¥n h·ªçc t√¨m th·∫•y
        let currentEditingCell = null;

        // Kh·ªüi t·∫°o s·ª± ki·ªán
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('sheetSelect').addEventListener('change', handleSheetSelect);
        document.getElementById('classSelect').addEventListener('change', handleClassSelect);
        document.getElementById('viewScheduleBtn').addEventListener('click', viewSchedule);
        document.getElementById('exportExcelBtn').addEventListener('click', exportExcel);
        document.getElementById('exportHtmlBtn').addEventListener('click', exportHtml);

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('statusDiv');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 8000);
        }



        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            showStatus('ƒêang ƒë·ªçc file Excel...', 'info');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    workbook = XLSX.read(e.target.result, { type: 'binary' });
                    
                    // Hi·ªÉn th·ªã th√¥ng tin file
                    const fileInfo = document.getElementById('fileInfo');
                    fileInfo.innerHTML = `üìÑ <strong>${file.name}</strong> (${(file.size / 1024).toFixed(1)} KB)`;
                    fileInfo.classList.remove('hidden');

                    // Hi·ªÉn th·ªã danh s√°ch sheet
                    const sheetSelect = document.getElementById('sheetSelect');
                    sheetSelect.innerHTML = '<option value="">-- Ch·ªçn sheet --</option>';
                    
                    workbook.SheetNames.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        sheetSelect.appendChild(option);
                    });

                    document.getElementById('sheetStep').classList.remove('hidden');
                    showStatus('‚úÖ ƒê·ªçc file th√†nh c√¥ng! Vui l√≤ng ch·ªçn sheet d·ªØ li·ªáu.', 'success');
                    

                } catch (error) {
                    showStatus('‚ùå L·ªói ƒë·ªçc file: ' + error.message, 'error');
                }
            };
            reader.readAsBinaryString(file);
        }

        function handleSheetSelect(event) {
            const sheetName = event.target.value;
            if (!sheetName) return;

            try {
                currentSheet = workbook.Sheets[sheetName];
                const analysisResult = analyzeSheet(currentSheet);
                
                if (analysisResult.classes.length === 0) {
                    showStatus('‚ùå Kh√¥ng t√¨m th·∫•y l·ªõp h·ªçc n√†o trong sheet n√†y. Vui l√≤ng ch·ªçn sheet kh√°c.', 'error');
                    return;
                }

                // Hi·ªÉn th·ªã danh s√°ch l·ªõp
                const classSelect = document.getElementById('classSelect');
                classSelect.innerHTML = '<option value="">-- Ch·ªçn l·ªõp --</option>';
                
                analysisResult.classes.forEach(className => {
                    const option = document.createElement('option');
                    option.value = className;
                    option.textContent = className;
                    classSelect.appendChild(option);
                });

                document.getElementById('classStep').classList.remove('hidden');
                showStatus(`‚úÖ T√¨m th·∫•y ${analysisResult.classes.length} l·ªõp h·ªçc. Vui l√≤ng ch·ªçn l·ªõp c·∫ßn tr√≠ch xu·∫•t.`, 'success');
            } catch (error) {
                showStatus('‚ùå L·ªói x·ª≠ l√Ω sheet: ' + error.message, 'error');
            }
        }

        function handleClassSelect(event) {
            selectedClass = event.target.value;
            const viewBtn = document.getElementById('viewScheduleBtn');
            
            if (selectedClass) {
                viewBtn.disabled = false;
            } else {
                viewBtn.disabled = true;
                document.getElementById('scheduleContainer').classList.add('hidden');
                document.getElementById('exportStep').classList.add('hidden');
            }
        }

        function analyzeSheet(sheet) {
            const range = XLSX.utils.decode_range(sheet['!ref']);
            const classes = new Set();
            const debugInfo = [];
            
            debugInfo.push(`K√≠ch th∆∞·ªõc sheet: ${range.e.r + 1} d√≤ng x ${range.e.c + 1} c·ªôt`);
            
            // X·ª≠ l√Ω merged cells
            const mergedCells = sheet['!merges'] || [];
            const cellValues = {};
            
            // ƒê·ªçc t·∫•t c·∫£ gi√° tr·ªã
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const cell = sheet[cellAddress];
                    
                    if (cell && cell.v !== undefined) {
                        cellValues[cellAddress] = String(cell.v).trim();
                    }
                }
            }
            
            // ƒêi·ªÅn gi√° tr·ªã cho merged cells
            mergedCells.forEach(merge => {
                const startCell = XLSX.utils.encode_cell({ r: merge.s.r, c: merge.s.c });
                const value = cellValues[startCell] || '';
                
                for (let row = merge.s.r; row <= merge.e.r; row++) {
                    for (let col = merge.s.c; col <= merge.e.c; col++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                        if (!cellValues[cellAddress]) {
                            cellValues[cellAddress] = value;
                        }
                    }
                }
            });

            debugInfo.push(`S·ªë merged cells: ${mergedCells.length}`);
            
            // T√¨m l·ªõp h·ªçc v·ªõi nhi·ªÅu pattern kh√°c nhau
            const potentialClasses = [];
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = cellValues[cellAddress] || '';
                    
                    if (value) {
                        const className = extractClassName(value);
                        if (className) {
                            classes.add(className);
                            potentialClasses.push(`${cellAddress}: "${value}" ‚Üí "${className}"`);
                        }
                    }
                }
            }
            
            debugInfo.push(`T√¨m th·∫•y ${potentialClasses.length} √¥ c√≥ th·ªÉ ch·ª©a t√™n l·ªõp:`);
            debugInfo.push(potentialClasses.slice(0, 10).join('\n')); // Ch·ªâ hi·ªÉn th·ªã 10 ƒë·∫ßu ti√™n
            if (potentialClasses.length > 10) {
                debugInfo.push(`... v√† ${potentialClasses.length - 10} √¥ kh√°c`);
            }
            
            const sortedClasses = Array.from(classes).sort((a, b) => {
                // S·∫Øp x·∫øp theo s·ªë l·ªõp r·ªìi ƒë·∫øn ch·ªØ c√°i
                const aMatch = a.match(/(\d+)([A-Za-z]+)(\d*)/);
                const bMatch = b.match(/(\d+)([A-Za-z]+)(\d*)/);
                if (aMatch && bMatch) {
                    const gradeA = parseInt(aMatch[1]);
                    const gradeB = parseInt(bMatch[1]);
                    if (gradeA !== gradeB) return gradeA - gradeB;
                    if (aMatch[2] !== bMatch[2]) return aMatch[2].localeCompare(bMatch[2]);
                    return parseInt(aMatch[3] || 0) - parseInt(bMatch[3] || 0);
                }
                return a.localeCompare(b);
            });
            
            return {
                classes: sortedClasses,
                debug: debugInfo.join('\n')
            };
        }

        function extractClassName(value) {
            // Lo·∫°i b·ªè c√°c k√Ω t·ª± kh√¥ng c·∫ßn thi·∫øt nh∆∞ng gi·ªØ l·∫°i kho·∫£ng tr·∫Øng t·∫°m th·ªùi
            let original = String(value).trim();
            let cleaned = original.replace(/[^\w\d\s]/g, '').replace(/\s+/g, '').toUpperCase();
            
            // Lo·∫°i b·ªè ti·ªÅn t·ªë ph·ªï bi·∫øn
            cleaned = cleaned.replace(/^(LOP|CLASS|K|KHOI)/i, '');
            
            // C√°c pattern nh·∫≠n di·ªán l·ªõp h·ªçc
            const patterns = [
                /^(\d{1,2})([A-Z])(\d*)$/,           // 10A1, 11B, 12C2
                /^(\d{1,2})([A-Z]+)(\d*)$/,          // 10AB1, 11CD
                /^([A-Z])(\d{1,2})([A-Z]?)(\d*)$/,   // A10B1, B11
            ];
            
            for (let pattern of patterns) {
                const match = cleaned.match(pattern);
                if (match) {
                    // Chu·∫©n h√≥a format: s·ªë + ch·ªØ + s·ªë (n·∫øu c√≥)
                    if (match[1] && /^\d/.test(match[1])) {
                        const grade = match[1];
                        const letter = match[2];
                        const number = match[3] || '';
                        
                        // Ki·ªÉm tra logic: l·ªõp 6-12, ch·ªØ c√°i A-Z
                        if (parseInt(grade) >= 6 && parseInt(grade) <= 12) {
                            return grade + letter + number;
                        }
                    } else if (match[2] && /^\d/.test(match[2])) {
                        const grade = match[2];
                        const letter = match[1];
                        const letter2 = match[3] || '';
                        const number = match[4] || '';
                        
                        if (parseInt(grade) >= 6 && parseInt(grade) <= 12) {
                            return grade + letter + letter2 + number;
                        }
                    }
                }
            }
            
            return null;
        }

        function viewSchedule() {
            if (!selectedClass || !currentSheet) return;

            try {
                const extractResult = extractScheduleData(currentSheet, selectedClass);
                scheduleData = extractResult.schedule;
                
                displaySchedule(scheduleData);
                
                document.getElementById('selectedClassName').textContent = selectedClass;
                document.getElementById('scheduleContainer').classList.remove('hidden');
                document.getElementById('exportStep').classList.remove('hidden');
                
                // K√≠ch ho·∫°t n√∫t xu·∫•t
                document.getElementById('exportExcelBtn').disabled = false;
                document.getElementById('exportHtmlBtn').disabled = false;
                
                showStatus('‚úÖ Hi·ªÉn th·ªã th·ªùi kh√≥a bi·ªÉu th√†nh c√¥ng!', 'success');
            } catch (error) {
                showStatus('‚ùå L·ªói tr√≠ch xu·∫•t d·ªØ li·ªáu: ' + error.message, 'error');
            }
        }

        function extractScheduleData(sheet, className) {
            const range = XLSX.utils.decode_range(sheet['!ref']);
            const debugInfo = [];
            
            // X·ª≠ l√Ω merged cells
            const mergedCells = sheet['!merges'] || [];
            const cellValues = {};
            
            // ƒê·ªçc t·∫•t c·∫£ gi√° tr·ªã v√† x·ª≠ l√Ω merge
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const cell = sheet[cellAddress];
                    
                    if (cell && cell.v !== undefined) {
                        cellValues[cellAddress] = String(cell.v).trim();
                    }
                }
            }
            
            // ƒêi·ªÅn gi√° tr·ªã cho merged cells
            mergedCells.forEach(merge => {
                const startCell = XLSX.utils.encode_cell({ r: merge.s.r, c: merge.s.c });
                const value = cellValues[startCell] || '';
                
                for (let row = merge.s.r; row <= merge.e.r; row++) {
                    for (let col = merge.s.c; col <= merge.e.c; col++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                        if (!cellValues[cellAddress]) {
                            cellValues[cellAddress] = value;
                        }
                    }
                }
            });

            // T√¨m header v√† c·ªôt d·ªØ li·ªáu (t√¨m trong to√†n b·ªô sheet)
            let headerRow = -1;
            let dayCol = -1;
            let periodCol = -1;
            let classCol = -1;

            // B∆∞·ªõc 1: T√¨m t·∫•t c·∫£ c√°c c·ªôt "Th·ª©" v√† "Ti·∫øt" trong to√†n b·ªô sheet tr∆∞·ªõc
            const potentialDayCols = [];
            const potentialPeriodCols = [];
            
            debugInfo.push('=== QU√âT TO√ÄN B·ªò SHEET T√åM C·ªòT ===');
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = cellValues[cellAddress] || '';
                    
                    if (value.trim()) {
                        if (isDayColumn(value)) {
                            potentialDayCols.push({ row, col, value, address: cellAddress });
                            debugInfo.push(`T√¨m th·∫•y c·ªôt ng√†y ti·ªÅm nƒÉng t·∫°i ${cellAddress}: "${value}"`);
                        }
                        if (isPeriodColumn(value)) {
                            potentialPeriodCols.push({ row, col, value, address: cellAddress });
                            debugInfo.push(`T√¨m th·∫•y c·ªôt ti·∫øt ti·ªÅm nƒÉng t·∫°i ${cellAddress}: "${value}"`);
                        }
                    }
                }
            }

            debugInfo.push(`T·ªïng c·ªông t√¨m th·∫•y ${potentialDayCols.length} c·ªôt ng√†y v√† ${potentialPeriodCols.length} c·ªôt ti·∫øt`);

            // B∆∞·ªõc 2: T√¨m l·ªõp h·ªçc trong to√†n b·ªô sheet
            debugInfo.push('=== T√åM L·ªöP H·ªåC ===');
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = cellValues[cellAddress] || '';
                    
                    if (normalizeClassName(value) === normalizeClassName(className)) {
                        headerRow = row;
                        classCol = col;
                        debugInfo.push(`T√¨m th·∫•y l·ªõp ${className} t·∫°i ${cellAddress} (d√≤ng ${row + 1}, c·ªôt ${col + 1})`);
                        break;
                    }
                }
                if (headerRow !== -1) break;
            }

            if (headerRow === -1) {
                throw new Error(`Kh√¥ng t√¨m th·∫•y l·ªõp ${className} trong d·ªØ li·ªáu`);
            }

            // B∆∞·ªõc 3: Ch·ªçn c·ªôt ng√†y v√† ti·∫øt ph√π h·ª£p nh·∫•t
            debugInfo.push('=== CH·ªåN C·ªòT PH√ô H·ª¢P NH·∫§T ===');
            
            // ∆Øu ti√™n c·ªôt trong c√πng d√≤ng v·ªõi l·ªõp h·ªçc
            let bestDayCol = potentialDayCols.find(col => col.row === headerRow);
            let bestPeriodCol = potentialPeriodCols.find(col => col.row === headerRow);
            
            if (bestDayCol) {
                dayCol = bestDayCol.col;
                debugInfo.push(`Ch·ªçn c·ªôt ng√†y c√πng d√≤ng: ${bestDayCol.address} - "${bestDayCol.value}"`);
            } else if (potentialDayCols.length > 0) {
                // Ch·ªçn c·ªôt g·∫ßn nh·∫•t v·ªõi d√≤ng l·ªõp h·ªçc
                bestDayCol = potentialDayCols.reduce((closest, current) => 
                    Math.abs(current.row - headerRow) < Math.abs(closest.row - headerRow) ? current : closest
                );
                dayCol = bestDayCol.col;
                debugInfo.push(`Ch·ªçn c·ªôt ng√†y g·∫ßn nh·∫•t: ${bestDayCol.address} - "${bestDayCol.value}"`);
            }
            
            if (bestPeriodCol) {
                periodCol = bestPeriodCol.col;
                debugInfo.push(`Ch·ªçn c·ªôt ti·∫øt c√πng d√≤ng: ${bestPeriodCol.address} - "${bestPeriodCol.value}"`);
            } else if (potentialPeriodCols.length > 0) {
                // Ch·ªçn c·ªôt g·∫ßn nh·∫•t v·ªõi d√≤ng l·ªõp h·ªçc
                bestPeriodCol = potentialPeriodCols.reduce((closest, current) => 
                    Math.abs(current.row - headerRow) < Math.abs(closest.row - headerRow) ? current : closest
                );
                periodCol = bestPeriodCol.col;
                debugInfo.push(`Ch·ªçn c·ªôt ti·∫øt g·∫ßn nh·∫•t: ${bestPeriodCol.address} - "${bestPeriodCol.value}"`);
            }

            if (dayCol === -1 || periodCol === -1) {
                let errorMsg = '‚ùå Kh√¥ng t√¨m th·∫•y c·ªôt c·∫ßn thi·∫øt:\n';
                if (dayCol === -1) {
                    errorMsg += `- Kh√¥ng t√¨m th·∫•y c·ªôt "Th·ª©/Ng√†y" (t√¨m th·∫•y ${potentialDayCols.length} ·ª©ng vi√™n)\n`;
                }
                if (periodCol === -1) {
                    errorMsg += `- Kh√¥ng t√¨m th·∫•y c·ªôt "Ti·∫øt/Gi·ªù" (t√¨m th·∫•y ${potentialPeriodCols.length} ·ª©ng vi√™n)\n`;
                }
                errorMsg += '\nüí° G·ª£i √Ω kh·∫Øc ph·ª•c:\n';
                errorMsg += '- Ki·ªÉm tra t√™n c·ªôt c√≥ ch·ª©a t·ª´ "Th·ª©", "Ng√†y", "Ti·∫øt", "Gi·ªù"\n';
                errorMsg += '- ƒê·∫£m b·∫£o c·ªôt header kh√¥ng b·ªã merge ho·∫∑c ·∫©n\n';
                errorMsg += '- Th·ª≠ ch·ªçn sheet kh√°c n·∫øu c√≥ nhi·ªÅu sheet';
                
                throw new Error(errorMsg);
            }

            // Tr√≠ch xu·∫•t d·ªØ li·ªáu v√† thu th·∫≠p t·∫•t c·∫£ m√¥n h·ªçc
            const schedule = {};
            let extractedCount = 0;
            allSubjects.clear(); // Reset danh s√°ch m√¥n h·ªçc
            
            // Thu th·∫≠p t·∫•t c·∫£ m√¥n h·ªçc t·ª´ to√†n b·ªô sheet
            debugInfo.push('=== THU TH·∫¨P M√îN H·ªåC ===');
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const value = cellValues[cellAddress] || '';
                    
                    if (value && value.trim().length > 0) {
                        const trimmedValue = value.trim();
                        
                        // Ki·ªÉm tra xem c√≥ ph·∫£i m√¥n h·ªçc kh√¥ng
                        if (isSubjectName(trimmedValue)) {
                            allSubjects.add(trimmedValue);
                            debugInfo.push(`M√¥n h·ªçc t√¨m th·∫•y: "${trimmedValue}" t·∫°i ${cellAddress}`);
                        }
                    }
                }
            }
            
            // Th√™m c√°c m√¥n h·ªçc c∆° b·∫£n ƒë·ªÉ ƒë·∫£m b·∫£o lu√¥n c√≥ g·ª£i √Ω
            const basicSubjects = [
                'To√°n', 'VƒÉn', 'Ti·∫øng Anh', 'V·∫≠t l√Ω', 'H√≥a h·ªçc', 'Sinh h·ªçc', 
                'L·ªãch s·ª≠', 'ƒê·ªãa l√Ω', 'GDCD', 'Tin h·ªçc', 'Th·ªÉ d·ª•c', '√Çm nh·∫°c', 
                'M·ªπ thu·∫≠t', 'C√¥ng ngh·ªá', 'Ho·∫°t ƒë·ªông tr·∫£i nghi·ªám', 'Sinh ho·∫°t l·ªõp',
                'T·ª± h·ªçc', 'Ch√†o c·ªù', 'Sinh ho·∫°t', 'Ngo·∫°i kh√≥a', 'Anh', 'L√Ω', 'H√≥a', 'Sinh', 'S·ª≠', 'ƒê·ªãa'
            ];
            basicSubjects.forEach(subject => allSubjects.add(subject));
            
            debugInfo.push(`T·ªïng c·ªông ${allSubjects.size} m√¥n h·ªçc: ${Array.from(allSubjects).join(', ')}`);
            console.log('All subjects collected:', Array.from(allSubjects));
            
            // Tr√≠ch xu·∫•t d·ªØ li·ªáu cho l·ªõp c·ª• th·ªÉ
            debugInfo.push('=== TR√çCH XU·∫§T D·ªÆ LI·ªÜU ===');
            for (let row = range.s.r; row <= range.e.r; row++) {
                const dayAddress = XLSX.utils.encode_cell({ r: row, c: dayCol });
                const periodAddress = XLSX.utils.encode_cell({ r: row, c: periodCol });
                const subjectAddress = XLSX.utils.encode_cell({ r: row, c: classCol });
                
                const day = cellValues[dayAddress] || '';
                const period = cellValues[periodAddress] || '';
                const subject = cellValues[subjectAddress] || '';
                
                // Debug log cho m·ªói d√≤ng c√≥ d·ªØ li·ªáu
                if (day || period || subject) {
                    debugInfo.push(`D√≤ng ${row + 1}: Day="${day}" Period="${period}" Subject="${subject}"`);
                }
                
                if (day && period && subject) {
                    const normalizedDay = normalizeDay(day);
                    const normalizedPeriod = normalizePeriod(period);
                    
                    debugInfo.push(`  -> Normalized: Day="${normalizedDay}" Period="${normalizedPeriod}"`);
                    
                    if (normalizedDay && normalizedPeriod) {
                        if (!schedule[normalizedDay]) {
                            schedule[normalizedDay] = {};
                        }
                        schedule[normalizedDay][normalizedPeriod] = subject;
                        extractedCount++;
                        debugInfo.push(`  -> ‚úÖ ƒê√£ l∆∞u: ${normalizedDay} - ${normalizedPeriod} = "${subject}"`);
                        
                        // ƒê·∫∑c bi·ªát log cho ti·∫øt 16h
                        if (normalizedPeriod === '16h') {
                            console.log(`üéØ FOUND 16H DATA: ${normalizedDay} = "${subject}"`);
                        }
                    } else {
                        debugInfo.push(`  -> ‚ùå Kh√¥ng th·ªÉ normalize`);
                    }
                }
            }

            debugInfo.push(`ƒê√£ tr√≠ch xu·∫•t ${extractedCount} ti·∫øt h·ªçc`);
            debugInfo.push(`C√°c ng√†y c√≥ d·ªØ li·ªáu: ${Object.keys(schedule).join(', ')}`);

            // Hi·ªÉn th·ªã debug info trong console
            console.log('=== DEBUG INFO ===');
            console.log(debugInfo.join('\n'));
            console.log('=== FINAL SCHEDULE ===');
            console.log(schedule);

            return {
                schedule: schedule,
                debug: debugInfo.join('\n')
            };
        }

        function normalizeClassName(name) {
            return String(name).replace(/[\s\-\.\/]/g, '').toUpperCase();
        }

        function isSubjectName(value) {
            const str = String(value).trim();
            
            // B·ªè qua c√°c gi√° tr·ªã r·ªóng, s·ªë, ng√†y th√°ng
            if (!str || /^\d+$/.test(str) || str.length < 2) return false;
            
            // B·ªè qua c√°c t·ª´ kh√≥a h·ªá th·ªëng
            const systemKeywords = [
                'th·ª©', 'ng√†y', 'ti·∫øt', 'gi·ªù', 'bu·ªïi', 's√°ng', 'chi·ªÅu', 't·ªëi',
                'l·ªõp', 'class', 'period', 'day', 'time', 'hour',
                'thu', 'ngay', 'tiet', 'gio', 'lop'
            ];
            
            const normalized = str.toLowerCase().replace(/[^\w]/g, '');
            if (systemKeywords.some(keyword => normalized.includes(keyword))) return false;
            
            // B·ªè qua t√™n l·ªõp
            if (extractClassName(str)) return false;
            
            // Ch·∫•p nh·∫≠n n·∫øu c√≥ √≠t nh·∫•t 2 k√Ω t·ª± v√† kh√¥ng ph·∫£i s·ªë thu·∫ßn t√∫y
            return str.length >= 2 && !/^\d+[\.\-\/]*\d*$/.test(str);
        }

        function isDayColumn(value) {
            const original = String(value).trim();
            const normalized = original.toLowerCase().replace(/[^\w\d]/g, '');
            
            // C√°c pattern nh·∫≠n di·ªán c·ªôt ng√†y/th·ª©
            const dayPatterns = [
                // Ti·∫øng Vi·ªát c√≥ d·∫•u
                'th·ª©', 'ng√†y', 'ngayhoc', 'ngaytrongtuan', 'ng√†yh·ªçc', 'ng√†ytrongtu·∫ßn',
                // Ti·∫øng Vi·ªát kh√¥ng d·∫•u  
                'thu', 'ngay', 'ngayhoc', 'ngaytrongtuan',
                // Ti·∫øng Anh
                'day', 'weekday', 'dayofweek', 'days',
                // Vi·∫øt t·∫Øt
                't', 'n', 'd'
            ];
            
            // Ki·ªÉm tra exact match tr∆∞·ªõc
            if (dayPatterns.includes(normalized)) return true;
            
            // Ki·ªÉm tra contains
            const containsPatterns = dayPatterns.some(pattern => normalized.includes(pattern));
            if (containsPatterns) return true;
            
            // Ki·ªÉm tra pattern ƒë·∫∑c bi·ªát: ch·ªâ c√≥ "T" ho·∫∑c "Th·ª©" 
            if (/^t+h*·ª©*$/i.test(normalized)) return true;
            
            // Ki·ªÉm tra n·∫øu c√≥ t·ª´ "th·ª©" trong chu·ªói g·ªëc (c√≥ d·∫•u)
            if (original.toLowerCase().includes('th·ª©')) return true;
            
            return false;
        }

        function isPeriodColumn(value) {
            const original = String(value).trim();
            const normalized = original.toLowerCase().replace(/[^\w\d]/g, '');
            
            // C√°c pattern nh·∫≠n di·ªán c·ªôt ti·∫øt/gi·ªù
            const periodPatterns = [
                // Ti·∫øng Vi·ªát c√≥ d·∫•u
                'ti·∫øt', 'gi·ªù', 'ti·∫øth·ªçc', 'gi·ªùh·ªçc', 'ti·∫øtd·∫°y', 'gi·ªùd·∫°y',
                // Ti·∫øng Vi·ªát kh√¥ng d·∫•u
                'tiet', 'gio', 'tiethoc', 'giohoc', 'tietday', 'gioday',
                // Ti·∫øng Anh
                'period', 'lesson', 'class', 'hour', 'time', 'slot',
                // Vi·∫øt t·∫Øt
                'tiet', 'gio', 'g', 'p', 'l'
            ];
            
            // Ki·ªÉm tra exact match tr∆∞·ªõc
            if (periodPatterns.includes(normalized)) return true;
            
            // Ki·ªÉm tra contains
            const containsPatterns = periodPatterns.some(pattern => normalized.includes(pattern));
            if (containsPatterns) return true;
            
            // Ki·ªÉm tra pattern ƒë·∫∑c bi·ªát
            if (/^t+i*·∫ø*t*$/i.test(normalized)) return true;
            if (/^g+i*·ªù*$/i.test(normalized)) return true;
            
            // Ki·ªÉm tra n·∫øu c√≥ t·ª´ "ti·∫øt" ho·∫∑c "gi·ªù" trong chu·ªói g·ªëc (c√≥ d·∫•u)
            if (original.toLowerCase().includes('ti·∫øt') || original.toLowerCase().includes('gi·ªù')) return true;
            
            return false;
        }

        function normalizeDay(day) {
            const dayStr = String(day).toLowerCase().replace(/[^\w]/g, '');
            
            const dayMap = {
                // S·ªë
                '2': 'Th·ª© 2', 'hai': 'Th·ª© 2', 'monday': 'Th·ª© 2', 'mon': 'Th·ª© 2', 't2': 'Th·ª© 2',
                '3': 'Th·ª© 3', 'ba': 'Th·ª© 3', 'tuesday': 'Th·ª© 3', 'tue': 'Th·ª© 3', 't3': 'Th·ª© 3',
                '4': 'Th·ª© 4', 'tu': 'Th·ª© 4', 't∆∞': 'Th·ª© 4', 'wednesday': 'Th·ª© 4', 'wed': 'Th·ª© 4', 't4': 'Th·ª© 4',
                '5': 'Th·ª© 5', 'nam': 'Th·ª© 5', 'nƒÉm': 'Th·ª© 5', 'thursday': 'Th·ª© 5', 'thu': 'Th·ª© 5', 't5': 'Th·ª© 5',
                '6': 'Th·ª© 6', 'sau': 'Th·ª© 6', 's√°u': 'Th·ª© 6', 'friday': 'Th·ª© 6', 'fri': 'Th·ª© 6', 't6': 'Th·ª© 6',
                '7': 'Th·ª© 7', 'bay': 'Th·ª© 7', 'b·∫£y': 'Th·ª© 7', 'saturday': 'Th·ª© 7', 'sat': 'Th·ª© 7', 't7': 'Th·ª© 7',
                'cn': 'Ch·ªß nh·∫≠t', 'chunhat': 'Ch·ªß nh·∫≠t', 'sunday': 'Ch·ªß nh·∫≠t', 'sun': 'Ch·ªß nh·∫≠t'
            };
            
            // T√¨m trong map tr∆∞·ªõc
            if (dayMap[dayStr]) {
                return dayMap[dayStr];
            }
            
            // T√¨m pattern "th·ª© X"
            const thuMatch = dayStr.match(/thu(\d)/);
            if (thuMatch) {
                const num = thuMatch[1];
                return dayMap[num] || null;
            }
            
            // N·∫øu ƒë√£ c√≥ "Th·ª©" trong chu·ªói g·ªëc
            if (String(day).includes('Th·ª©')) {
                return String(day).trim();
            }
            
            return null;
        }

        function normalizePeriod(period) {
            const original = String(period).trim();
            const str = original.toLowerCase().replace(/[^\w\d:]/g, '');
            
            // Debug log ƒë·ªÉ theo d√µi
            console.log(`Normalizing period: "${original}" -> "${str}"`);
            
            // X·ª≠ l√Ω c√°c format ƒë·∫∑c bi·ªát cho 16h tr∆∞·ªõc
            if (str.includes('16h') || str.includes('16:') || str.includes('1600') || str === '16') {
                console.log('Found 16h period');
                return '16h';
            }
            
            // X·ª≠ l√Ω c√°c t·ª´ kh√≥a ƒë·∫∑c bi·ªát
            if (str.includes('sau') || str.includes('saugio') || str.includes('saugiohoc')) {
                console.log('Found "sau gio hoc" period');
                return '16h';
            }
            
            if (str.includes('sang')) return 's√°ng';
            if (str.includes('chieu')) return 'chi·ªÅu';
            
            // T√¨m s·ªë ti·∫øt
            const numberMatch = str.match(/(\d+)/);
            if (numberMatch) {
                const num = parseInt(numberMatch[1]);
                
                // X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho s·ªë 16
                if (num === 16) {
                    console.log('Found number 16, treating as 16h');
                    return '16h';
                }
                
                // Ch·ªâ ch·∫•p nh·∫≠n ti·∫øt t·ª´ 1-10
                if (num >= 1 && num <= 10) {
                    return num.toString();
                }
            }
            
            // X·ª≠ l√Ω kho·∫£ng th·ªùi gian
            const timeMatch = str.match(/(\d{1,2})h?(\d{0,2})/);
            if (timeMatch) {
                const hour = parseInt(timeMatch[1]);
                if (hour >= 7 && hour <= 8) return '1';
                if (hour >= 8 && hour <= 9) return '2';
                if (hour >= 9 && hour <= 10) return '3';
                if (hour >= 10 && hour <= 11) return '4';
                if (hour >= 11 && hour <= 12) return '5';
                if (hour >= 13 && hour <= 14) return '6';
                if (hour >= 14 && hour <= 15) return '7';
                if (hour >= 15 && hour <= 16) return '8';
                if (hour >= 16) {
                    console.log(`Found hour ${hour}, treating as 16h`);
                    return '16h';
                }
            }
            
            // Ki·ªÉm tra c√°c pattern kh√°c cho 16h
            if (original.toLowerCase().includes('16') || 
                original.toLowerCase().includes('sau gi·ªù') ||
                original.toLowerCase().includes('sau gio') ||
                original.toLowerCase().includes('ngo√†i gi·ªù') ||
                original.toLowerCase().includes('ngoai gio')) {
                console.log('Found alternative 16h pattern');
                return '16h';
            }
            
            console.log(`Could not normalize period: "${original}"`);
            return null;
        }

        function displaySchedule(schedule) {
            const days = ['Th·ª© 2', 'Th·ª© 3', 'Th·ª© 4', 'Th·ª© 5', 'Th·ª© 6'];
            const periods = ['1', '2', '3', '4', '5', '6', '7', '8', '16h'];
            
            // Debug: In ra d·ªØ li·ªáu schedule ƒë·ªÉ ki·ªÉm tra
            console.log('Schedule data:', schedule);
            
            let html = '<table class="schedule-table">';
            html += '<thead><tr><th>Bu·ªïi</th><th>Ti·∫øt</th>';
            days.forEach(day => {
                html += `<th>${day}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Bu·ªïi s√°ng
            html += '<tr><td rowspan="5" class="session-header">S√°ng</td><td class="period-label">1</td>';
            days.forEach(day => {
                const subject = (schedule[day] && schedule[day]['1']) ? schedule[day]['1'] : '';
                html += `<td class="editable-cell" data-day="${day}" data-period="1">${subject}<span class="edit-hint">‚úèÔ∏è</span></td>`;
            });
            html += '</tr>';

            for (let i = 2; i <= 5; i++) {
                html += `<tr><td class="period-label">${i}</td>`;
                days.forEach(day => {
                    const subject = (schedule[day] && schedule[day][i.toString()]) ? schedule[day][i.toString()] : '';
                    html += `<td class="editable-cell" data-day="${day}" data-period="${i}">${subject}<span class="edit-hint">‚úèÔ∏è</span></td>`;
                });
                html += '</tr>';
            }

            // Kho·∫£ng c√°ch gi·ªØa bu·ªïi s√°ng v√† chi·ªÅu
            html += '<tr class="session-break"><td colspan="7"></td></tr>';

            // Bu·ªïi chi·ªÅu
            html += '<tr><td rowspan="3" class="session-header">Chi·ªÅu</td><td class="period-label">6</td>';
            days.forEach(day => {
                const subject = (schedule[day] && schedule[day]['6']) ? schedule[day]['6'] : '';
                html += `<td class="editable-cell" data-day="${day}" data-period="6">${subject}<span class="edit-hint">‚úèÔ∏è</span></td>`;
            });
            html += '</tr>';

            for (let i = 7; i <= 8; i++) {
                html += `<tr><td class="period-label">${i}</td>`;
                days.forEach(day => {
                    const subject = (schedule[day] && schedule[day][i.toString()]) ? schedule[day][i.toString()] : '';
                    html += `<td class="editable-cell" data-day="${day}" data-period="${i}">${subject}<span class="edit-hint">‚úèÔ∏è</span></td>`;
                });
                html += '</tr>';
            }

            // Kho·∫£ng c√°ch gi·ªØa bu·ªïi chi·ªÅu v√† sau gi·ªù h·ªçc
            html += '<tr class="session-break"><td colspan="7"></td></tr>';

            // Sau gi·ªù h·ªçc - X·ª≠ l√Ω ƒë·∫∑c bi·ªát ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªÉn th·ªã ƒë√∫ng
            html += '<tr><td class="session-header">Sau gi·ªù h·ªçc</td><td class="period-label">16h</td>';
            days.forEach(day => {
                // Ki·ªÉm tra t·∫•t c·∫£ c√°c kh·∫£ nƒÉng c√≥ th·ªÉ c·ªßa period 16h
                let subject = '';
                if (schedule[day]) {
                    subject = schedule[day]['16h'] || schedule[day]['16'] || schedule[day]['sau'] || schedule[day]['saugiohoc'] || '';
                }
                console.log(`Day ${day}, Period 16h: "${subject}"`); // Debug log
                html += `<td class="editable-cell" data-day="${day}" data-period="16h">${subject}<span class="edit-hint">‚úèÔ∏è</span></td>`;
            });
            html += '</tr>';

            html += '</tbody></table>';
            document.getElementById('scheduleTable').innerHTML = html;
            
            // Th√™m s·ª± ki·ªán click cho c√°c √¥ c√≥ th·ªÉ ch·ªânh s·ª≠a
            document.querySelectorAll('.editable-cell').forEach(cell => {
                cell.addEventListener('click', handleCellClick);
            });
            
            // Th√™m s·ª± ki·ªán click outside ƒë·ªÉ ƒë√≥ng dropdown
            document.addEventListener('click', handleOutsideClick);
        }

        function handleCellClick(event) {
            event.stopPropagation();
            
            // ƒê√≥ng input hi·ªán t·∫°i n·∫øu c√≥
            closeCurrentInput();
            
            const cell = event.currentTarget;
            const day = cell.dataset.day;
            const period = cell.dataset.period;
            const currentSubject = cell.textContent.replace('‚úèÔ∏è', '').trim();
            
            // ƒê√°nh d·∫•u √¥ ƒëang ch·ªânh s·ª≠a
            cell.classList.add('editing');
            currentEditingCell = cell;
            
            // T·∫°o input v·ªõi autocomplete
            const inputContainer = createInputWithAutocomplete(currentSubject, day, period);
            cell.appendChild(inputContainer);
            
            // Focus v√†o input
            const input = inputContainer.querySelector('input');
            input.focus();
            input.select();
        }

        function createInputWithAutocomplete(currentSubject, day, period) {
            const container = document.createElement('div');
            container.className = 'input-container';
            
            // T·∫°o input
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'subject-input';
            input.value = currentSubject;
            input.placeholder = 'Nh·∫≠p t√™n m√¥n h·ªçc...';
            
            // T·∫°o dropdown g·ª£i √Ω
            const dropdown = document.createElement('div');
            dropdown.className = 'autocomplete-dropdown hidden';
            
            // S·ª± ki·ªán input
            input.addEventListener('input', (e) => {
                const value = e.target.value.trim();
                updateAutocomplete(dropdown, value, day, period);
            });
            
            // S·ª± ki·ªán focus - hi·ªÉn th·ªã dropdown khi focus
            input.addEventListener('focus', (e) => {
                const value = e.target.value.trim();
                updateAutocomplete(dropdown, value, day, period);
            });
            
            // S·ª± ki·ªán ph√≠m
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    selectSubject(input.value.trim(), day, period);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeCurrentInput();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    navigateDropdown(dropdown, 'down');
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    navigateDropdown(dropdown, 'up');
                }
            });
            
            // Hi·ªÉn th·ªã g·ª£i √Ω ban ƒë·∫ßu
            updateAutocomplete(dropdown, '', day, period);
            
            container.appendChild(input);
            container.appendChild(dropdown);
            
            return container;
        }

        function updateAutocomplete(dropdown, searchValue, day, period) {
            dropdown.innerHTML = '';
            
            // Debug log
            console.log(`Updating autocomplete for ${day} - ${period}, search: "${searchValue}"`);
            console.log(`Available subjects:`, Array.from(allSubjects));
            
            // L·ªçc m√¥n h·ªçc theo t·ª´ kh√≥a t√¨m ki·∫øm
            const sortedSubjects = Array.from(allSubjects).sort();
            const filteredSubjects = sortedSubjects.filter(subject => 
                subject.toLowerCase().includes(searchValue.toLowerCase())
            );
            
            console.log(`Filtered subjects:`, filteredSubjects);
            
            // Th√™m t√πy ch·ªçn tr·ªëng
            const emptyOption = document.createElement('div');
            emptyOption.className = 'autocomplete-option';
            emptyOption.textContent = '(Tr·ªëng)';
            emptyOption.addEventListener('click', (e) => {
                e.stopPropagation();
                selectSubject('', day, period);
            });
            dropdown.appendChild(emptyOption);
            
            // Th√™m c√°c m√¥n h·ªçc ƒë∆∞·ª£c l·ªçc
            filteredSubjects.forEach(subject => {
                const option = document.createElement('div');
                option.className = 'autocomplete-option';
                option.textContent = subject;
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectSubject(subject, day, period);
                });
                dropdown.appendChild(option);
            });
            
            // Th√™m m·ªôt s·ªë m√¥n h·ªçc ph·ªï bi·∫øn n·∫øu kh√¥ng c√≥ g·ª£i √Ω
            if (filteredSubjects.length === 0 && searchValue === '') {
                const commonSubjects = [
                    'To√°n', 'VƒÉn', 'Anh', 'L√Ω', 'H√≥a', 'Sinh', 'S·ª≠', 'ƒê·ªãa', 
                    'GDCD', 'Tin h·ªçc', 'Th·ªÉ d·ª•c', '√Çm nh·∫°c', 'M·ªπ thu·∫≠t',
                    'Ho·∫°t ƒë·ªông tr·∫£i nghi·ªám', 'Sinh ho·∫°t l·ªõp', 'T·ª± h·ªçc'
                ];
                
                commonSubjects.forEach(subject => {
                    const option = document.createElement('div');
                    option.className = 'autocomplete-option';
                    option.textContent = subject;
                    option.style.fontStyle = 'italic';
                    option.style.color = '#666';
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        selectSubject(subject, day, period);
                    });
                    dropdown.appendChild(option);
                });
            }
            
            // Lu√¥n hi·ªÉn th·ªã dropdown khi c√≥ focus
            dropdown.classList.remove('hidden');
            console.log(`Dropdown shown with ${dropdown.children.length} options`);
        }

        function navigateDropdown(dropdown, direction) {
            const options = dropdown.querySelectorAll('.autocomplete-option');
            let currentIndex = -1;
            
            // T√¨m option ƒëang ƒë∆∞·ª£c ch·ªçn
            options.forEach((option, index) => {
                if (option.classList.contains('selected')) {
                    currentIndex = index;
                    option.classList.remove('selected');
                }
            });
            
            // Di chuy·ªÉn selection
            if (direction === 'down') {
                currentIndex = currentIndex < options.length - 1 ? currentIndex + 1 : 0;
            } else {
                currentIndex = currentIndex > 0 ? currentIndex - 1 : options.length - 1;
            }
            
            // ƒê√°nh d·∫•u option m·ªõi
            if (options[currentIndex]) {
                options[currentIndex].classList.add('selected');
                options[currentIndex].scrollIntoView({ block: 'nearest' });
                
                // C·∫≠p nh·∫≠t gi√° tr·ªã input
                const input = currentEditingCell.querySelector('.subject-input');
                if (input) {
                    input.value = options[currentIndex].textContent === '(Tr·ªëng)' ? '' : options[currentIndex].textContent;
                }
            }
        }

        function selectSubject(subject, day, period) {
            // C·∫≠p nh·∫≠t d·ªØ li·ªáu
            if (!scheduleData[day]) {
                scheduleData[day] = {};
            }
            scheduleData[day][period] = subject;
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã
            if (currentEditingCell) {
                currentEditingCell.innerHTML = `${subject}<span class="edit-hint">‚úèÔ∏è</span>`;
            }
            
            // ƒê√≥ng input
            closeCurrentInput();
            
            showStatus('‚úÖ ƒê√£ c·∫≠p nh·∫≠t m√¥n h·ªçc!', 'success');
        }

        function closeCurrentInput() {
            if (currentEditingCell) {
                const inputContainer = currentEditingCell.querySelector('.input-container');
                if (inputContainer) {
                    inputContainer.remove();
                }
                currentEditingCell.classList.remove('editing');
                currentEditingCell = null;
            }
        }

        function handleOutsideClick(event) {
            if (currentEditingCell && !currentEditingCell.contains(event.target)) {
                closeCurrentInput();
            }
        }

        function exportExcel() {
            if (!scheduleData || !selectedClass) return;

            try {
                const wb = XLSX.utils.book_new();
                const wsData = createExcelData(scheduleData);
                const ws = XLSX.utils.aoa_to_sheet(wsData);
                
                // Thi·∫øt l·∫≠p merge cells
                const merges = [];
                merges.push({ s: { r: 1, c: 0 }, e: { r: 5, c: 0 } }); // S√°ng
                merges.push({ s: { r: 6, c: 0 }, e: { r: 8, c: 0 } }); // Chi·ªÅu
                
                ws['!merges'] = merges;
                
                // Thi·∫øt l·∫≠p ƒë·ªô r·ªông c·ªôt
                ws['!cols'] = [
                    { width: 12 }, // Bu·ªïi
                    { width: 8 },  // Ti·∫øt
                    { width: 15 }, // Th·ª© 2
                    { width: 15 }, // Th·ª© 3
                    { width: 15 }, // Th·ª© 4
                    { width: 15 }, // Th·ª© 5
                    { width: 15 }  // Th·ª© 6
                ];

                XLSX.utils.book_append_sheet(wb, ws, `TKB_${selectedClass}`);
                XLSX.writeFile(wb, `TKB_${selectedClass}.xlsx`);
                
                showStatus('‚úÖ Xu·∫•t file Excel th√†nh c√¥ng!', 'success');
            } catch (error) {
                showStatus('‚ùå L·ªói xu·∫•t Excel: ' + error.message, 'error');
            }
        }

        function createExcelData(schedule) {
            const days = ['Th·ª© 2', 'Th·ª© 3', 'Th·ª© 4', 'Th·ª© 5', 'Th·ª© 6'];
            const data = [];
            
            // Header
            data.push(['Bu·ªïi', 'Ti·∫øt', ...days]);
            
            // Bu·ªïi s√°ng
            data.push(['S√°ng', '1', ...days.map(day => schedule[day] && schedule[day]['1'] || '')]);
            data.push(['', '2', ...days.map(day => schedule[day] && schedule[day]['2'] || '')]);
            data.push(['', '3', ...days.map(day => schedule[day] && schedule[day]['3'] || '')]);
            data.push(['', '4', ...days.map(day => schedule[day] && schedule[day]['4'] || '')]);
            data.push(['', '5', ...days.map(day => schedule[day] && schedule[day]['5'] || '')]);
            
            // Bu·ªïi chi·ªÅu
            data.push(['Chi·ªÅu', '6', ...days.map(day => schedule[day] && schedule[day]['6'] || '')]);
            data.push(['', '7', ...days.map(day => schedule[day] && schedule[day]['7'] || '')]);
            data.push(['', '8', ...days.map(day => schedule[day] && schedule[day]['8'] || '')]);
            
            // Sau gi·ªù h·ªçc
            data.push(['Sau gi·ªù h·ªçc', '16h', ...days.map(day => schedule[day] && schedule[day]['16h'] || '')]);
            
            return data;
        }

        function exportHtml() {
            if (!scheduleData || !selectedClass) return;

            try {
                const htmlContent = createHtmlContent(scheduleData, selectedClass);
                const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                saveAs(blob, `TKB_${selectedClass}.html`);
                
                showStatus('‚úÖ Xu·∫•t file HTML th√†nh c√¥ng!', 'success');
            } catch (error) {
                showStatus('‚ùå L·ªói xu·∫•t HTML: ' + error.message, 'error');
            }
        }

        function createHtmlContent(schedule, className) {
            const days = ['Th·ª© 2', 'Th·ª© 3', 'Th·ª© 4', 'Th·ª© 5', 'Th·ª© 6'];
            
            return `<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Th·ªùi kh√≥a bi·ªÉu l·ªõp ${className}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #2c3e50; margin-bottom: 30px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px 8px; text-align: center; }
        th { background: #ff7b54; color: white; font-weight: bold; }
        .session-header { background: #e8f4fd !important; font-weight: bold; color: #1976d2; }
        .period-label { font-weight: bold; color: #2c3e50; }
        .session-break { height: 15px; background: linear-gradient(90deg, transparent 0%, #ff7b54 50%, transparent 100%); border: none; }
        .session-break td { border: none; padding: 0; position: relative; }
        .session-break td::after { content: '‚Ä¢ ‚Ä¢ ‚Ä¢'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff7b54; font-size: 12px; letter-spacing: 8px; }
        tr:nth-child(even) { background: #f9f9f9; }
        .print-date { text-align: center; margin-top: 20px; color: #666; font-size: 14px; }
        @media print { body { margin: 0; } .container { box-shadow: none; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìã TH·ªúI KH√ìA BI·ªÇU L·ªöP ${className}</h1>
        <table>
            <thead>
                <tr>
                    <th>Bu·ªïi</th>
                    <th>Ti·∫øt</th>
                    ${days.map(day => `<th>${day}</th>`).join('')}
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td rowspan="5" class="session-header">S√°ng</td>
                    <td class="period-label">1</td>
                    ${days.map(day => `<td>${schedule[day] && schedule[day]['1'] || ''}</td>`).join('')}
                </tr>
                ${[2,3,4,5].map(period => `
                <tr>
                    <td class="period-label">${period}</td>
                    ${days.map(day => `<td>${schedule[day] && schedule[day][period.toString()] || ''}</td>`).join('')}
                </tr>`).join('')}
                <tr class="session-break"><td colspan="7"></td></tr>
                <tr>
                    <td rowspan="3" class="session-header">Chi·ªÅu</td>
                    <td class="period-label">6</td>
                    ${days.map(day => `<td>${schedule[day] && schedule[day]['6'] || ''}</td>`).join('')}
                </tr>
                ${[7,8].map(period => `
                <tr>
                    <td class="period-label">${period}</td>
                    ${days.map(day => `<td>${schedule[day] && schedule[day][period.toString()] || ''}</td>`).join('')}
                </tr>`).join('')}
                <tr class="session-break"><td colspan="7"></td></tr>
                <tr>
                    <td class="session-header">Sau gi·ªù h·ªçc</td>
                    <td class="period-label">16h</td>
                    ${days.map(day => `<td>${schedule[day] && schedule[day]['16h'] || ''}</td>`).join('')}
                </tr>
            </tbody>
        </table>
        <div class="print-date">Xu·∫•t ng√†y: ${new Date().toLocaleDateString('vi-VN')}</div>
    </div>
</body>
</html>`;
        }
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'982143a217de1114',t:'MTc1ODM3MDY5My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

