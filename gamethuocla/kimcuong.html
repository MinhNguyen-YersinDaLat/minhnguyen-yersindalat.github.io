<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"/>
    <title>Game Kim Cương: Bảo Vệ Trái Tim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: none;
            overflow: hidden;
            animation: vignette-pulse 8s infinite alternate ease-in-out;
            /* cursor is set by JS */
        }
        @keyframes vignette-pulse {
            from { background: radial-gradient(ellipse at center, #1a1111 50%, #000000 100%); }
            to { background: radial-gradient(ellipse at center, #110a0a 40%, #000000 100%); }
        }
        canvas {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            /* cursor is set by JS */
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        #character-container {
            position: absolute;
            top: -95px; /* Điều chỉnh vị trí để phù hợp với kích thước mới */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
            z-index: 20;
        }
        .character-aura {
            position: absolute;
            width: 250px;
            height: 150px;
            background: radial-gradient(ellipse at center, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0) 70%);
            border-radius: 50%;
            animation: aura-pulse 4s infinite alternate ease-in-out;
            z-index: -1;
        }
        @keyframes aura-pulse {
            from { transform: scale(1); opacity: 0.7; }
            to { transform: scale(1.2); opacity: 0.4; }
        }
        #cigarette-svg {
            width: 240px; 
            height: 120px; 
            filter: drop-shadow(0 5px 20px rgba(0, 0, 0, 0.8));
            animation: idle-spasm 6s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        @keyframes idle-spasm {
            0%, 100% { transform: translate(0, 0) rotate(0); }
            10% { transform: translate(-2px, 2px) rotate(-1deg); }
            20% { transform: translate(2px, -2px) rotate(1deg); }
            30% { transform: translate(-3px, 0px) rotate(-1.5deg); }
            40% { transform: translate(3px, 1px) rotate(1.5deg); }
            50% { transform: translate(0, 0) rotate(0); }
            70% { transform: translate(0, 0) rotate(0); }
            72% { transform: translate(5px, -5px) rotate(3deg); }
            74% { transform: translate(0, 0) rotate(0); }
        }
        .cigarette-body-shape { fill: url(#paper-gradient); }
        .filter-shape { fill: #6b3520; }
        .ash-shape { fill: #333; }
        .ember-shape { fill: #ff4500; filter: url(#emberGlow); animation: ember-flicker 1.5s infinite alternate; }
        @keyframes ember-flicker {
            from { opacity: 0.9; }
            to { opacity: 1; }
        }
        .eye-socket { fill: #1a0000; }
        .eye-ball { fill: #dc143c; }
        .eye-pupil { fill: #000; transition: transform 0.1s linear; }
        .eye-vein { stroke: #8b0000; stroke-width: 0.5; fill: none; }
        .mouth { fill: #1a1a1a; transition: d 0.3s ease-in-out; }
        .crack { fill: none; stroke: #4e2a1d; stroke-width: 1.2; }
        .stain { fill: #704214; opacity: 0.6; }
        .spark { fill: #ffdd00; animation: spark-fly 1.5s infinite linear; }
        @keyframes spark-fly {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(-30px, var(--y-end)) scale(0); opacity: 0; }
        }
        .smoke-container { position: absolute; left: -120px; top: 50%; transform: translateY(-50%); width: 200px; height: 200px; pointer-events: none; filter: url(#smokeFilter); }
        .smoke-wisp {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: wisp-rise 12s infinite linear;
            opacity: 0;
        }
        @keyframes wisp-rise {
            0% { transform: translate(0, 0) scale(0.5); opacity: 0; }
            15% { opacity: 0.8; }
            100% { transform: translate(-120px, var(--y-end)) scale(2.5); opacity: 0; }
        }
        .smoke-wisp:nth-child(1) { width: 60px; height: 60px; animation-delay: 0s; --y-end: -80px; }
        .smoke-wisp:nth-child(2) { width: 80px; height: 80px; animation-delay: 4s; --y-end: 50px; }
        .smoke-wisp:nth-child(3) { width: 50px; height: 50px; animation-delay: 8s; --y-end: -20px; }
        #threat-bubble {
            position: absolute; bottom: 100%; left: 50%; margin-bottom: 10px; background-color: #110d0d; color: #ff4500;
            padding: 15px 22px; border-radius: 12px; border: 2px solid #ff4500; font-size: 1.3rem; font-family: 'Metal Mania', cursive;
            letter-spacing: 1px; opacity: 0; transform: translateY(20px) scale(0.9) translateX(-50%);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); white-space: nowrap; box-shadow: 0 0 25px rgba(255, 69, 0, 0.7);
        }
        #threat-bubble.visible { opacity: 1; transform: translateY(0) scale(1) translateX(-50%); }

        #monster-name {
            position: absolute;
            top: 50%;
            left: 230px; /* Điều chỉnh vị trí cho phù hợp */
            transform: translateY(-50%);
            white-space: nowrap;
        }

        #game-title { animation: sparkle 5s infinite linear; }
        @keyframes sparkle {
            0% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); }
            50% { text-shadow: 2px 2px 8px rgba(236, 72, 153, 0.5); }
            100% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); }
        }
        .health-bar-bg {
            background-color: rgba(0,0,0,0.3);
            border-radius: 9999px;
            padding: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .health-bar {
            background: linear-gradient(to right, #ef4444, #f87171);
            height: 16px;
            border-radius: 9999px;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px #ef4444;
        }
        #custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #ff4500;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 9999;
            transition: transform 0.1s ease-out;
            /* display is set by JS */
        }
        /* Màn hình chờ */
        #start-screen {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            padding: 1rem;
        }
        
        .tutorial-icon {
            height: 60px;
            margin: 0 auto 0.5rem auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tutorial-gem-container {
            width: 50px;
            height: 50px;
            position: relative;
        }
        .tutorial-gem {
            width: 100%;
            height: 100%;
            transform: rotate(45deg);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), inset -2px -2px 5px rgba(0,0,0,0.3);
        }
        .tutorial-gem-bomb {
            background: radial-gradient(circle, #6bb5ff, #1E90FF);
        }
        .tutorial-gem-bomb::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 60%;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px white;
        }
        .tutorial-gem-beam {
            background: radial-gradient(circle, #ff7b7b, #FF3131);
        }
        .tutorial-gem-beam::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 25%;
            background-color: white;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px white;
        }
        .tutorial-gem-hypercube {
            background: conic-gradient(from 0deg, #FF3131, #FFFF00, #00FF7F, #1E90FF, #FF00FF, #FF8C00, #FF3131);
            animation: spin 4s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(45deg); }
            to { transform: rotate(405deg); }
        }

        .gem-hint {
            animation: hint-pulse 1s infinite;
        }
        @keyframes hint-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* --- GIAO DIỆN NÚT MỚI --- */
        .ui-button {
            position: fixed;
            z-index: 101; /* Above start screen */
            width: 44px;
            height: 44px;
            background: rgba(10, 20, 30, 0.5);
            border: 1px solid rgba(236, 72, 153, 0.3);
            border-radius: 50%;
            color: rgba(236, 72, 153, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.2), inset 0 0 5px rgba(236, 72, 153, 0.1);
        }
        .ui-button:hover {
            background: rgba(20, 40, 60, 0.7);
            color: white;
            border-color: rgba(236, 72, 153, 0.8);
            box-shadow: 0 0 25px rgba(236, 72, 153, 0.5), inset 0 0 10px rgba(236, 72, 153, 0.2);
            transform: scale(1.1);
        }
        #fullscreen-btn {
            top: 1rem;
            right: 1rem;
        }
        #back-to-menu-btn {
            bottom: 1rem;
            right: 1rem;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-700 via-gray-800 to-gray-900 flex items-end justify-center min-h-screen p-4">

<!-- Nút Toàn màn hình -->
<button id="fullscreen-btn" class="ui-button" title="Toàn màn hình">
    <svg id="fullscreen-icon-open" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
    <svg id="fullscreen-icon-close" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
</button>

<!-- Nút Về màn hình chính -->
<button id="back-to-menu-btn" class="ui-button hidden" title="Về màn hình chính">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
</button>

<!-- Màn hình chờ -->
<div id="start-screen">
    <h1 class="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-4" id="game-title-start">Bảo Vệ Trái Tim</h1>
    <p class="text-gray-200 italic text-xl md:text-2xl mb-8 max-w-2xl">Quái vật thuốc lá đang đến gần. Hãy dùng trí tuệ của bạn để ghép các viên kim cương, cứu lấy những trái tim và đẩy lùi mối đe dọa!</p>
    <div class="flex flex-col sm:flex-row gap-4">
        <button id="easy-mode-btn" class="bg-green-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">Dễ (1 Màn)</button>
        <button id="hard-mode-btn" class="bg-red-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">Khó (3 Màn)</button>
        <button id="free-mode-btn" class="bg-blue-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">Tự Do</button>
    </div>
</div>

<!-- Modal Hướng dẫn chơi -->
<div id="tutorial-modal" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm">
    <div class="bg-gray-800 border border-gray-700 rounded-2xl p-6 md:p-8 shadow-2xl max-w-md w-full text-white text-center">
        <!-- Step 1: Trái Tim -->
        <div id="tutorial-step-1" class="tutorial-step">
            <h2 class="text-3xl font-bold text-pink-400 mb-4">Mục Tiêu: Cứu Trái Tim!</h2>
            <div class="tutorial-icon text-5xl">💗</div>
            <p class="text-lg mb-4">Mỗi vài nước đi, một viên kim cương <strong>Trái Tim</strong> sẽ xuất hiện ở hàng dưới cùng.</p>
            <p class="text-lg mb-6">Hãy đưa nó lên <strong>hàng trên cùng</strong> để cứu trái tim và ghi điểm. Đừng để quái vật thuốc lá chạm tới!</p>
            <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Tiếp theo</button>
        </div>

        <!-- Step 2: Kim cương đặc biệt -->
        <div id="tutorial-step-2" class="tutorial-step hidden">
             <h2 class="text-3xl font-bold text-yellow-400 mb-4">Sức Mạnh Đặc Biệt</h2>
             <p class="text-lg mb-4">Ghép 4 hoặc 5 viên kim cương để tạo ra các loại đặc biệt:</p>
             <div class="flex justify-around items-start text-center mb-6 space-x-2">
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-bomb"></div>
                        </div>
                    </div>
                    <p class="font-bold">Bom</p>
                    <p class="text-sm text-gray-300">(Ghép 5 viên hình chữ L hoặc T)</p>
                </div>
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-beam"></div>
                        </div>
                    </div>
                    <p class="font-bold">Tia Sáng</p>
                    <p class="text-sm text-gray-300">(Ghép 4 viên)</p>
                </div>
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-hypercube"></div>
                        </div>
                    </div>
                    <p class="font-bold">Siêu Khối</p>
                    <p class="text-sm text-gray-300">(Ghép 5 viên thẳng hàng)</p>
                </div>
             </div>
             <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Tiếp theo</button>
        </div>

        <!-- Step 3: Quái vật -->
        <div id="tutorial-step-3" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-red-500 mb-4">Mối Đe Dọa</h2>
            <div class="tutorial-icon text-5xl">🚬</div>
            <p class="text-lg mb-4"><strong>Quái vật thuốc lá</strong> sẽ di chuyển và cố gắng "ăn" những trái tim ở hàng trên cùng.</p>
            <p class="text-lg mb-6">Hãy ngăn chặn nó bằng cách hoàn thành <strong>mục tiêu</strong> ở bảng bên trái để qua màn!</p>
            <button id="play-from-tutorial-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform hover:scale-105">Bắt đầu chơi!</button>
        </div>
    </div>
</div>


<div id="custom-cursor"></div>
<div class="w-full max-w-7xl mx-auto flex flex-col md:flex-row items-center md:items-start justify-center gap-4 md:gap-8">

    <!-- Cột Trái (Tiêu đề & Mục Tiêu) -->
    <div class="w-full md:w-1/4 order-2 md:order-1">
        <div class="title-container text-center md:text-left mb-4">
            <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-2" id="game-title">Bảo Vệ Trái Tim</h1>
            <p class="text-gray-200 italic text-lg md:text-xl" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">Tiêu diệt quái vật thuốc lá!</p>
        </div>
        <div class="p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <h2 class="text-xl font-bold text-white/80 mb-2">Mục Tiêu</h2>
            <div class="health-bar-bg mb-4">
                <div class="health-bar" id="health-bar" style="width: 0%;"></div>
            </div>
            <div class="space-y-2" id="quest-list">
                <!-- Quest items will be generated by JS -->
            </div>
        </div>
    </div>

    <!-- Cột Giữa (Game) -->
    <div class="w-full max-w-md text-center order-1 md:order-2">
        <div class="relative" id="game-container">
            <div id="character-container">
                <div class="character-aura"></div>
                <!-- START: CẬP NHẬT SVG QUÁI VẬT -->
                <svg id="cigarette-svg" viewBox="0 0 200 100">
                    <defs>
                        <filter id="smokeFilter">
                            <feTurbulence type="fractalNoise" baseFrequency="0.02 0.05" numOctaves="3" result="turbulence" />
                            <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="15" xChannelSelector="R" yChannelSelector="G" />
                        </filter>
                        <filter id="emberGlow">
                            <feGaussianBlur stdDeviation="3.5" result="coloredBlur" />
                            <feMerge>
                                <feMergeNode in="coloredBlur" />
                                <feMergeNode in="SourceGraphic" />
                            </feMerge>
                        </filter>
                        <radialGradient id="paper-gradient">
                            <stop offset="0%" stop-color="#d2b48c" />
                            <stop offset="100%" stop-color="#c8a97e" />
                        </radialGradient>
                    </defs>
                    <path class="filter-shape" d="M160,30 L180,28 Q192,30 190,50 Q188,70 180,72 L160,70 Z" />
                    <path class="cigarette-body-shape" d="M20,30 L160,30 L160,70 L20,70 Q10,70 10,50 Q10,30 20,30 Z" />
                    <path class="stain" d="M110,40 C 120,35 130,45 125,55 C 120,60 110,55 110,40 Z" />
                    <path class="stain" d="M70,60 C 75,55 85,58 80,68 Z" />
                    <path class="crack" d="M140,45 C 145,50, 145,55, 150,60" />
                    <path class="crack" d="M100,35 C 105,45, 95,55, 100,65" />
                    <path class="crack" d="M40,35 L 45,65" />
                    <path class="crack" d="M155,35 L 158,65" />
                    <path class="ash-shape" d="M20,30 Q10,30 10,50 Q10,70 20,70 L30,70 Q25,50 30,30 Z" />
                    <path d="M28 40 L 32 38 M28 50 L 33 50 M28 60 L 32 62" stroke="#a0522d" stroke-width="1" />
                    <path class="ember-shape" d="M25,35 Q20,50 25,65 L20,65 Q15,50 20,35 Z" />
                    <g id="sparks">
                        <circle class="spark" cx="22" cy="40" r="1.5" style="animation-delay: 0s; --y-end: -20px;"></circle>
                        <circle class="spark" cx="20" cy="50" r="1" style="animation-delay: 0.5s; --y-end: 0px;"></circle>
                        <circle class="spark" cx="22" cy="60" r="1.5" style="animation-delay: 1s; --y-end: 20px;"></circle>
                    </g>
                    <g id="face">
                        <g id="eye1_group">
                            <circle class="eye-socket" cx="55" cy="50" r="12" />
                            <circle class="eye-ball" cx="55" cy="50" r="11" />
                            <path class="eye-vein" d="M50,50 C 52,47 55,47 57,50" />
                            <path class="eye-vein" d="M57,50 C 59,53 62,53 85,50" />
                            <circle class="eye-pupil" id="pupil1" cx="55" cy="50" r="5" />
                        </g>
                        <g id="eye2_group">
                            <circle class="eye-socket" cx="80" cy="50" r="12" />
                            <circle class="eye-ball" cx="80" cy="50" r="11" />
                            <path class="eye-vein" d="M75,50 C 77,47 80,47 82,50" />
                            <path class="eye-vein" d="M82,50 C 84,53 87,53 85,50" />
                            <circle class="eye-pupil" id="pupil2" cx="80" cy="50" r="5" />
                        </g>
                        <path class="mouth" id="mouth-path" d="M60 65 L 64 63 L 68 65 L 72 63 L 76 65" />
                    </g>
                </svg>
                <!-- END: CẬP NHẬT SVG QUÁI VẬT -->
                <div class="smoke-container">
                    <div class="smoke-wisp"></div>
                    <div class="smoke-wisp"></div>
                    <div class="smoke-wisp"></div>
                </div>
                <div id="threat-bubble"><p id="threat-text"></p></div>
                <div id="monster-name" class="text-center">
                    <p class="text-lg font-bold text-red-400" style="text-shadow: 0 0 8px rgba(255, 0, 0, 0.7);">Quái vật thuốc lá</p>
                </div>
            </div>
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>
    
    <!-- Cột Phải (Thông tin) -->
    <div class="w-full md:w-1/4 order-3 flex flex-row md:flex-col gap-4 md:gap-6">
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">Cấp Độ</p>
            <p class="text-4xl font-bold text-white" id="level">1</p>
        </div>
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">Nước đi</p>
            <p class="text-4xl font-bold text-white" id="moves">0</p>
        </div>
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">Trái tim đã cứu</p>
            <p class="text-4xl font-bold text-white" id="score">0</p>
        </div>
    </div>
</div>


<!-- Modal Chiến Thắng -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="winModal">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-green-600 mb-4">Qua Màn!</h2>
        <p class="text-lg text-gray-700 mb-6" id="win-level-text"></p>
        <button class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-300" id="nextLevelButton">Tiếp tục</button>
    </div>
</div>

<!-- Modal Game Over -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="gameOverModal">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-red-800 mb-4">Nguy hiểm!</h2>
        <p class="text-lg text-gray-700 mb-2">Thuốc lá đã làm hại một trái tim.</p>
        <p class="text-xl text-gray-800 mb-6">Bạn đã bảo vệ được <span class="font-bold text-pink-600" id="finalScore">0</span> trái tim.</p>
        <button class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-300" id="restartButton">Về Màn Hình Chính</button>
    </div>
</div>

<!-- Modal Thông điệp sức khỏe -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm" id="factModal">
    <div class="bg-white rounded-2xl p-6 md:p-8 text-center shadow-2xl transform transition-all scale-95 max-w-md w-full">
        <h2 class="text-2xl md:text-3xl font-bold text-blue-700 mb-4">Sự Thật & Lời Khuyên</h2>
        <p class="text-base md:text-lg text-gray-800 mb-3 text-left" id="factText"></p>
        <p class="text-base md:text-lg text-green-700 font-semibold mb-6 text-left" id="adviceText"></p>
        <button class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300" id="closeFactButton">Đã hiểu</button>
    </div>
</div>

<!-- Modal Chiến Thắng Cuối Cùng (ĐÃ CẬP NHẬT) -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="finalWinModal">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-yellow-500 mb-4">CHIẾN THẮNG!</h2>
        <p class="text-lg text-gray-700 mb-2">Bạn đã bảo vệ thành công những trái tim khỏi nanh vuốt của quái vật!</p>
        <p class="text-xl text-gray-800 mb-6">Cảm ơn bạn đã trở thành người hùng!</p>
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="restartGameButton">Chơi lại</button>
            <button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="backToIndexButton">Về màn hình chính</button>
            <button class="bg-yellow-500 text-white font-bold py-3 px-8 rounded-full hover:bg-yellow-600 transition-transform transform hover:scale-110 ring-4 ring-yellow-300 shadow-lg shadow-yellow-500/50" id="continueToNextGameButton">Tiếp tục</button>
        </div>
    </div>
</div>

<script>
// Sử dụng IIFE để tạo scope riêng, tránh biến toàn cục
(function() {
    'use strict';

    // --- Lấy các phần tử DOM ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const movesEl = document.getElementById('moves');
    const winModal = document.getElementById('winModal');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const winLevelText = document.getElementById('win-level-text');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');
    const factModal = document.getElementById('factModal');
    const factText = document.getElementById('factText');
    const adviceText = document.getElementById('adviceText');
    const closeFactButton = document.getElementById('closeFactButton');
    const healthBar = document.getElementById('health-bar');
    const questList = document.getElementById('quest-list');
    const startScreen = document.getElementById('start-screen');
    const customCursor = document.getElementById('custom-cursor');
    const tutorialModal = document.getElementById('tutorial-modal');
    const tutorialSteps = document.querySelectorAll('.tutorial-step');
    const tutorialNextBtns = document.querySelectorAll('.tutorial-next-btn');
    const playFromTutorialBtn = document.getElementById('play-from-tutorial-btn');
    const finalWinModal = document.getElementById('finalWinModal');
    const restartGameButton = document.getElementById('restartGameButton');
    const easyModeBtn = document.getElementById('easy-mode-btn');
    const hardModeBtn = document.getElementById('hard-mode-btn');
    const freeModeBtn = document.getElementById('free-mode-btn');
    const backToMenuBtn = document.getElementById('back-to-menu-btn');

    // --- DOM Elements cho nhân vật mới ---
    const characterContainerEl = document.getElementById('character-container');
    const threatBubble = document.getElementById('threat-bubble');
    const threatText = document.getElementById('threat-text');
    const mouth = document.getElementById('mouth-path');
    const pupil1 = document.getElementById('pupil1');
    const pupil2 = document.getElementById('pupil2');
    
    // --- Cấu hình game (Không còn "Magic Numbers") ---
    const CONFIG = {
        GRID_SIZE: 8,
        GEM_COLORS: ['#FF3131', '#00FF7F', '#1E90FF', '#FF00FF', '#FF8C00', '#FFFF00'],
        HEART_EMOJI: '💗',
        MOVES_PER_HEART_SPAWN: 3,
        CIGARETTE_LUNGE_CHANCE: 0.25,
        THREAT_INTERVAL: 6000,
        ANIM_SWAP_SPEED: 150,
        ANIM_FALL_SPEED: 400,
        ANIM_CLEAR_SPEED: 200,
        ANIM_SPECIAL_PULSE_SPEED: 150,
        MAX_PARTICLES: 150, 
        HINT_TIMEOUT: 5000,
        FINAL_LEVEL: 1 
    };

    const SPECIAL_TYPES = {
        NONE: 'none',
        H_BEAM: 'h_beam',
        V_BEAM: 'v_beam',
        BOMB: 'bomb',
        HYPERCUBE: 'hypercube'
    };
    
    // === AUDIO (Tone.js) – NHẠC NỀN ĐƠN GIẢN ===
    const AudioManager = {
      initialized: false,
      started: false,
      nodes: {},
      sfx: {},
      musicParts: {},

      setup() {
        if (this.initialized) return;

        // Master chain with volume control
        Tone.Destination.volume.value = -9; // Đặt âm lượng tổng thể
        const limiter = new Tone.Limiter(-1).toDestination();
        const comp = new Tone.Compressor(-24, 4).connect(limiter);
        
        const reverb = new Tone.Reverb({ decay: 1.5, wet: 0.2 }).connect(comp);
        const delay = new Tone.FeedbackDelay("16n", 0.25).connect(reverb);

        const melodySynth = new Tone.PolySynth(Tone.FMSynth, {
            harmonicity: 2,
            modulationIndex: 5,
            envelope: { attack: 0.01, decay: 0.2, release: 0.2 },
            modulationEnvelope: { attack: 0.01, decay: 0.1, release: 0.2 }
        }).connect(delay);
        melodySynth.volume.value = -15;

        const bassSynth = new Tone.MonoSynth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.3, release: 1 },
            filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.5, baseFrequency: 200, octaves: 2.6 }
        }).connect(comp);
        bassSynth.volume.value = -18;

        const melodyPattern = new Tone.Sequence((time, note) => {
            melodySynth.triggerAttackRelease(note, "16n", time);
        }, [
            "C5", null, "E5", "G5", 
            "E5", null, "C5", null,
            "D5", null, "F5", "A5",
            "F5", null, "D5", null
        ], "8n");

        const bassPattern = new Tone.Sequence((time, note) => {
            bassSynth.triggerAttackRelease(note, "2n", time);
        }, ["C3", "G3"], "1n");

        // === SFX (Hiệu ứng âm thanh) ===
        const clickSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.03 } }).connect(comp);
        const pluck = new Tone.PluckSynth().connect(comp);
        const noise = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.005, decay: 0.15, sustain: 0 } }).connect(new Tone.Filter(1200, "bandpass").connect(comp));
        const bombKick = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 3, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.2 } }).connect(comp);
        const fm = new Tone.FMSynth().connect(reverb);

        this.sfx = { clickSynth, pluck, noise, kick: bombKick, fm };
        this.musicParts = { melodyPattern, bassPattern };
        
        Tone.Transport.bpm.value = 140;
        this.initialized = true;
      },

      async start() {
        if (this.started) return;
        this.setup();

        await Tone.start();
        
        this.musicParts.melodyPattern.start(0);
        this.musicParts.bassPattern.start(0);

        Tone.Transport.start("+0.1");
        this.started = true;
      },

      stopBackground() {
        if (!this.initialized) return;
        this.musicParts.melodyPattern.stop();
        this.musicParts.bassPattern.stop();
      },

      resumeBackground() {
        if (!this.initialized || !this.started) return;
        this.musicParts.melodyPattern.start();
        this.musicParts.bassPattern.start();
      },

      setMasterVolume(db) {
        Tone.Destination.volume.rampTo(db, 0.2);
      },

      play(name, opts = {}) {
        if (!this.initialized || !this.started) return;

        switch (name) {
          case "selectSound":
            this.sfx.clickSynth.triggerAttackRelease("C5", "16n");
            break;

          case "matchSound": {
            const intensity = Math.min(1, Math.max(0.2, (opts.intensity || 3) / 6));
            this.sfx.pluck.triggerAttackRelease("E5", "8n", undefined, 0.4 + 0.4*intensity);
            break;
          }

          case "beamSound":
            this.sfx.noise.triggerAttack();
            break;

          case "bombSound":
            this.sfx.kick.triggerAttack("C2");
            break;

          case "hypercubeSound":
            this.sfx.fm.triggerAttackRelease("A4", "8n");
            break;
        }
      }
    };
    // Đề phòng chuyển tab
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        Tone.Transport.pause();
      } else if (AudioManager.started) {
        Tone.Transport.start();
      }
    });

    // --- Dữ liệu tuyên truyền ---
    const HEALTH_FACTS = [
        { fact: "Thuốc lá giết **hơn 7 triệu người/năm**, trong đó có khoảng **1,6 triệu người không hút thụ động**. (Nguồn: WHO)", advice: "Lời khuyên: Hãy tránh xa khói thuốc để bảo vệ bạn và những người xung quanh." },
        { fact: "Hút thuốc không thụ động (passive smoking) cũng gây ung thư phổi, bệnh tim và nhiều vấn đề sức khỏe nghiêm trọng. (Nguồn: CDC / IARC)", advice: "Lời khuyên: Đừng để khói thuốc xâm nhập không khí sống, giữ sạch môi trường cho phổi bạn." },
        { fact: "Hút thuốc gây tổn thương **gan, phổi, tim**, làm tăng nguy cơ mắc **COPD, nhồi máu cơ tim, đột quỵ** và nhiều loại ung thư. (Nguồn: CDC)", advice: "Lời khuyên: Mỗi hơi thuốc bạn hít vào là tổn hại cho cơ thể—ngưng ngay hôm nay để khỏe mạnh hơn." },
        { fact: "Hút thuốc gây ung thư ở **khoảng 20% các ca ung thư**, và khoảng **80% ca ung thư phổi** là do việc hút thuốc. (Nguồn: American Cancer Society)", advice: "Lời khuyên: Bỏ thuốc sẽ giúp giảm nguy cơ mắc nhiều loại ung thư — đó là cách bảo vệ tương lai của bạn." },
        { fact: "Hút thuốc có thể **rút ngắn tuổi thọ trung bình 10 năm** so với người không hút. (Nguồn: Wikipedia – WHO)", advice: "Lời khuyên: Chọn sống lâu hơn — nói không với thuốc lá hôm nay." },
        { fact: "Khói thuốc lá chứa hơn **7.000 hóa chất**, trong đó có **hơn 70 chất gây ung thư**. (Nguồn: FDA)", advice: "Lời khuyên: Cơ thể bạn không nên trở thành phòng thí nghiệm—hãy giữ phổi trong lành." },
        { fact: "Hút thuốc làm suy yếu hệ miễn dịch, làm cơ thể khó chống lại nhiễm trùng và có thể làm tổn thương miễn dịch kéo dài ngay cả sau khi bỏ thuốc. (Nguồn: Nature/CNN)", advice: "Lời khuyên: Hãy bảo vệ hệ miễn dịch của bạn—một lý do tuyệt vời để bỏ thuốc." },
        { fact: "Tiếp xúc với khói thuốc làm tăng nguy cơ ung thư vú ở phụ nữ trẻ lên tới **70%**. (Nguồn: IARC / Wikipedia)", advice: "Lời khuyên: Bảo vệ bản thân, bảo vệ sức khỏe—tránh khói thuốc thụ động." },
        { fact: "Hút thuốc làm giảm khả năng sinh sản—phụ nữ hút thuốc có nguy cơ vô sinh cao hơn **60%**, tăng nguy cơ sẩy thai và các vấn đề thai kỳ. (Nguồn: Wikipedia)", advice: "Lời khuyên: Hãy giữ sức khỏe sinh sản—nói không với thuốc lá để tương lai tươi sáng." },
        { fact: "Không có mức độ hút thuốc nào là an toàn — kể cả một điếu mỗi ngày cũng tăng nguy cơ bệnh tim và ung thư. (Nguồn: WHO)", advice: "Lời khuyên: Đừng tự đánh lừa—bỏ hẳn là cách an toàn duy nhất." },
    ];
    let factsShown = [];
    const THREATS = [
        "Ta nếm được nỗi sợ của ngươi.",
        "Mỗi tế bào của ngươi đang gào thét.",
        "Ta là cái chết chậm rãi ngươi tự chọn.",
        "Linh hồn ngươi... sẽ là làn khói tiếp theo.",
        "Không có lối thoát đâu."
    ];
    let threatInterval = null;

    // --- Biến trạng thái game ---
    let gemSize;
    let board = [];
    let selectedGem = null;
    let score = 0;
    let moves = 0;
    let isAnimating = false;
    let isPaused = false;
    let animations = [];
    let particles = [];
    let cigarette = { col: Math.floor(CONFIG.GRID_SIZE / 2), level: 1 };
    let currentLevel = 1;
    let quest = {};
    let startDragPos = { x: null, y: null };
    let startGem = null;
    let isDragging = false;
    let gemCache = {}; 
    let particlePool = [];
    let hintTimeout = null;
    let hintGems = [];
    let isFreePlayMode = false;

    // --- Hiển thị lời đe dọa của quái vật ---
    function showThreat() {
        if (isPaused || !gameOverModal.classList.contains('hidden') || characterContainerEl.classList.contains('attacking')) return;
        
        AudioManager.play('beamSound');
        threatText.textContent = THREATS[Math.floor(Math.random() * THREATS.length)];
        
        mouth.setAttribute('d', 'M58 68 L 64 60 L 70 68 L 76 60 L 82 68');
        characterContainerEl.classList.add('attacking');
        threatBubble.classList.add('visible');

        setTimeout(() => {
            threatBubble.classList.remove('visible');
            mouth.setAttribute('d', 'M60 65 L 64 63 L 68 65 L 72 63 L 76 65');
            characterContainerEl.classList.remove('attacking');
        }, 2000);
    }

    // --- Khởi tạo và Thiết lập Game ---
    function setupLevel(level) {
        currentLevel = level;
        levelEl.textContent = level;
        
        const baseRequirement = 15 + (level - 1) * 8;
        const numTargets = Math.min(2 + Math.floor(level / 2), 5);
        
        quest = {
            targets: {},
            collected: {},
            totalDamage: 0,
            maxDamage: 0,
            heartsToSave: level, 
            heartsSaved: 0
        };

        let availableColors = [...Array(CONFIG.GEM_COLORS.length).keys()];
        for(let i = 0; i < numTargets; i++) {
            if(availableColors.length === 0) break;
            const colorIndex = availableColors.splice(Math.floor(Math.random() * availableColors.length), 1)[0];
            const requirement = Math.floor(baseRequirement * (Math.random() * 0.4 + 0.8));
            quest.targets[colorIndex] = requirement;
            quest.collected[colorIndex] = 0;
            quest.maxDamage += requirement;
        }
        updateQuestUI();
        updateHealthBar();
    }

    function init() {
        resizeCanvas();
        
        ctx.font = `${gemSize * 0.7}px sans-serif`;

        cigarette.col = Math.floor(CONFIG.GRID_SIZE / 2);
        updateCigarettePosition();

        board = [];
        score = 0;
        moves = 0;
        selectedGem = null;
        isAnimating = false;
        isPaused = false;
        animations = [];
        
        particles = [];
        particlePool = [];
        for(let i = 0; i < CONFIG.MAX_PARTICLES; i++) {
            particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', alpha: 0 });
        }

        factsShown = [];
        
        if (threatInterval) clearInterval(threatInterval);
        threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL);

        updateScore();
        updateMoves();
        setupLevel(1);
        
        do {
            createBoard();
        } while(!hasPossibleMoves(board));

        spawnHeartIfNeeded(true);
        requestAnimationFrame(gameLoop);
        resetHintTimer();
    }
    
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        const containerWidth = container.clientWidth;
        const dpr = window.devicePixelRatio || 1;

        canvas.style.width = containerWidth + 'px';
        canvas.style.height = containerWidth + 'px';

        canvas.width = Math.floor(containerWidth * dpr);
        canvas.height = Math.floor(containerWidth * dpr);

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        gemSize = containerWidth / CONFIG.GRID_SIZE;
        
        preRenderGems(); 

        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if(board[r] && board[r][c]) {
                    board[r][c].x = c * gemSize;
                    board[r][c].y = r * gemSize;
                }
            }
        }
        updateCigarettePosition();
    }

    function createBoard() {
        board = [];
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            board[row] = [];
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                let possibleColors = [...Array(CONFIG.GEM_COLORS.length).keys()];
                
                if (col >= 2 && board[row][col-1].colorIndex === board[row][col-2].colorIndex) {
                    const colorToRemove = board[row][col-1].colorIndex;
                    possibleColors = possibleColors.filter(c => c !== colorToRemove);
                }

                if (row >= 2 && board[row-1][col].colorIndex === board[row-2][col].colorIndex) {
                    const colorToRemove = board[row-1][col].colorIndex;
                    possibleColors = possibleColors.filter(c => c !== colorToRemove);
                }

                const colorIndex = possibleColors[Math.floor(Math.random() * possibleColors.length)];

                board[row][col] = {
                    colorIndex: colorIndex,
                    isHeart: false,
                    special: SPECIAL_TYPES.NONE,
                    row: row,
                    col: col,
                    x: col * gemSize,
                    y: row * gemSize,
                    scale: 1,
                    alpha: 1,
                };
            }
        }
    }

    // --- Vòng lặp Game và Vẽ ---
    function gameLoop(time) {
        requestAnimationFrame(gameLoop);
        
        if (isPaused || !winModal.classList.contains('hidden') || !gameOverModal.classList.contains('hidden') || !finalWinModal.classList.contains('hidden')) {
            return;
        }
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        handleAnimations(time);
        drawBoard(time);
        drawParticles();
        drawSelection(time);
        drawHint(time);
    }

    async function preRenderGems() {
        gemCache = {};
        const promises = [];
        const specials = Object.values(SPECIAL_TYPES);
        const size = Math.max(1, Math.round(gemSize));

        CONFIG.GEM_COLORS.forEach((col) => {
            const canvas = renderGemCanvas(col, size);
            if ('createImageBitmap' in window) {
                promises.push(createImageBitmap(canvas).then(img => { gemCache[col] = img; }));
            } else {
                gemCache[col] = canvas;
            }
        });

        specials.forEach(special => {
            if (special === SPECIAL_TYPES.HYPERCUBE) {
                const canvas = renderHypercubeCanvas(size);
                 if ('createImageBitmap' in window) {
                    promises.push(createImageBitmap(canvas).then(img => { gemCache[special] = img; }));
                } else {
                    gemCache[special] = canvas;
                }
            } else if (special !== SPECIAL_TYPES.NONE) {
                CONFIG.GEM_COLORS.forEach((col, idx) => {
                    const canvas = renderSpecialCanvas(special, col, size);
                     if ('createImageBitmap' in window) {
                        promises.push(createImageBitmap(canvas).then(img => { gemCache[`${special}_${idx}`] = img; }));
                    } else {
                        gemCache[`${special}_${idx}`] = canvas;
                    }
                });
            }
        });
        await Promise.all(promises);
    }
    
    function renderGemCanvas(color, size) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = size;
        offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;
        
        offscreenCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
        offscreenCtx.shadowBlur = 5;
        offscreenCtx.shadowOffsetX = 2;
        offscreenCtx.shadowOffsetY = 2;

        const shadeColor = (col, percent) => {
            let f=parseInt(col.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
            return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
        };
        const lightColor = shadeColor(color, 0.6);
        const darkColor = shadeColor(color, -0.6);
        const grad = offscreenCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, half);
        grad.addColorStop(0, lightColor);
        grad.addColorStop(1, color);
        
        offscreenCtx.fillStyle = grad;
        offscreenCtx.beginPath();
        offscreenCtx.moveTo(centerX, centerY - half); 
        offscreenCtx.lineTo(centerX + half, centerY); 
        offscreenCtx.lineTo(centerX, centerY + half); 
        offscreenCtx.lineTo(centerX - half, centerY);
        offscreenCtx.closePath();
        offscreenCtx.fill();
        
        offscreenCtx.strokeStyle = darkColor;
        offscreenCtx.lineWidth = 2;
        offscreenCtx.stroke();

        return offscreenCanvas;
    }

    function renderSpecialCanvas(special, color, size) {
        const canvas = renderGemCanvas(color, size);
        const ctx = canvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;

        ctx.fillStyle = 'white';
        ctx.shadowColor = 'white';
        ctx.shadowBlur = 10;

        if(special === SPECIAL_TYPES.H_BEAM) {
            ctx.fillRect(centerX - half, centerY - half * 0.1, s, half * 0.2);
        } else if (special === SPECIAL_TYPES.V_BEAM) {
            ctx.fillRect(centerX - half * 0.1, centerY - half, half * 0.2, s);
        } else if (special === SPECIAL_TYPES.BOMB) {
            ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, half * 0.6, 0, 2 * Math.PI);
            ctx.fill();
        }
        return canvas;
    }

    function renderHypercubeCanvas(size) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = size;
        offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;

        offscreenCtx.shadowColor = 'rgba(255, 255, 255, 0.7)';
        offscreenCtx.shadowBlur = 10;

        for (let i = 0; i < 6; i++) {
            offscreenCtx.fillStyle = CONFIG.GEM_COLORS[i];
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(centerX,centerY);
            const angle1 = (i / 6) * 2 * Math.PI;
            const angle2 = ((i+1) / 6) * 2 * Math.PI;
            offscreenCtx.arc(centerX,centerY, half, angle1, angle2);
            offscreenCtx.closePath();
            offscreenCtx.fill();
        }
        return offscreenCanvas;
    }


    function drawBoard(time) {
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                const gem = board[row][col];
                if (gem) {
                    ctx.save();
                    ctx.globalAlpha = gem.alpha;
                    
                    const centerX = gem.x + gemSize / 2;
                    const centerY = gem.y + gemSize / 2;
                    ctx.translate(centerX, centerY);
                    ctx.scale(gem.scale, gem.scale);
                    ctx.translate(-centerX, -centerY);
                    
                    let cacheKey;
                    if (gem.special !== SPECIAL_TYPES.NONE && gem.special !== SPECIAL_TYPES.HYPERCUBE) {
                        cacheKey = `${gem.special}_${gem.colorIndex}`;
                    } else if (gem.special === SPECIAL_TYPES.HYPERCUBE) {
                        cacheKey = SPECIAL_TYPES.HYPERCUBE;
                    } else {
                        cacheKey = CONFIG.GEM_COLORS[gem.colorIndex];
                    }
                    const cachedGem = gemCache[cacheKey];

                    if (cachedGem) {
                        ctx.drawImage(cachedGem, gem.x, gem.y, gemSize, gemSize);
                    }
                    
                    if (gem.isHeart) {
                        const heartPulse = Math.sin(time / 300) * 0.1 + 1.1;
                        ctx.save();
                        ctx.translate(gem.x + gemSize / 2, gem.y + gemSize / 2);
                        ctx.scale(heartPulse, heartPulse);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = 'rgba(0,0,0,0)';
                        ctx.font = `${gemSize * 0.6}px sans-serif`;
                        ctx.fillText(CONFIG.HEART_EMOJI, 0, 0);
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }
        }
    }

    function drawHint(time) {
        if (hintGems.length === 2 && !isAnimating) {
            const gem1 = hintGems[0];
            const gem2 = hintGems[1];

            const pulse = (Math.sin(time / 200) + 1) / 2;
            const scale = 1 + 0.05 * pulse;

            if (gem1) {
                ctx.save();
                const centerX = gem1.x + gemSize / 2;
                const centerY = gem1.y + gemSize / 2;
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.translate(-centerX, -centerY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(gem1.x + 2, gem1.y + 2, gemSize - 4, gemSize - 4);
                ctx.restore();
            }

            if (gem2) {
                ctx.save();
                const centerX = gem2.x + gemSize / 2;
                const centerY = gem2.y + gemSize / 2;
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.translate(-centerX, -centerY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(gem2.x + 2, gem2.y + 2, gemSize - 4, gemSize - 4);
                ctx.restore();
            }
        }
    }
    
    function drawParticles() {
        for (let i = particlePool.length - 1; i >= 0; i--) {
            const p = particlePool[i];
            if (!p.active) continue;

            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= 0.02;

            if (p.alpha <= 0) {
                p.active = false;
            } else {
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
    }

    function getParticle() {
        for (let i = 0; i < particlePool.length; i++) {
            if (!particlePool[i].active) {
                return particlePool[i];
            }
        }
        return null;
    }
    
    function createParticleBurst(x, y, color) {
        for(let i=0; i<10; i++) {
            const p = getParticle();
            if (p) {
                p.active = true;
                p.x = x; p.y = y;
                p.vx = (Math.random() - 0.5) * 6;
                p.vy = (Math.random() - 0.5) * 6;
                p.size = Math.random() * 4 + 2;
                p.color = color;
                p.alpha = 1;
            }
        }
    }

    function drawSelection(time) {
        if (selectedGem) {
            const pulse = Math.sin(time / 100) * 0.5 + 0.5;
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
        }
    }

    function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    }

    function handlePointerStart(e) {
        e.preventDefault();
        if (isAnimating || isPaused) return;
        
        resetHintTimer();
        hintGems = [];

        const pos = getEventPos(e);
        const col = Math.floor(pos.x / gemSize);
        const row = Math.floor(pos.y / gemSize);

        if (row < 0 || row >= CONFIG.GRID_SIZE || col < 0 || col >= CONFIG.GRID_SIZE) {
            selectedGem = null;
            return;
        }
        
        const clickedGem = board[row][col];

        isDragging = true;
        startDragPos = pos;
        startGem = clickedGem;

        if (selectedGem) {
            if (selectedGem === clickedGem) {
                selectedGem = null;
                return;
            }

            const isAdjacent = Math.abs(selectedGem.row - clickedGem.row) + Math.abs(selectedGem.col - clickedGem.col) === 1;
            
            if (isAdjacent) {
                processSwap(selectedGem, clickedGem);
            } else {
                AudioManager.play('selectSound');
                selectedGem = clickedGem;
            }
        } else {
            AudioManager.play('selectSound');
            selectedGem = clickedGem;
        }
    }

    function handlePointerMove(e) {
        e.preventDefault();
        if (!isDragging || isAnimating || isPaused) return;
        
        const pos = getEventPos(e);
        const deltaX = pos.x - startDragPos.x;
        const deltaY = pos.y - startDragPos.y;
        
        if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) {
            let endGem = null;
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                const endCol = startGem.col + (deltaX > 0 ? 1 : -1);
                if (endCol >= 0 && endCol < CONFIG.GRID_SIZE) {
                    endGem = board[startGem.row][endCol];
                }
            } else {
                const endRow = startGem.row + (deltaY > 0 ? 1 : -1);
                 if (endRow >= 0 && endRow < CONFIG.GRID_SIZE) {
                    endGem = board[endRow][startGem.col];
                }
            }

            if (endGem && startGem !== endGem) {
                isDragging = false;
                selectedGem = null; 
                processSwap(startGem, endGem);
            }
        }
    }

    function handlePointerEnd(e) {
        isDragging = false;
        startGem = null;
    }

    // --- Logic Game Chính ---
    async function processSwap(gem1, gem2) {
        isAnimating = true;
        selectedGem = null;
        
        const startPos1 = { row: gem1.row, col: gem1.col };
        const startPos2 = { row: gem2.row, col: gem2.col };

        if (gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE) {
            moves++;
            updateMoves();
            const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
            const otherGem = hypercube === gem1 ? gem2 : gem1;
            await triggerHypercube(hypercube, otherGem);
        } else {
            await swapGems(gem1, gem2);
            const matchInfo = findMatchesAndSpecial(startPos1, startPos2);
            if (matchInfo.allMatches.length > 0) {
                moves++;
                updateMoves();
                await cascadeMatches(matchInfo.allMatches, matchInfo.specialToCreate);
            } else {
                await sleep(100);
                await swapGems(gem1, gem2);
            }
        }
        
        if (gameOverModal.classList.contains('hidden') && winModal.classList.contains('hidden') && finalWinModal.classList.contains('hidden')) {
            await moveCigarette();
            if (checkGameOver()) {
                isAnimating = false;
                return;
            }
            spawnHeartIfNeeded();
            checkWinCondition();
            if (!hasPossibleMoves(board)) {
                await reshuffleBoard();
            }
        }
        
        isAnimating = false;
        resetHintTimer();
    }

    function resetHintTimer() {
        if (hintTimeout) clearTimeout(hintTimeout);
        hintGems = [];
        hintTimeout = setTimeout(() => {
            if (!isAnimating && !isPaused) {
                const move = findFirstPossibleMove();
                if (move) {
                    hintGems = [move.gem1, move.gem2];
                }
            }
        }, CONFIG.HINT_TIMEOUT);
    }

    function findFirstPossibleMove() {
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if (c < CONFIG.GRID_SIZE - 1) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    [tempBoard[r][c], tempBoard[r][c+1]] = [tempBoard[r][c+1], tempBoard[r][c]];
                    if (findMatches(tempBoard).length > 0) {
                        return { gem1: board[r][c], gem2: board[r][c+1] };
                    }
                }
                if (r < CONFIG.GRID_SIZE - 1) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    [tempBoard[r][c], tempBoard[r+1][c]] = [tempBoard[r+1][c], tempBoard[r][c]];
                    if (findMatches(tempBoard).length > 0) {
                        return { gem1: board[r][c], gem2: board[r+1][c] };
                    }
                }
            }
        }
        return null;
    }

    function hasPossibleMoves(currentBoard) {
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE - 1; c++) {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                const tempGem1 = tempBoard[r][c];
                const tempGem2 = tempBoard[r][c+1];
                [tempBoard[r][c], tempBoard[r][c+1]] = [tempGem2, tempGem1];

                if (findMatches(tempBoard).length > 0) {
                    return true;
                }
            }
        }

        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            for (let r = 0; r < CONFIG.GRID_SIZE - 1; r++) {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                const tempGem1 = tempBoard[r][c];
                const tempGem2 = tempBoard[r+1][c];
                [tempBoard[r][c], tempBoard[r+1][c]] = [tempGem2, tempGem1];

                if (findMatches(tempBoard).length > 0) {
                    return true;
                }
            }
        }
        return false;
    }

    async function reshuffleBoard() {
        isAnimating = true;
        
        const promises = [];
        board.flat().forEach(gem => {
            if (gem) {
                promises.push(animate(gem, { alpha: 0, scale: 0 }, 300));
            }
        });
        await Promise.all(promises);
        
        do {
            createBoard();
        } while(!hasPossibleMoves(board));

        const refillPromises = [];
        board.flat().forEach(gem => {
            if (gem) {
                gem.alpha = 0; gem.scale = 0;
                refillPromises.push(animate(gem, { alpha: 1, scale: 1 }, 300));
            }
        });
        await Promise.all(refillPromises);

        isAnimating = false;
        resetHintTimer();
    }
    
    async function cascadeMatches(initialMatches, specialToCreate = null) {
        let gemsToClear = new Set(initialMatches);
        let processedSpecials = new Set();
        
        while(true) {
            let newGemsFromExplosion = new Set();
            let foundNewExplosion = false;
            for(const gem of gemsToClear) {
                if(gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                    foundNewExplosion = true;
                    processedSpecials.add(gem);
                    
                    switch(gem.special) {
                        case SPECIAL_TYPES.H_BEAM:
                        case SPECIAL_TYPES.V_BEAM:
                            AudioManager.play('beamSound');
                            break;
                        case SPECIAL_TYPES.BOMB:
                            AudioManager.play('bombSound');
                            break;
                    }

                    getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                }
            }
            if(!foundNewExplosion) break;
            newGemsFromExplosion.forEach(g => gemsToClear.add(g));
        }

        const savedAHeart = await handleMatches(Array.from(gemsToClear), specialToCreate);
        if (savedAHeart) {
            await showFact();
        }

        await sleep(150);
        await shiftAndRefill();
        
        const nextMatches = findMatches(board);
        if (nextMatches.length > 0) {
            await cascadeMatches(nextMatches);
        } else {
             await moveHearts();
        }
    }
    
    async function triggerHypercube(hypercube, otherGem) {
        let gemsToClear = new Set([hypercube]);
        AudioManager.play('hypercubeSound');
        
        if (otherGem.special === SPECIAL_TYPES.NONE) {
            const targetColorIndex = otherGem.colorIndex;
            board.flat().filter(g => g && g.colorIndex === targetColorIndex).forEach(g => gemsToClear.add(g));
        }
        else if (otherGem.special !== SPECIAL_TYPES.HYPERCUBE) {
             const targetColorIndex = otherGem.colorIndex;
             board.flat().filter(g => g && g.colorIndex === targetColorIndex).forEach(g => {
                g.special = otherGem.special;
                gemsToClear.add(g);
             });
        }
        else {
            board.flat().forEach(g => { if(g) gemsToClear.add(g) });
        }
        await cascadeMatches(Array.from(gemsToClear));
    }

    function getSpecialEffectGems(gem) {
        let affected = new Set();
        if (gem.special === SPECIAL_TYPES.H_BEAM) {
            for(let c=0; c<CONFIG.GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); }
        } else if (gem.special === SPECIAL_TYPES.V_BEAM) {
            for(let r=0; r<CONFIG.GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); }
        } else if (gem.special === SPECIAL_TYPES.BOMB) {
            for(let r = gem.row - 1; r <= gem.row + 1; r++) {
                for(let c = gem.col - 1; c <= gem.col + 1; c++) {
                    if(r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) {
                        affected.add(board[r][c]);
                    }
                }
            }
        }
        return affected;
    }

    function swapGems(gem1, gem2) {
        const r1 = gem1.row, c1 = gem1.col;
        const r2 = gem2.row, c2 = gem2.col;
        board[r1][c1] = gem2;
        board[r2][c2] = gem1;
        gem1.row = r2; gem1.col = c2;
        gem2.row = r1; gem2.col = c1;
        const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad);
        const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad);
        return Promise.all([p1, p2]);
    }
    
    function findMatches(currentBoard) {
        const matches = new Set();
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE - 2; c++) {
                const gem1 = currentBoard[r][c];
                if (!gem1) continue;
                const gem2 = currentBoard[r][c+1];
                const gem3 = currentBoard[r][c+2];
                if (gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                    matches.add(gem1); matches.add(gem2); matches.add(gem3);
                }
            }
        }
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            for (let r = 0; r < CONFIG.GRID_SIZE - 2; r++) {
                 const gem1 = currentBoard[r][c];
                 if (!gem1) continue;
                const gem2 = currentBoard[r+1][c];
                const gem3 = currentBoard[r+2][c];
                if (gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                    matches.add(gem1); matches.add(gem2); matches.add(gem3);
                }
            }
        }
        return Array.from(matches);
    }

    function findMatchesAndSpecial(startPos1, startPos2) {
      const allMatches = new Set();

      const checkLine = (line) => {
        const res = [];
        for (let i = 0; i < line.length - 2; i++) {
          const g = line[i];
          if (!g) continue;
          let len = 1;
          while (i + len < line.length && line[i + len] && line[i + len].colorIndex === g.colorIndex) len++;
          if (len >= 3) {
            res.push(line.slice(i, i + len));
            i += len - 1;
          }
        }
        return res;
      };

      const h1 = checkLine(board[startPos1.row] || []);
      const v1 = checkLine(board.map(r => r[startPos1.col]) || []);
      const h2 = checkLine(board[startPos2.row] || []);
      const v2 = checkLine(board.map(r => r[startPos2.col]) || []);

      const allFoundMatches = [...h1, ...v1, ...h2, ...v2];
      allFoundMatches.flat().forEach(g => allMatches.add(g));

      const gem1 = board[startPos1.row][startPos1.col];
      const gem2 = board[startPos2.row][startPos2.col];
      let movedGem = Array.from(allMatches).includes(gem1) ? gem1 : (Array.from(allMatches).includes(gem2) ? gem2 : null);

      let specialToCreate = null;
      if (movedGem) {
        let best = { len: 0, match: null, type: null };
        for (const m of allFoundMatches) {
          if (!m.includes(movedGem)) continue;
          const len = m.length;
          if (len >= 5) { best = { len, match: m, type: 'line5' }; break; }
          const isHorizontal = (m[0].row === m[1].row);
          const crossMatches = isHorizontal ? [...v1, ...v2] : [...h1, ...h2];
          const hasCross = crossMatches.some(cm => cm.includes(movedGem));
          if (hasCross) { best = { len: 5, match: m, type: 'cross' }; break; }
          if (len === 4 && best.len < 4) { best = { len: 4, match: m, type: isHorizontal ? 'h' : 'v' }; }
        }

        if (best.len > 0) {
          let special = SPECIAL_TYPES.NONE;
          if (best.type === 'line5') special = SPECIAL_TYPES.HYPERCUBE;
          else if (best.type === 'cross') special = SPECIAL_TYPES.BOMB;
          else if (best.type === 'h') special = SPECIAL_TYPES.H_BEAM;
          else if (best.type === 'v') special = SPECIAL_TYPES.V_BEAM;
          if (special !== SPECIAL_TYPES.NONE) {
            specialToCreate = { special, colorIndex: movedGem.colorIndex, row: movedGem.row, col: movedGem.col };
          }
        }
      }
      return { allMatches: Array.from(allMatches), specialToCreate };
    }
    
    async function handleMatches(matches, specialToCreate) {
        if (matches.length > 0) {
            AudioManager.play('matchSound', { intensity: matches.length });
        }

        const promises = [];
        let heartSaved = false;
        let collectedForQuest = {};

        matches.forEach(gem => {
            if(specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) return;
            
            if (gem.isHeart) { 
                score++; 
                quest.heartsSaved++;
                updateScore(); 
                heartSaved = true; 
            }
            
            const colorIdx = gem.colorIndex;
            if(quest.targets[colorIdx] !== undefined) {
                collectedForQuest[colorIdx] = (collectedForQuest[colorIdx] || 0) + 1;
            }

            createParticleBurst(gem.x + gemSize / 2, gem.y + gemSize / 2, CONFIG.GEM_COLORS[gem.colorIndex]);
            
            promises.push(new Promise(async (resolve) => {
                await animate(gem, { scale: 0, alpha: 0 }, CONFIG.ANIM_CLEAR_SPEED, easing.easeInQuad);
                if (board[gem.row]) {
                    board[gem.row][gem.col] = null;
                }
                resolve();
            }));
        });
        await Promise.all(promises);
        
        updateQuestProgress(collectedForQuest);
        updateQuestUI();

        if (specialToCreate) {
            const gem = board[specialToCreate.row][specialToCreate.col];
            if (gem) {
                gem.special = specialToCreate.special;
                if (specialToCreate.special !== SPECIAL_TYPES.HYPERCUBE) gem.colorIndex = specialToCreate.colorIndex;
                gem.isHeart = false;
                await animate(gem, {scale: 1.5}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad)
                    .then(() => animate(gem, {scale: 1}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad));
            }
        }
        return heartSaved;
    }

    async function shiftAndRefill() {
        const shiftPromises = [];
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            let emptySlots = 0;
            for (let r = CONFIG.GRID_SIZE - 1; r >= 0; r--) {
                if (board[r][c] === null) {
                    emptySlots++;
                } else if (emptySlots > 0) {
                    const gem = board[r][c];
                    board[r + emptySlots][c] = gem;
                    board[r][c] = null;
                    gem.row += emptySlots;
                    shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300, easing.easeOutQuad));
                }
            }
        }
        await Promise.all(shiftPromises);

        const refillPromises = [];
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
                if (board[r][c] === null) {
                    const newGem = {
                        colorIndex: Math.floor(Math.random() * CONFIG.GEM_COLORS.length),
                        isHeart: false, special: SPECIAL_TYPES.NONE,
                        row: r, col: c,
                        x: c * gemSize, y: (r - CONFIG.GRID_SIZE) * gemSize,
                        scale: 1, alpha: 1,
                    };
                    board[r][c] = newGem;
                    refillPromises.push(animate(newGem, { y: r * gemSize }, CONFIG.ANIM_FALL_SPEED, easing.easeOutQuad));
                }
            }
        }
        await Promise.all(refillPromises);
    }

    function spawnHeartIfNeeded(isFirst = false) {
         if (isFirst || (moves > 0 && moves % CONFIG.MOVES_PER_HEART_SPAWN === 0)) {
            let availableCols = [];
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if (board[CONFIG.GRID_SIZE - 1][c] && !board[CONFIG.GRID_SIZE - 1][c].isHeart && board[CONFIG.GRID_SIZE - 1][c].special === SPECIAL_TYPES.NONE) {
                    availableCols.push(c);
                }
            }
            if (availableCols.length > 0) {
                const col = availableCols[Math.floor(Math.random() * availableCols.length)];
                const gem = board[CONFIG.GRID_SIZE - 1][col];
                gem.isHeart = true;
                gem.special = SPECIAL_TYPES.NONE;
                animate(gem, {scale: 1.5}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad)
                    .then(() => animate(gem, {scale: 1}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad));
            }
        }
    }

    async function moveHearts() {
        const movePromises = [];
        let movedGems = new Set();

        for (let r = 1; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                const gem = board[r][c];
                if (gem && gem.isHeart && !movedGems.has(gem)) {
                    const gemAbove = board[r - 1][c];
                    if (gemAbove && !gemAbove.isHeart) {
                        board[r - 1][c] = gem;
                        board[r][c] = gemAbove;
                        
                        gem.row = r - 1;
                        gemAbove.row = r;
                        
                        movePromises.push(animate(gem, { y: gem.row * gemSize }, 200, easing.easeInOutQuad));
                        movePromises.push(animate(gemAbove, { y: gemAbove.row * gemSize }, 200, easing.easeInOutQuad));
                        
                        movedGems.add(gem);
                        movedGems.add(gemAbove);
                    }
                }
            }
        }
        await Promise.all(movePromises);
    }

    async function moveCigarette() {
        let highestHeart = null;
        let minRow = CONFIG.GRID_SIZE;

        board.flat().filter(g => g && g.isHeart).forEach(g => {
            if (g.row < minRow) {
                minRow = g.row;
                highestHeart = g;
            }
        });

        if (highestHeart) {
            if (Math.random() < CONFIG.CIGARETTE_LUNGE_CHANCE) {
                const originalCol = cigarette.col;
                const targetCol = highestHeart.col;
                
                updateCigarettePosition(targetCol, true);
                await sleep(150);
                updateCigarettePosition(originalCol);
                await sleep(400);
            }

            if (cigarette.col < highestHeart.col) cigarette.col++;
            else if (cigarette.col > highestHeart.col) cigarette.col--;
        }
        updateCigarettePosition();
    }

    function updateCigarettePosition(col = cigarette.col, isLunging = false) {
        const columnCenter = (col * gemSize) + (gemSize / 2);
        const svgScaledWidth = 200 * 0.7;
        const translateX = columnCenter - (svgScaledWidth / 2);

        let scale = 0.7;
        let rotate = 0;
        let translateY = 0;
        
        if (isLunging) {
            scale = 0.8;
            translateY = 10;
        } else if (characterContainerEl.classList.contains('attacking')) {
            scale = 0.8;
            rotate = -5;
        }

        characterContainerEl.style.transform = `translateX(${translateX}px) translateY(${translateY}px) scale(${scale}) rotate(${rotate}deg)`;
    }
    
    function checkGameOver() {
        if(board[0][cigarette.col] && board[0][cigarette.col].isHeart) {
            showGameOver();
            return true;
        }
        return false;
    }

    // --- Giao diện người dùng và Tiện ích ---
    function updateQuestUI() {
        questList.innerHTML = '';
        for (const colorIdx in quest.targets) {
            const remaining = Math.max(0, quest.targets[colorIdx] - quest.collected[colorIdx]);
            const isCompleted = remaining === 0;
            
            const item = document.createElement('div');
            item.className = `flex items-center justify-between p-2 rounded-lg transition-all ${isCompleted ? 'bg-green-500/30' : 'bg-black/20'}`;
            item.innerHTML = `
                <div class="w-6 h-6 rounded-full border-2 border-white/20" style="background-color: ${CONFIG.GEM_COLORS[colorIdx]}"></div>
                <span class="font-bold text-white">${remaining}</span>
            `;
            questList.appendChild(item);
        }
        const remainingHearts = Math.max(0, quest.heartsToSave - quest.heartsSaved);
        const heartsCompleted = remainingHearts === 0;
        const heartItem = document.createElement('div');
        heartItem.className = `flex items-center justify-between p-2 rounded-lg transition-all ${heartsCompleted ? 'bg-green-500/30' : 'bg-black/20'}`;
        heartItem.innerHTML = `
            <span class="text-2xl">${CONFIG.HEART_EMOJI}</span>
            <span class="font-bold text-white">${remainingHearts}</span>
        `;
        questList.appendChild(heartItem);
    }
    
    function updateHealthBar() {
        const progressPercent = quest.maxDamage > 0 ? Math.min(100, (quest.totalDamage / quest.maxDamage) * 100) : 0;
        healthBar.style.width = `${progressPercent}%`;
    }

    function updateQuestProgress(collected) {
        for (const key in collected) {
            const colorIdx = parseInt(key, 10);
            const amount = collected[key];
            if (!quest.targets.hasOwnProperty(colorIdx)) continue;

            const before = quest.collected[colorIdx] || 0;
            const remaining = Math.max(0, quest.targets[colorIdx] - before);
            const used = Math.min(remaining, amount);

            quest.collected[colorIdx] = before + used;
            quest.totalDamage += used;
        }
        updateHealthBar();
    }

    function updateScore() { scoreEl.textContent = score; }
    function updateMoves() { movesEl.textContent = moves; }

    function showGameOver() {
        AudioManager.setMasterVolume(-12);
        isAnimating = true;
        isPaused = true;
        if (threatInterval) clearInterval(threatInterval);
        finalScoreEl.textContent = score;
        gameOverModal.classList.remove('hidden');
        setTimeout(() => gameOverModal.querySelector('div').classList.add('scale-100'), 10);
    }

    function checkWinCondition() {
        if (quest.totalDamage >= quest.maxDamage && quest.heartsSaved >= quest.heartsToSave) {
            AudioManager.setMasterVolume(-12);
            isAnimating = true;
            isPaused = true;
            if (threatInterval) clearInterval(threatInterval);

            if (!isFreePlayMode && currentLevel >= CONFIG.FINAL_LEVEL) {
                finalWinModal.classList.remove('hidden');
                setTimeout(() => finalWinModal.querySelector('div').classList.add('scale-100'), 10);
            } else {
                winLevelText.textContent = `Bạn đã hoàn thành màn ${currentLevel}!`;
                winModal.classList.remove('hidden');
                setTimeout(() => winModal.querySelector('div').classList.add('scale-100'), 10);
            }
        }
    }

    async function showFact() {
        isPaused = true;
        let availableFacts = HEALTH_FACTS.filter(obj => !factsShown.includes(obj));
        if (availableFacts.length === 0) factsShown = [];
        const factObject = availableFacts.length > 0 ? availableFacts[Math.floor(Math.random() * availableFacts.length)] : HEALTH_FACTS[0];
        factsShown.push(factObject);
        factText.textContent = factObject.fact;
        adviceText.textContent = factObject.advice;
        factModal.classList.remove('hidden');
        
        return new Promise(resolve => {
            const listener = () => {
                factModal.classList.add('hidden');
                isPaused = false;
                resolve();
            };
            closeFactButton.addEventListener('click', listener, { once: true });
        });
    }

    function goToNextLevel() {
        AudioManager.setMasterVolume(0);
        isAnimating = false;
        isPaused = false;
        setupLevel(currentLevel + 1);
        
        do {
            createBoard();
        } while(!hasPossibleMoves(board));

        spawnHeartIfNeeded(true);
        if (threatInterval) clearInterval(threatInterval);
        threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL);
    }

    restartButton.addEventListener('click', () => {
        window.location.href = 'index.html';
    });

    nextLevelButton.addEventListener('click', () => {
        winModal.classList.add('hidden');
        winModal.querySelector('div').classList.remove('scale-100');
        goToNextLevel();
    });

    restartGameButton.addEventListener('click', () => {
        location.reload();
    });

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    
    // --- Hệ thống Animation ---
    const easing = {
        easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
        easeInQuad: t => t * t,
        easeOutQuad: t => t * (2 - t)
    };

    function animate(target, toProperties, duration, easeFunc = easing.easeInOutQuad) {
        return new Promise(resolve => {
            const startProps = {};
            const endProps = {};
            for (const key in toProperties) {
                const cur = typeof target[key] === 'number' && !isNaN(target[key]) ? target[key] : 0;
                startProps[key] = cur;
                endProps[key] = Number(toProperties[key]);
            }
            animations.push({
                target,
                startProperties: startProps,
                endProperties: endProps,
                duration,
                easeFunc,
                startTime: performance.now(),
                onComplete: resolve
            });
        });
    }

    function handleAnimations() {
        const now = performance.now();
        for (let i = animations.length - 1; i >= 0; i--) {
            const anim = animations[i];
            const elapsed = now - anim.startTime;
            const t = Math.min(elapsed / anim.duration, 1);
            const progress = anim.easeFunc(t);

            if (t >= 1) {
                for (const key in anim.endProperties) anim.target[key] = anim.endProperties[key];
                if (anim.onComplete) anim.onComplete();
                animations.splice(i, 1);
            } else {
                for (const key in anim.endProperties) {
                    const start = anim.startProperties[key];
                    const end = anim.endProperties[key];
                    anim.target[key] = start + (end - start) * progress;
                }
            }
        }
    }

    // --- Logic con trỏ và theo dõi mắt ---
    function trackPupil(pupilElement, e) {
        const svgRect = characterContainerEl.getBoundingClientRect();
        const pupilData = {
            cx: parseFloat(pupilElement.getAttribute('cx')),
            cy: parseFloat(pupilElement.getAttribute('cy'))
        };
        
        const pupilX = svgRect.left + (pupilData.cx / 200) * svgRect.width;
        const pupilY = svgRect.top + (pupilData.cy / 100) * svgRect.height;
        
        const angle = Math.atan2(e.clientY - pupilY, e.clientX - pupilX);
        const maxMove = 4;
        const moveX = Math.cos(angle) * maxMove;
        const moveY = Math.sin(angle) * maxMove;
        pupilElement.style.transform = `translate(${moveX}px, ${moveY}px)`;
    }
    
    // --- Logic Toàn màn hình ---
    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    function updateFullscreenIcons() {
        const fullscreenIconOpen = document.getElementById('fullscreen-icon-open');
        const fullscreenIconClose = document.getElementById('fullscreen-icon-close');
        if (document.fullscreenElement) {
            fullscreenIconOpen.classList.add('hidden');
            fullscreenIconClose.classList.remove('hidden');
        } else {
            fullscreenIconOpen.classList.remove('hidden');
            fullscreenIconClose.classList.add('hidden');
        }
    }
    
    // --- KHỞI CHẠY GAME ---
    window.addEventListener('DOMContentLoaded', () => {
        let currentTutorialStep = 0;

        const backToIndexButton = document.getElementById('backToIndexButton');
        const continueToNextGameButton = document.getElementById('continueToNextGameButton');
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', toggleFullScreen);
            document.addEventListener('fullscreenchange', updateFullscreenIcons);
        }

        if (backToIndexButton) {
            backToIndexButton.addEventListener('click', () => {
                window.location.href = 'index.html';
            });
        }

        if (continueToNextGameButton) {
            continueToNextGameButton.addEventListener('click', () => {
                window.location.href = 'kimcuongquatraloicauhoi.html';
            });
        }

        function showTutorialStep(index) {
            tutorialSteps.forEach((step, i) => {
                step.classList.toggle('hidden', i !== index);
            });
        }

        function startGame(finalLevel, isFree) {
            CONFIG.FINAL_LEVEL = finalLevel;
            isFreePlayMode = isFree;
            startScreen.style.display = 'none';
            tutorialModal.classList.remove('hidden');
            showTutorialStep(0);
        }

        easyModeBtn.addEventListener('click', () => startGame(1, false));
        hardModeBtn.addEventListener('click', () => startGame(3, false));
        freeModeBtn.addEventListener('click', () => startGame(Infinity, true));

        const isTouch = window.matchMedia('(pointer: coarse)').matches;
        if (isTouch) {
            document.body.style.cursor = 'auto';
            customCursor.style.display = 'none';
            canvas.style.cursor = 'auto';
        } else {
            document.body.style.cursor = 'none';
            customCursor.style.display = 'block';
            canvas.style.cursor = 'none';
            
            let rafScheduled = false;
            let lastMouseEvent = null;
            document.addEventListener('mousemove', (e) => {
                lastMouseEvent = e;
                if (!rafScheduled) {
                    rafScheduled = true;
                    requestAnimationFrame(() => {
                        if (lastMouseEvent) {
                            customCursor.style.left = lastMouseEvent.clientX + 'px';
                            customCursor.style.top = lastMouseEvent.clientY + 'px';
                            if (startScreen.style.display === 'none') {
                                trackPupil(pupil1, lastMouseEvent);
                                trackPupil(pupil2, lastMouseEvent);
                            }
                        }
                        rafScheduled = false;
                    });
                }
            });
        }

        tutorialNextBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                currentTutorialStep++;
                if (currentTutorialStep < tutorialSteps.length) {
                    showTutorialStep(currentTutorialStep);
                }
            });
        });

        playFromTutorialBtn.addEventListener('click', async () => {
            tutorialModal.classList.add('hidden');
            backToMenuBtn.classList.remove('hidden'); 
            
            await AudioManager.start();
            init();

            canvas.addEventListener('pointerdown', handlePointerStart);
            canvas.addEventListener('pointermove', handlePointerMove);
            canvas.addEventListener('pointerup', handlePointerEnd);
            canvas.addEventListener('pointercancel', handlePointerEnd);
            
            canvas.addEventListener('touchstart', handlePointerStart, { passive: false });
            canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
            canvas.addEventListener('touchend', handlePointerEnd);
            canvas.addEventListener('touchcancel', handlePointerEnd);

            window.addEventListener('resize', resizeCanvas);
        });

        backToMenuBtn.addEventListener('click', () => {
            window.location.href = 'index.html';
        });
    });

    window.addEventListener('beforeunload', () => {
        if (threatInterval) clearInterval(threatInterval);
        if (hintTimeout) clearTimeout(hintTimeout);
    });

})(); // Kết thúc IIFE
</script>
</body>
</html>
