<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"/>
    <title>Game Kim C∆∞∆°ng: B·∫£o V·ªá Tr√°i Tim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            touch-action: none;
            overflow: hidden;
            animation: vignette-pulse 8s infinite alternate ease-in-out;
            /* cursor is set by JS */
        }
        @keyframes vignette-pulse {
            from { background: radial-gradient(ellipse at center, #1a1111 50%, #000000 100%); }
            to { background: radial-gradient(ellipse at center, #110a0a 40%, #000000 100%); }
        }
        canvas {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            /* cursor is set by JS */
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        #character-container {
            position: absolute;
            top: -95px; /* ƒêi·ªÅu ch·ªânh v·ªã tr√≠ ƒë·ªÉ ph√π h·ª£p v·ªõi k√≠ch th∆∞·ªõc m·ªõi */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
            z-index: 20;
        }
        .character-aura {
            position: absolute;
            width: 250px;
            height: 150px;
            background: radial-gradient(ellipse at center, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0) 70%);
            border-radius: 50%;
            animation: aura-pulse 4s infinite alternate ease-in-out;
            z-index: -1;
        }
        @keyframes aura-pulse {
            from { transform: scale(1); opacity: 0.7; }
            to { transform: scale(1.2); opacity: 0.4; }
        }
        #cigarette-svg {
            width: 240px; 
            height: 120px; 
            filter: drop-shadow(0 5px 20px rgba(0, 0, 0, 0.8));
            animation: idle-spasm 6s ease-in-out infinite;
            transition: transform 0.3s ease;
        }
        @keyframes idle-spasm {
            0%, 100% { transform: translate(0, 0) rotate(0); }
            10% { transform: translate(-2px, 2px) rotate(-1deg); }
            20% { transform: translate(2px, -2px) rotate(1deg); }
            30% { transform: translate(-3px, 0px) rotate(-1.5deg); }
            40% { transform: translate(3px, 1px) rotate(1.5deg); }
            50% { transform: translate(0, 0) rotate(0); }
            70% { transform: translate(0, 0) rotate(0); }
            72% { transform: translate(5px, -5px) rotate(3deg); }
            74% { transform: translate(0, 0) rotate(0); }
        }
        .cigarette-body-shape { fill: url(#paper-gradient); }
        .filter-shape { fill: #6b3520; }
        .ash-shape { fill: #333; }
        .ember-shape { fill: #ff4500; filter: url(#emberGlow); animation: ember-flicker 1.5s infinite alternate; }
        @keyframes ember-flicker {
            from { opacity: 0.9; }
            to { opacity: 1; }
        }
        .eye-socket { fill: #1a0000; }
        .eye-ball { fill: #dc143c; }
        .eye-pupil { fill: #000; transition: transform 0.1s linear; }
        .eye-vein { stroke: #8b0000; stroke-width: 0.5; fill: none; }
        .mouth { fill: #1a1a1a; transition: d 0.3s ease-in-out; }
        .crack { fill: none; stroke: #4e2a1d; stroke-width: 1.2; }
        .stain { fill: #704214; opacity: 0.6; }
        .spark { fill: #ffdd00; animation: spark-fly 1.5s infinite linear; }
        @keyframes spark-fly {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(-30px, var(--y-end)) scale(0); opacity: 0; }
        }
        .smoke-container { position: absolute; left: -120px; top: 50%; transform: translateY(-50%); width: 200px; height: 200px; pointer-events: none; filter: url(#smokeFilter); }
        .smoke-wisp {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: wisp-rise 12s infinite linear;
            opacity: 0;
        }
        @keyframes wisp-rise {
            0% { transform: translate(0, 0) scale(0.5); opacity: 0; }
            15% { opacity: 0.8; }
            100% { transform: translate(-120px, var(--y-end)) scale(2.5); opacity: 0; }
        }
        .smoke-wisp:nth-child(1) { width: 60px; height: 60px; animation-delay: 0s; --y-end: -80px; }
        .smoke-wisp:nth-child(2) { width: 80px; height: 80px; animation-delay: 4s; --y-end: 50px; }
        .smoke-wisp:nth-child(3) { width: 50px; height: 50px; animation-delay: 8s; --y-end: -20px; }
        #threat-bubble {
            position: absolute; bottom: 100%; left: 50%; margin-bottom: 10px; background-color: #110d0d; color: #ff4500;
            padding: 15px 22px; border-radius: 12px; border: 2px solid #ff4500; font-size: 1.3rem; font-family: 'Metal Mania', cursive;
            letter-spacing: 1px; opacity: 0; transform: translateY(20px) scale(0.9) translateX(-50%);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); white-space: nowrap; box-shadow: 0 0 25px rgba(255, 69, 0, 0.7);
        }
        #threat-bubble.visible { opacity: 1; transform: translateY(0) scale(1) translateX(-50%); }

        #monster-name {
            position: absolute;
            top: 50%;
            left: 230px; /* ƒêi·ªÅu ch·ªânh v·ªã tr√≠ cho ph√π h·ª£p */
            transform: translateY(-50%);
            white-space: nowrap;
        }

        #game-title { animation: sparkle 5s infinite linear; }
        @keyframes sparkle {
            0% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); }
            50% { text-shadow: 2px 2px 8px rgba(236, 72, 153, 0.5); }
            100% { text-shadow: 1px 1px 3px rgba(236, 72, 153, 0.2); }
        }
        .health-bar-bg {
            background-color: rgba(0,0,0,0.3);
            border-radius: 9999px;
            padding: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .health-bar {
            background: linear-gradient(to right, #ef4444, #f87171);
            height: 16px;
            border-radius: 9999px;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px #ef4444;
        }
        #custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #ff4500;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 9999;
            transition: transform 0.1s ease-out;
            /* display is set by JS */
        }
        /* M√†n h√¨nh ch·ªù */
        #start-screen {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            padding: 1rem;
        }
        
        .tutorial-icon {
            height: 60px;
            margin: 0 auto 0.5rem auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tutorial-gem-container {
            width: 50px;
            height: 50px;
            position: relative;
        }
        .tutorial-gem {
            width: 100%;
            height: 100%;
            transform: rotate(45deg);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.4), inset -2px -2px 5px rgba(0,0,0,0.3);
        }
        .tutorial-gem-bomb {
            background: radial-gradient(circle, #6bb5ff, #1E90FF);
        }
        .tutorial-gem-bomb::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60%;
            height: 60%;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px white;
        }
        .tutorial-gem-beam {
            background: radial-gradient(circle, #ff7b7b, #FF3131);
        }
        .tutorial-gem-beam::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 25%;
            background-color: white;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px white;
        }
        .tutorial-gem-hypercube {
            background: conic-gradient(from 0deg, #FF3131, #FFFF00, #00FF7F, #1E90FF, #FF00FF, #FF8C00, #FF3131);
            animation: spin 4s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(45deg); }
            to { transform: rotate(405deg); }
        }

        .gem-hint {
            animation: hint-pulse 1s infinite;
        }
        @keyframes hint-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* --- GIAO DI·ªÜN N√öT M·ªöI --- */
        .ui-button {
            position: fixed;
            z-index: 101; /* Above start screen */
            width: 44px;
            height: 44px;
            background: rgba(10, 20, 30, 0.5);
            border: 1px solid rgba(236, 72, 153, 0.3);
            border-radius: 50%;
            color: rgba(236, 72, 153, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.2), inset 0 0 5px rgba(236, 72, 153, 0.1);
        }
        .ui-button:hover {
            background: rgba(20, 40, 60, 0.7);
            color: white;
            border-color: rgba(236, 72, 153, 0.8);
            box-shadow: 0 0 25px rgba(236, 72, 153, 0.5), inset 0 0 10px rgba(236, 72, 153, 0.2);
            transform: scale(1.1);
        }
        #fullscreen-btn {
            top: 1rem;
            right: 1rem;
        }
        #back-to-menu-btn {
            bottom: 1rem;
            right: 1rem;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-700 via-gray-800 to-gray-900 flex items-end justify-center min-h-screen p-4">

<!-- N√∫t To√†n m√†n h√¨nh -->
<button id="fullscreen-btn" class="ui-button" title="To√†n m√†n h√¨nh">
    <svg id="fullscreen-icon-open" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
    <svg id="fullscreen-icon-close" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
</button>

<!-- N√∫t V·ªÅ m√†n h√¨nh ch√≠nh -->
<button id="back-to-menu-btn" class="ui-button hidden" title="V·ªÅ m√†n h√¨nh ch√≠nh">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
</button>

<!-- M√†n h√¨nh ch·ªù -->
<div id="start-screen">
    <h1 class="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-4" id="game-title-start">B·∫£o V·ªá Tr√°i Tim</h1>
    <p class="text-gray-200 italic text-xl md:text-2xl mb-8 max-w-2xl">Qu√°i v·∫≠t thu·ªëc l√° ƒëang ƒë·∫øn g·∫ßn. H√£y d√πng tr√≠ tu·ªá c·ªßa b·∫°n ƒë·ªÉ gh√©p c√°c vi√™n kim c∆∞∆°ng, c·ª©u l·∫•y nh·ªØng tr√°i tim v√† ƒë·∫©y l√πi m·ªëi ƒëe d·ªça!</p>
    <div class="flex flex-col sm:flex-row gap-4">
        <button id="easy-mode-btn" class="bg-green-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">D·ªÖ (1 M√†n)</button>
        <button id="hard-mode-btn" class="bg-red-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">Kh√≥ (3 M√†n)</button>
        <button id="free-mode-btn" class="bg-blue-600 text-white font-bold py-4 px-10 rounded-full text-2xl hover:scale-105 transition-transform">T·ª± Do</button>
    </div>
</div>

<!-- Modal H∆∞·ªõng d·∫´n ch∆°i -->
<div id="tutorial-modal" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm">
    <div class="bg-gray-800 border border-gray-700 rounded-2xl p-6 md:p-8 shadow-2xl max-w-md w-full text-white text-center">
        <!-- Step 1: Tr√°i Tim -->
        <div id="tutorial-step-1" class="tutorial-step">
            <h2 class="text-3xl font-bold text-pink-400 mb-4">M·ª•c Ti√™u: C·ª©u Tr√°i Tim!</h2>
            <div class="tutorial-icon text-5xl">üíó</div>
            <p class="text-lg mb-4">M·ªói v√†i n∆∞·ªõc ƒëi, m·ªôt vi√™n kim c∆∞∆°ng <strong>Tr√°i Tim</strong> s·∫Ω xu·∫•t hi·ªán ·ªü h√†ng d∆∞·ªõi c√πng.</p>
            <p class="text-lg mb-6">H√£y ƒë∆∞a n√≥ l√™n <strong>h√†ng tr√™n c√πng</strong> ƒë·ªÉ c·ª©u tr√°i tim v√† ghi ƒëi·ªÉm. ƒê·ª´ng ƒë·ªÉ qu√°i v·∫≠t thu·ªëc l√° ch·∫°m t·ªõi!</p>
            <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Ti·∫øp theo</button>
        </div>

        <!-- Step 2: Kim c∆∞∆°ng ƒë·∫∑c bi·ªát -->
        <div id="tutorial-step-2" class="tutorial-step hidden">
             <h2 class="text-3xl font-bold text-yellow-400 mb-4">S·ª©c M·∫°nh ƒê·∫∑c Bi·ªát</h2>
             <p class="text-lg mb-4">Gh√©p 4 ho·∫∑c 5 vi√™n kim c∆∞∆°ng ƒë·ªÉ t·∫°o ra c√°c lo·∫°i ƒë·∫∑c bi·ªát:</p>
             <div class="flex justify-around items-start text-center mb-6 space-x-2">
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-bomb"></div>
                        </div>
                    </div>
                    <p class="font-bold">Bom</p>
                    <p class="text-sm text-gray-300">(Gh√©p 5 vi√™n h√¨nh ch·ªØ L ho·∫∑c T)</p>
                </div>
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-beam"></div>
                        </div>
                    </div>
                    <p class="font-bold">Tia S√°ng</p>
                    <p class="text-sm text-gray-300">(Gh√©p 4 vi√™n)</p>
                </div>
                <div class="flex-1">
                    <div class="tutorial-icon">
                        <div class="tutorial-gem-container">
                            <div class="tutorial-gem tutorial-gem-hypercube"></div>
                        </div>
                    </div>
                    <p class="font-bold">Si√™u Kh·ªëi</p>
                    <p class="text-sm text-gray-300">(Gh√©p 5 vi√™n th·∫≥ng h√†ng)</p>
                </div>
             </div>
             <button class="tutorial-next-btn bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform hover:scale-105">Ti·∫øp theo</button>
        </div>

        <!-- Step 3: Qu√°i v·∫≠t -->
        <div id="tutorial-step-3" class="tutorial-step hidden">
            <h2 class="text-3xl font-bold text-red-500 mb-4">M·ªëi ƒêe D·ªça</h2>
            <div class="tutorial-icon text-5xl">üö¨</div>
            <p class="text-lg mb-4"><strong>Qu√°i v·∫≠t thu·ªëc l√°</strong> s·∫Ω di chuy·ªÉn v√† c·ªë g·∫Øng "ƒÉn" nh·ªØng tr√°i tim ·ªü h√†ng tr√™n c√πng.</p>
            <p class="text-lg mb-6">H√£y ngƒÉn ch·∫∑n n√≥ b·∫±ng c√°ch ho√†n th√†nh <strong>m·ª•c ti√™u</strong> ·ªü b·∫£ng b√™n tr√°i ƒë·ªÉ qua m√†n!</p>
            <button id="play-from-tutorial-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform hover:scale-105">B·∫Øt ƒë·∫ßu ch∆°i!</button>
        </div>
    </div>
</div>


<div id="custom-cursor"></div>
<div class="w-full max-w-7xl mx-auto flex flex-col md:flex-row items-center md:items-start justify-center gap-4 md:gap-8">

    <!-- C·ªôt Tr√°i (Ti√™u ƒë·ªÅ & M·ª•c Ti√™u) -->
    <div class="w-full md:w-1/4 order-2 md:order-1">
        <div class="title-container text-center md:text-left mb-4">
            <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-300 via-white to-pink-400 mb-2" id="game-title">B·∫£o V·ªá Tr√°i Tim</h1>
            <p class="text-gray-200 italic text-lg md:text-xl" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">Ti√™u di·ªát qu√°i v·∫≠t thu·ªëc l√°!</p>
        </div>
        <div class="p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <h2 class="text-xl font-bold text-white/80 mb-2">M·ª•c Ti√™u</h2>
            <div class="health-bar-bg mb-4">
                <div class="health-bar" id="health-bar" style="width: 0%;"></div>
            </div>
            <div class="space-y-2" id="quest-list">
                <!-- Quest items will be generated by JS -->
            </div>
        </div>
    </div>

    <!-- C·ªôt Gi·ªØa (Game) -->
    <div class="w-full max-w-md text-center order-1 md:order-2">
        <div class="relative" id="game-container">
            <div id="character-container">
                <div class="character-aura"></div>
                <!-- START: C·∫¨P NH·∫¨T SVG QU√ÅI V·∫¨T -->
                <svg id="cigarette-svg" viewBox="0 0 200 100">
                    <defs>
                        <filter id="smokeFilter">
                            <feTurbulence type="fractalNoise" baseFrequency="0.02 0.05" numOctaves="3" result="turbulence" />
                            <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="15" xChannelSelector="R" yChannelSelector="G" />
                        </filter>
                        <filter id="emberGlow">
                            <feGaussianBlur stdDeviation="3.5" result="coloredBlur" />
                            <feMerge>
                                <feMergeNode in="coloredBlur" />
                                <feMergeNode in="SourceGraphic" />
                            </feMerge>
                        </filter>
                        <radialGradient id="paper-gradient">
                            <stop offset="0%" stop-color="#d2b48c" />
                            <stop offset="100%" stop-color="#c8a97e" />
                        </radialGradient>
                    </defs>
                    <path class="filter-shape" d="M160,30 L180,28 Q192,30 190,50 Q188,70 180,72 L160,70 Z" />
                    <path class="cigarette-body-shape" d="M20,30 L160,30 L160,70 L20,70 Q10,70 10,50 Q10,30 20,30 Z" />
                    <path class="stain" d="M110,40 C 120,35 130,45 125,55 C 120,60 110,55 110,40 Z" />
                    <path class="stain" d="M70,60 C 75,55 85,58 80,68 Z" />
                    <path class="crack" d="M140,45 C 145,50, 145,55, 150,60" />
                    <path class="crack" d="M100,35 C 105,45, 95,55, 100,65" />
                    <path class="crack" d="M40,35 L 45,65" />
                    <path class="crack" d="M155,35 L 158,65" />
                    <path class="ash-shape" d="M20,30 Q10,30 10,50 Q10,70 20,70 L30,70 Q25,50 30,30 Z" />
                    <path d="M28 40 L 32 38 M28 50 L 33 50 M28 60 L 32 62" stroke="#a0522d" stroke-width="1" />
                    <path class="ember-shape" d="M25,35 Q20,50 25,65 L20,65 Q15,50 20,35 Z" />
                    <g id="sparks">
                        <circle class="spark" cx="22" cy="40" r="1.5" style="animation-delay: 0s; --y-end: -20px;"></circle>
                        <circle class="spark" cx="20" cy="50" r="1" style="animation-delay: 0.5s; --y-end: 0px;"></circle>
                        <circle class="spark" cx="22" cy="60" r="1.5" style="animation-delay: 1s; --y-end: 20px;"></circle>
                    </g>
                    <g id="face">
                        <g id="eye1_group">
                            <circle class="eye-socket" cx="55" cy="50" r="12" />
                            <circle class="eye-ball" cx="55" cy="50" r="11" />
                            <path class="eye-vein" d="M50,50 C 52,47 55,47 57,50" />
                            <path class="eye-vein" d="M57,50 C 59,53 62,53 85,50" />
                            <circle class="eye-pupil" id="pupil1" cx="55" cy="50" r="5" />
                        </g>
                        <g id="eye2_group">
                            <circle class="eye-socket" cx="80" cy="50" r="12" />
                            <circle class="eye-ball" cx="80" cy="50" r="11" />
                            <path class="eye-vein" d="M75,50 C 77,47 80,47 82,50" />
                            <path class="eye-vein" d="M82,50 C 84,53 87,53 85,50" />
                            <circle class="eye-pupil" id="pupil2" cx="80" cy="50" r="5" />
                        </g>
                        <path class="mouth" id="mouth-path" d="M60 65 L 64 63 L 68 65 L 72 63 L 76 65" />
                    </g>
                </svg>
                <!-- END: C·∫¨P NH·∫¨T SVG QU√ÅI V·∫¨T -->
                <div class="smoke-container">
                    <div class="smoke-wisp"></div>
                    <div class="smoke-wisp"></div>
                    <div class="smoke-wisp"></div>
                </div>
                <div id="threat-bubble"><p id="threat-text"></p></div>
                <div id="monster-name" class="text-center">
                    <p class="text-lg font-bold text-red-400" style="text-shadow: 0 0 8px rgba(255, 0, 0, 0.7);">Qu√°i v·∫≠t thu·ªëc l√°</p>
                </div>
            </div>
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>
    
    <!-- C·ªôt Ph·∫£i (Th√¥ng tin) -->
    <div class="w-full md:w-1/4 order-3 flex flex-row md:flex-col gap-4 md:gap-6">
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">C·∫•p ƒê·ªô</p>
            <p class="text-4xl font-bold text-white" id="level">1</p>
        </div>
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">N∆∞·ªõc ƒëi</p>
            <p class="text-4xl font-bold text-white" id="moves">0</p>
        </div>
        <div class="flex-1 p-4 bg-black/20 rounded-2xl shadow-lg text-center backdrop-blur-sm border border-white/10">
            <p class="text-lg font-bold text-white/70">Tr√°i tim ƒë√£ c·ª©u</p>
            <p class="text-4xl font-bold text-white" id="score">0</p>
        </div>
    </div>
</div>


<!-- Modal Chi·∫øn Th·∫Øng -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="winModal">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-green-600 mb-4">Qua M√†n!</h2>
        <p class="text-lg text-gray-700 mb-6" id="win-level-text"></p>
        <button class="bg-green-600 text-white font-bold py-3 px-8 rounded-full hover:bg-green-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-300" id="nextLevelButton">Ti·∫øp t·ª•c</button>
    </div>
</div>

<!-- Modal Game Over -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="gameOverModal">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-red-800 mb-4">Nguy hi·ªÉm!</h2>
        <p class="text-lg text-gray-700 mb-2">Thu·ªëc l√° ƒë√£ l√†m h·∫°i m·ªôt tr√°i tim.</p>
        <p class="text-xl text-gray-800 mb-6">B·∫°n ƒë√£ b·∫£o v·ªá ƒë∆∞·ª£c <span class="font-bold text-pink-600" id="finalScore">0</span> tr√°i tim.</p>
        <button class="bg-red-600 text-white font-bold py-3 px-8 rounded-full hover:bg-red-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-300" id="restartButton">V·ªÅ M√†n H√¨nh Ch√≠nh</button>
    </div>
</div>

<!-- Modal Th√¥ng ƒëi·ªáp s·ª©c kh·ªèe -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 backdrop-blur-sm" id="factModal">
    <div class="bg-white rounded-2xl p-6 md:p-8 text-center shadow-2xl transform transition-all scale-95 max-w-md w-full">
        <h2 class="text-2xl md:text-3xl font-bold text-blue-700 mb-4">S·ª± Th·∫≠t & L·ªùi Khuy√™n</h2>
        <p class="text-base md:text-lg text-gray-800 mb-3 text-left" id="factText"></p>
        <p class="text-base md:text-lg text-green-700 font-semibold mb-6 text-left" id="adviceText"></p>
        <button class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300" id="closeFactButton">ƒê√£ hi·ªÉu</button>
    </div>
</div>

<!-- Modal Chi·∫øn Th·∫Øng Cu·ªëi C√πng (ƒê√É C·∫¨P NH·∫¨T) -->
<div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 backdrop-blur-sm" id="finalWinModal">
    <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform transition-all scale-95">
        <h2 class="text-4xl font-bold text-yellow-500 mb-4">CHI·∫æN TH·∫ÆNG!</h2>
        <p class="text-lg text-gray-700 mb-2">B·∫°n ƒë√£ b·∫£o v·ªá th√†nh c√¥ng nh·ªØng tr√°i tim kh·ªèi nanh vu·ªët c·ªßa qu√°i v·∫≠t!</p>
        <p class="text-xl text-gray-800 mb-6">C·∫£m ∆°n b·∫°n ƒë√£ tr·ªü th√†nh ng∆∞·ªùi h√πng!</p>
        <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="restartGameButton">Ch∆°i l·∫°i</button>
            <button class="bg-gray-500 text-white font-bold py-3 px-8 rounded-full hover:bg-gray-600 transition-transform transform hover:scale-105" id="backToIndexButton">V·ªÅ m√†n h√¨nh ch√≠nh</button>
            <button class="bg-yellow-500 text-white font-bold py-3 px-8 rounded-full hover:bg-yellow-600 transition-transform transform hover:scale-110 ring-4 ring-yellow-300 shadow-lg shadow-yellow-500/50" id="continueToNextGameButton">Ti·∫øp t·ª•c</button>
        </div>
    </div>
</div>

<script>
// S·ª≠ d·ª•ng IIFE ƒë·ªÉ t·∫°o scope ri√™ng, tr√°nh bi·∫øn to√†n c·ª•c
(function() {
    'use strict';

    // --- L·∫•y c√°c ph·∫ßn t·ª≠ DOM ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const movesEl = document.getElementById('moves');
    const winModal = document.getElementById('winModal');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const winLevelText = document.getElementById('win-level-text');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');
    const factModal = document.getElementById('factModal');
    const factText = document.getElementById('factText');
    const adviceText = document.getElementById('adviceText');
    const closeFactButton = document.getElementById('closeFactButton');
    const healthBar = document.getElementById('health-bar');
    const questList = document.getElementById('quest-list');
    const startScreen = document.getElementById('start-screen');
    const customCursor = document.getElementById('custom-cursor');
    const tutorialModal = document.getElementById('tutorial-modal');
    const tutorialSteps = document.querySelectorAll('.tutorial-step');
    const tutorialNextBtns = document.querySelectorAll('.tutorial-next-btn');
    const playFromTutorialBtn = document.getElementById('play-from-tutorial-btn');
    const finalWinModal = document.getElementById('finalWinModal');
    const restartGameButton = document.getElementById('restartGameButton');
    const easyModeBtn = document.getElementById('easy-mode-btn');
    const hardModeBtn = document.getElementById('hard-mode-btn');
    const freeModeBtn = document.getElementById('free-mode-btn');
    const backToMenuBtn = document.getElementById('back-to-menu-btn');

    // --- DOM Elements cho nh√¢n v·∫≠t m·ªõi ---
    const characterContainerEl = document.getElementById('character-container');
    const threatBubble = document.getElementById('threat-bubble');
    const threatText = document.getElementById('threat-text');
    const mouth = document.getElementById('mouth-path');
    const pupil1 = document.getElementById('pupil1');
    const pupil2 = document.getElementById('pupil2');
    
    // --- C·∫•u h√¨nh game (Kh√¥ng c√≤n "Magic Numbers") ---
    const CONFIG = {
        GRID_SIZE: 8,
        GEM_COLORS: ['#FF3131', '#00FF7F', '#1E90FF', '#FF00FF', '#FF8C00', '#FFFF00'],
        HEART_EMOJI: 'üíó',
        MOVES_PER_HEART_SPAWN: 3,
        CIGARETTE_LUNGE_CHANCE: 0.25,
        THREAT_INTERVAL: 6000,
        ANIM_SWAP_SPEED: 150,
        ANIM_FALL_SPEED: 400,
        ANIM_CLEAR_SPEED: 200,
        ANIM_SPECIAL_PULSE_SPEED: 150,
        MAX_PARTICLES: 150, 
        HINT_TIMEOUT: 5000,
        FINAL_LEVEL: 1 
    };

    const SPECIAL_TYPES = {
        NONE: 'none',
        H_BEAM: 'h_beam',
        V_BEAM: 'v_beam',
        BOMB: 'bomb',
        HYPERCUBE: 'hypercube'
    };
    
    // === AUDIO (Tone.js) ‚Äì NH·∫†C N·ªÄN ƒê∆†N GI·∫¢N ===
    const AudioManager = {
      initialized: false,
      started: false,
      nodes: {},
      sfx: {},
      musicParts: {},

      setup() {
        if (this.initialized) return;

        // Master chain with volume control
        Tone.Destination.volume.value = -9; // ƒê·∫∑t √¢m l∆∞·ª£ng t·ªïng th·ªÉ
        const limiter = new Tone.Limiter(-1).toDestination();
        const comp = new Tone.Compressor(-24, 4).connect(limiter);
        
        const reverb = new Tone.Reverb({ decay: 1.5, wet: 0.2 }).connect(comp);
        const delay = new Tone.FeedbackDelay("16n", 0.25).connect(reverb);

        const melodySynth = new Tone.PolySynth(Tone.FMSynth, {
            harmonicity: 2,
            modulationIndex: 5,
            envelope: { attack: 0.01, decay: 0.2, release: 0.2 },
            modulationEnvelope: { attack: 0.01, decay: 0.1, release: 0.2 }
        }).connect(delay);
        melodySynth.volume.value = -15;

        const bassSynth = new Tone.MonoSynth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.3, release: 1 },
            filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.5, baseFrequency: 200, octaves: 2.6 }
        }).connect(comp);
        bassSynth.volume.value = -18;

        const melodyPattern = new Tone.Sequence((time, note) => {
            melodySynth.triggerAttackRelease(note, "16n", time);
        }, [
            "C5", null, "E5", "G5", 
            "E5", null, "C5", null,
            "D5", null, "F5", "A5",
            "F5", null, "D5", null
        ], "8n");

        const bassPattern = new Tone.Sequence((time, note) => {
            bassSynth.triggerAttackRelease(note, "2n", time);
        }, ["C3", "G3"], "1n");

        // === SFX (Hi·ªáu ·ª©ng √¢m thanh) ===
        const clickSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.03 } }).connect(comp);
        const pluck = new Tone.PluckSynth().connect(comp);
        const noise = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.005, decay: 0.15, sustain: 0 } }).connect(new Tone.Filter(1200, "bandpass").connect(comp));
        const bombKick = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 3, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.2 } }).connect(comp);
        const fm = new Tone.FMSynth().connect(reverb);

        this.sfx = { clickSynth, pluck, noise, kick: bombKick, fm };
        this.musicParts = { melodyPattern, bassPattern };
        
        Tone.Transport.bpm.value = 140;
        this.initialized = true;
      },

      async start() {
        if (this.started) return;
        this.setup();

        await Tone.start();
        
        this.musicParts.melodyPattern.start(0);
        this.musicParts.bassPattern.start(0);

        Tone.Transport.start("+0.1");
        this.started = true;
      },

      stopBackground() {
        if (!this.initialized) return;
        this.musicParts.melodyPattern.stop();
        this.musicParts.bassPattern.stop();
      },

      resumeBackground() {
        if (!this.initialized || !this.started) return;
        this.musicParts.melodyPattern.start();
        this.musicParts.bassPattern.start();
      },

      setMasterVolume(db) {
        Tone.Destination.volume.rampTo(db, 0.2);
      },

      play(name, opts = {}) {
        if (!this.initialized || !this.started) return;

        switch (name) {
          case "selectSound":
            this.sfx.clickSynth.triggerAttackRelease("C5", "16n");
            break;

          case "matchSound": {
            const intensity = Math.min(1, Math.max(0.2, (opts.intensity || 3) / 6));
            this.sfx.pluck.triggerAttackRelease("E5", "8n", undefined, 0.4 + 0.4*intensity);
            break;
          }

          case "beamSound":
            this.sfx.noise.triggerAttack();
            break;

          case "bombSound":
            this.sfx.kick.triggerAttack("C2");
            break;

          case "hypercubeSound":
            this.sfx.fm.triggerAttackRelease("A4", "8n");
            break;
        }
      }
    };
    // ƒê·ªÅ ph√≤ng chuy·ªÉn tab
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        Tone.Transport.pause();
      } else if (AudioManager.started) {
        Tone.Transport.start();
      }
    });

    // --- D·ªØ li·ªáu tuy√™n truy·ªÅn ---
    const HEALTH_FACTS = [
        { fact: "Thu·ªëc l√° gi·∫øt **h∆°n 7 tri·ªáu ng∆∞·ªùi/nƒÉm**, trong ƒë√≥ c√≥ kho·∫£ng **1,6 tri·ªáu ng∆∞·ªùi kh√¥ng h√∫t th·ª• ƒë·ªông**. (Ngu·ªìn: WHO)", advice: "L·ªùi khuy√™n: H√£y tr√°nh xa kh√≥i thu·ªëc ƒë·ªÉ b·∫£o v·ªá b·∫°n v√† nh·ªØng ng∆∞·ªùi xung quanh." },
        { fact: "H√∫t thu·ªëc kh√¥ng th·ª• ƒë·ªông (passive smoking) c≈©ng g√¢y ung th∆∞ ph·ªïi, b·ªánh tim v√† nhi·ªÅu v·∫•n ƒë·ªÅ s·ª©c kh·ªèe nghi√™m tr·ªçng. (Ngu·ªìn: CDC / IARC)", advice: "L·ªùi khuy√™n: ƒê·ª´ng ƒë·ªÉ kh√≥i thu·ªëc x√¢m nh·∫≠p kh√¥ng kh√≠ s·ªëng, gi·ªØ s·∫°ch m√¥i tr∆∞·ªùng cho ph·ªïi b·∫°n." },
        { fact: "H√∫t thu·ªëc g√¢y t·ªïn th∆∞∆°ng **gan, ph·ªïi, tim**, l√†m tƒÉng nguy c∆° m·∫Øc **COPD, nh·ªìi m√°u c∆° tim, ƒë·ªôt qu·ªµ** v√† nhi·ªÅu lo·∫°i ung th∆∞. (Ngu·ªìn: CDC)", advice: "L·ªùi khuy√™n: M·ªói h∆°i thu·ªëc b·∫°n h√≠t v√†o l√† t·ªïn h·∫°i cho c∆° th·ªÉ‚Äîng∆∞ng ngay h√¥m nay ƒë·ªÉ kh·ªèe m·∫°nh h∆°n." },
        { fact: "H√∫t thu·ªëc g√¢y ung th∆∞ ·ªü **kho·∫£ng 20% c√°c ca ung th∆∞**, v√† kho·∫£ng **80% ca ung th∆∞ ph·ªïi** l√† do vi·ªác h√∫t thu·ªëc. (Ngu·ªìn: American Cancer Society)", advice: "L·ªùi khuy√™n: B·ªè thu·ªëc s·∫Ω gi√∫p gi·∫£m nguy c∆° m·∫Øc nhi·ªÅu lo·∫°i ung th∆∞ ‚Äî ƒë√≥ l√† c√°ch b·∫£o v·ªá t∆∞∆°ng lai c·ªßa b·∫°n." },
        { fact: "H√∫t thu·ªëc c√≥ th·ªÉ **r√∫t ng·∫Øn tu·ªïi th·ªç trung b√¨nh 10 nƒÉm** so v·ªõi ng∆∞·ªùi kh√¥ng h√∫t. (Ngu·ªìn: Wikipedia ‚Äì WHO)", advice: "L·ªùi khuy√™n: Ch·ªçn s·ªëng l√¢u h∆°n ‚Äî n√≥i kh√¥ng v·ªõi thu·ªëc l√° h√¥m nay." },
        { fact: "Kh√≥i thu·ªëc l√° ch·ª©a h∆°n **7.000 h√≥a ch·∫•t**, trong ƒë√≥ c√≥ **h∆°n 70 ch·∫•t g√¢y ung th∆∞**. (Ngu·ªìn: FDA)", advice: "L·ªùi khuy√™n: C∆° th·ªÉ b·∫°n kh√¥ng n√™n tr·ªü th√†nh ph√≤ng th√≠ nghi·ªám‚Äîh√£y gi·ªØ ph·ªïi trong l√†nh." },
        { fact: "H√∫t thu·ªëc l√†m suy y·∫øu h·ªá mi·ªÖn d·ªãch, l√†m c∆° th·ªÉ kh√≥ ch·ªëng l·∫°i nhi·ªÖm tr√πng v√† c√≥ th·ªÉ l√†m t·ªïn th∆∞∆°ng mi·ªÖn d·ªãch k√©o d√†i ngay c·∫£ sau khi b·ªè thu·ªëc. (Ngu·ªìn: Nature/CNN)", advice: "L·ªùi khuy√™n: H√£y b·∫£o v·ªá h·ªá mi·ªÖn d·ªãch c·ªßa b·∫°n‚Äîm·ªôt l√Ω do tuy·ªát v·ªùi ƒë·ªÉ b·ªè thu·ªëc." },
        { fact: "Ti·∫øp x√∫c v·ªõi kh√≥i thu·ªëc l√†m tƒÉng nguy c∆° ung th∆∞ v√∫ ·ªü ph·ª• n·ªØ tr·∫ª l√™n t·ªõi **70%**. (Ngu·ªìn: IARC / Wikipedia)", advice: "L·ªùi khuy√™n: B·∫£o v·ªá b·∫£n th√¢n, b·∫£o v·ªá s·ª©c kh·ªèe‚Äîtr√°nh kh√≥i thu·ªëc th·ª• ƒë·ªông." },
        { fact: "H√∫t thu·ªëc l√†m gi·∫£m kh·∫£ nƒÉng sinh s·∫£n‚Äîph·ª• n·ªØ h√∫t thu·ªëc c√≥ nguy c∆° v√¥ sinh cao h∆°n **60%**, tƒÉng nguy c∆° s·∫©y thai v√† c√°c v·∫•n ƒë·ªÅ thai k·ª≥. (Ngu·ªìn: Wikipedia)", advice: "L·ªùi khuy√™n: H√£y gi·ªØ s·ª©c kh·ªèe sinh s·∫£n‚Äîn√≥i kh√¥ng v·ªõi thu·ªëc l√° ƒë·ªÉ t∆∞∆°ng lai t∆∞∆°i s√°ng." },
        { fact: "Kh√¥ng c√≥ m·ª©c ƒë·ªô h√∫t thu·ªëc n√†o l√† an to√†n ‚Äî k·ªÉ c·∫£ m·ªôt ƒëi·∫øu m·ªói ng√†y c≈©ng tƒÉng nguy c∆° b·ªánh tim v√† ung th∆∞. (Ngu·ªìn: WHO)", advice: "L·ªùi khuy√™n: ƒê·ª´ng t·ª± ƒë√°nh l·ª´a‚Äîb·ªè h·∫≥n l√† c√°ch an to√†n duy nh·∫•t." },
    ];
    let factsShown = [];
    const THREATS = [
        "Ta n·∫øm ƒë∆∞·ª£c n·ªói s·ª£ c·ªßa ng∆∞∆°i.",
        "M·ªói t·∫ø b√†o c·ªßa ng∆∞∆°i ƒëang g√†o th√©t.",
        "Ta l√† c√°i ch·∫øt ch·∫≠m r√£i ng∆∞∆°i t·ª± ch·ªçn.",
        "Linh h·ªìn ng∆∞∆°i... s·∫Ω l√† l√†n kh√≥i ti·∫øp theo.",
        "Kh√¥ng c√≥ l·ªëi tho√°t ƒë√¢u."
    ];
    let threatInterval = null;

    // --- Bi·∫øn tr·∫°ng th√°i game ---
    let gemSize;
    let board = [];
    let selectedGem = null;
    let score = 0;
    let moves = 0;
    let isAnimating = false;
    let isPaused = false;
    let animations = [];
    let particles = [];
    let cigarette = { col: Math.floor(CONFIG.GRID_SIZE / 2), level: 1 };
    let currentLevel = 1;
    let quest = {};
    let startDragPos = { x: null, y: null };
    let startGem = null;
    let isDragging = false;
    let gemCache = {}; 
    let particlePool = [];
    let hintTimeout = null;
    let hintGems = [];
    let isFreePlayMode = false;

    // --- Hi·ªÉn th·ªã l·ªùi ƒëe d·ªça c·ªßa qu√°i v·∫≠t ---
    function showThreat() {
        if (isPaused || !gameOverModal.classList.contains('hidden') || characterContainerEl.classList.contains('attacking')) return;
        
        AudioManager.play('beamSound');
        threatText.textContent = THREATS[Math.floor(Math.random() * THREATS.length)];
        
        mouth.setAttribute('d', 'M58 68 L 64 60 L 70 68 L 76 60 L 82 68');
        characterContainerEl.classList.add('attacking');
        threatBubble.classList.add('visible');

        setTimeout(() => {
            threatBubble.classList.remove('visible');
            mouth.setAttribute('d', 'M60 65 L 64 63 L 68 65 L 72 63 L 76 65');
            characterContainerEl.classList.remove('attacking');
        }, 2000);
    }

    // --- Kh·ªüi t·∫°o v√† Thi·∫øt l·∫≠p Game ---
    function setupLevel(level) {
        currentLevel = level;
        levelEl.textContent = level;
        
        const baseRequirement = 15 + (level - 1) * 8;
        const numTargets = Math.min(2 + Math.floor(level / 2), 5);
        
        quest = {
            targets: {},
            collected: {},
            totalDamage: 0,
            maxDamage: 0,
            heartsToSave: level, 
            heartsSaved: 0
        };

        let availableColors = [...Array(CONFIG.GEM_COLORS.length).keys()];
        for(let i = 0; i < numTargets; i++) {
            if(availableColors.length === 0) break;
            const colorIndex = availableColors.splice(Math.floor(Math.random() * availableColors.length), 1)[0];
            const requirement = Math.floor(baseRequirement * (Math.random() * 0.4 + 0.8));
            quest.targets[colorIndex] = requirement;
            quest.collected[colorIndex] = 0;
            quest.maxDamage += requirement;
        }
        updateQuestUI();
        updateHealthBar();
    }

    function init() {
        resizeCanvas();
        
        ctx.font = `${gemSize * 0.7}px sans-serif`;

        cigarette.col = Math.floor(CONFIG.GRID_SIZE / 2);
        updateCigarettePosition();

        board = [];
        score = 0;
        moves = 0;
        selectedGem = null;
        isAnimating = false;
        isPaused = false;
        animations = [];
        
        particles = [];
        particlePool = [];
        for(let i = 0; i < CONFIG.MAX_PARTICLES; i++) {
            particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', alpha: 0 });
        }

        factsShown = [];
        
        if (threatInterval) clearInterval(threatInterval);
        threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL);

        updateScore();
        updateMoves();
        setupLevel(1);
        
        do {
            createBoard();
        } while(!hasPossibleMoves(board));

        spawnHeartIfNeeded(true);
        requestAnimationFrame(gameLoop);
        resetHintTimer();
    }
    
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        const containerWidth = container.clientWidth;
        const dpr = window.devicePixelRatio || 1;

        canvas.style.width = containerWidth + 'px';
        canvas.style.height = containerWidth + 'px';

        canvas.width = Math.floor(containerWidth * dpr);
        canvas.height = Math.floor(containerWidth * dpr);

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        gemSize = containerWidth / CONFIG.GRID_SIZE;
        
        preRenderGems(); 

        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if(board[r] && board[r][c]) {
                    board[r][c].x = c * gemSize;
                    board[r][c].y = r * gemSize;
                }
            }
        }
        updateCigarettePosition();
    }

    function createBoard() {
        board = [];
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            board[row] = [];
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                let possibleColors = [...Array(CONFIG.GEM_COLORS.length).keys()];
                
                if (col >= 2 && board[row][col-1].colorIndex === board[row][col-2].colorIndex) {
                    const colorToRemove = board[row][col-1].colorIndex;
                    possibleColors = possibleColors.filter(c => c !== colorToRemove);
                }

                if (row >= 2 && board[row-1][col].colorIndex === board[row-2][col].colorIndex) {
                    const colorToRemove = board[row-1][col].colorIndex;
                    possibleColors = possibleColors.filter(c => c !== colorToRemove);
                }

                const colorIndex = possibleColors[Math.floor(Math.random() * possibleColors.length)];

                board[row][col] = {
                    colorIndex: colorIndex,
                    isHeart: false,
                    special: SPECIAL_TYPES.NONE,
                    row: row,
                    col: col,
                    x: col * gemSize,
                    y: row * gemSize,
                    scale: 1,
                    alpha: 1,
                };
            }
        }
    }

    // --- V√≤ng l·∫∑p Game v√† V·∫Ω ---
    function gameLoop(time) {
        requestAnimationFrame(gameLoop);
        
        if (isPaused || !winModal.classList.contains('hidden') || !gameOverModal.classList.contains('hidden') || !finalWinModal.classList.contains('hidden')) {
            return;
        }
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        handleAnimations(time);
        drawBoard(time);
        drawParticles();
        drawSelection(time);
        drawHint(time);
    }

    async function preRenderGems() {
        gemCache = {};
        const promises = [];
        const specials = Object.values(SPECIAL_TYPES);
        const size = Math.max(1, Math.round(gemSize));

        CONFIG.GEM_COLORS.forEach((col) => {
            const canvas = renderGemCanvas(col, size);
            if ('createImageBitmap' in window) {
                promises.push(createImageBitmap(canvas).then(img => { gemCache[col] = img; }));
            } else {
                gemCache[col] = canvas;
            }
        });

        specials.forEach(special => {
            if (special === SPECIAL_TYPES.HYPERCUBE) {
                const canvas = renderHypercubeCanvas(size);
                 if ('createImageBitmap' in window) {
                    promises.push(createImageBitmap(canvas).then(img => { gemCache[special] = img; }));
                } else {
                    gemCache[special] = canvas;
                }
            } else if (special !== SPECIAL_TYPES.NONE) {
                CONFIG.GEM_COLORS.forEach((col, idx) => {
                    const canvas = renderSpecialCanvas(special, col, size);
                     if ('createImageBitmap' in window) {
                        promises.push(createImageBitmap(canvas).then(img => { gemCache[`${special}_${idx}`] = img; }));
                    } else {
                        gemCache[`${special}_${idx}`] = canvas;
                    }
                });
            }
        });
        await Promise.all(promises);
    }
    
    function renderGemCanvas(color, size) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = size;
        offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;
        
        offscreenCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
        offscreenCtx.shadowBlur = 5;
        offscreenCtx.shadowOffsetX = 2;
        offscreenCtx.shadowOffsetY = 2;

        const shadeColor = (col, percent) => {
            let f=parseInt(col.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
            return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
        };
        const lightColor = shadeColor(color, 0.6);
        const darkColor = shadeColor(color, -0.6);
        const grad = offscreenCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, half);
        grad.addColorStop(0, lightColor);
        grad.addColorStop(1, color);
        
        offscreenCtx.fillStyle = grad;
        offscreenCtx.beginPath();
        offscreenCtx.moveTo(centerX, centerY - half); 
        offscreenCtx.lineTo(centerX + half, centerY); 
        offscreenCtx.lineTo(centerX, centerY + half); 
        offscreenCtx.lineTo(centerX - half, centerY);
        offscreenCtx.closePath();
        offscreenCtx.fill();
        
        offscreenCtx.strokeStyle = darkColor;
        offscreenCtx.lineWidth = 2;
        offscreenCtx.stroke();

        return offscreenCanvas;
    }

    function renderSpecialCanvas(special, color, size) {
        const canvas = renderGemCanvas(color, size);
        const ctx = canvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;

        ctx.fillStyle = 'white';
        ctx.shadowColor = 'white';
        ctx.shadowBlur = 10;

        if(special === SPECIAL_TYPES.H_BEAM) {
            ctx.fillRect(centerX - half, centerY - half * 0.1, s, half * 0.2);
        } else if (special === SPECIAL_TYPES.V_BEAM) {
            ctx.fillRect(centerX - half * 0.1, centerY - half, half * 0.2, s);
        } else if (special === SPECIAL_TYPES.BOMB) {
            ctx.fillStyle = `rgba(255, 255, 255, 0.8)`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, half * 0.6, 0, 2 * Math.PI);
            ctx.fill();
        }
        return canvas;
    }

    function renderHypercubeCanvas(size) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = size;
        offscreenCanvas.height = size;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const centerX = size / 2;
        const centerY = size / 2;
        const s = size * 0.85;
        const half = s / 2;

        offscreenCtx.shadowColor = 'rgba(255, 255, 255, 0.7)';
        offscreenCtx.shadowBlur = 10;

        for (let i = 0; i < 6; i++) {
            offscreenCtx.fillStyle = CONFIG.GEM_COLORS[i];
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(centerX,centerY);
            const angle1 = (i / 6) * 2 * Math.PI;
            const angle2 = ((i+1) / 6) * 2 * Math.PI;
            offscreenCtx.arc(centerX,centerY, half, angle1, angle2);
            offscreenCtx.closePath();
            offscreenCtx.fill();
        }
        return offscreenCanvas;
    }


    function drawBoard(time) {
        for (let row = 0; row < CONFIG.GRID_SIZE; row++) {
            for (let col = 0; col < CONFIG.GRID_SIZE; col++) {
                const gem = board[row][col];
                if (gem) {
                    ctx.save();
                    ctx.globalAlpha = gem.alpha;
                    
                    const centerX = gem.x + gemSize / 2;
                    const centerY = gem.y + gemSize / 2;
                    ctx.translate(centerX, centerY);
                    ctx.scale(gem.scale, gem.scale);
                    ctx.translate(-centerX, -centerY);
                    
                    let cacheKey;
                    if (gem.special !== SPECIAL_TYPES.NONE && gem.special !== SPECIAL_TYPES.HYPERCUBE) {
                        cacheKey = `${gem.special}_${gem.colorIndex}`;
                    } else if (gem.special === SPECIAL_TYPES.HYPERCUBE) {
                        cacheKey = SPECIAL_TYPES.HYPERCUBE;
                    } else {
                        cacheKey = CONFIG.GEM_COLORS[gem.colorIndex];
                    }
                    const cachedGem = gemCache[cacheKey];

                    if (cachedGem) {
                        ctx.drawImage(cachedGem, gem.x, gem.y, gemSize, gemSize);
                    }
                    
                    if (gem.isHeart) {
                        const heartPulse = Math.sin(time / 300) * 0.1 + 1.1;
                        ctx.save();
                        ctx.translate(gem.x + gemSize / 2, gem.y + gemSize / 2);
                        ctx.scale(heartPulse, heartPulse);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = 'rgba(0,0,0,0)';
                        ctx.font = `${gemSize * 0.6}px sans-serif`;
                        ctx.fillText(CONFIG.HEART_EMOJI, 0, 0);
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }
        }
    }

    function drawHint(time) {
        if (hintGems.length === 2 && !isAnimating) {
            const gem1 = hintGems[0];
            const gem2 = hintGems[1];

            const pulse = (Math.sin(time / 200) + 1) / 2;
            const scale = 1 + 0.05 * pulse;

            if (gem1) {
                ctx.save();
                const centerX = gem1.x + gemSize / 2;
                const centerY = gem1.y + gemSize / 2;
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.translate(-centerX, -centerY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(gem1.x + 2, gem1.y + 2, gemSize - 4, gemSize - 4);
                ctx.restore();
            }

            if (gem2) {
                ctx.save();
                const centerX = gem2.x + gemSize / 2;
                const centerY = gem2.y + gemSize / 2;
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.translate(-centerX, -centerY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 4;
                ctx.strokeRect(gem2.x + 2, gem2.y + 2, gemSize - 4, gemSize - 4);
                ctx.restore();
            }
        }
    }
    
    function drawParticles() {
        for (let i = particlePool.length - 1; i >= 0; i--) {
            const p = particlePool[i];
            if (!p.active) continue;

            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= 0.02;

            if (p.alpha <= 0) {
                p.active = false;
            } else {
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
    }

    function getParticle() {
        for (let i = 0; i < particlePool.length; i++) {
            if (!particlePool[i].active) {
                return particlePool[i];
            }
        }
        return null;
    }
    
    function createParticleBurst(x, y, color) {
        for(let i=0; i<10; i++) {
            const p = getParticle();
            if (p) {
                p.active = true;
                p.x = x; p.y = y;
                p.vx = (Math.random() - 0.5) * 6;
                p.vy = (Math.random() - 0.5) * 6;
                p.size = Math.random() * 4 + 2;
                p.color = color;
                p.alpha = 1;
            }
        }
    }

    function drawSelection(time) {
        if (selectedGem) {
            const pulse = Math.sin(time / 100) * 0.5 + 0.5;
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(selectedGem.col * gemSize + 2, selectedGem.row * gemSize + 2, gemSize - 4, gemSize - 4);
        }
    }

    function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    }

    function handlePointerStart(e) {
        e.preventDefault();
        if (isAnimating || isPaused) return;
        
        resetHintTimer();
        hintGems = [];

        const pos = getEventPos(e);
        const col = Math.floor(pos.x / gemSize);
        const row = Math.floor(pos.y / gemSize);

        if (row < 0 || row >= CONFIG.GRID_SIZE || col < 0 || col >= CONFIG.GRID_SIZE) {
            selectedGem = null;
            return;
        }
        
        const clickedGem = board[row][col];

        isDragging = true;
        startDragPos = pos;
        startGem = clickedGem;

        if (selectedGem) {
            if (selectedGem === clickedGem) {
                selectedGem = null;
                return;
            }

            const isAdjacent = Math.abs(selectedGem.row - clickedGem.row) + Math.abs(selectedGem.col - clickedGem.col) === 1;
            
            if (isAdjacent) {
                processSwap(selectedGem, clickedGem);
            } else {
                AudioManager.play('selectSound');
                selectedGem = clickedGem;
            }
        } else {
            AudioManager.play('selectSound');
            selectedGem = clickedGem;
        }
    }

    function handlePointerMove(e) {
        e.preventDefault();
        if (!isDragging || isAnimating || isPaused) return;
        
        const pos = getEventPos(e);
        const deltaX = pos.x - startDragPos.x;
        const deltaY = pos.y - startDragPos.y;
        
        if (Math.abs(deltaX) > gemSize / 2 || Math.abs(deltaY) > gemSize / 2) {
            let endGem = null;
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                const endCol = startGem.col + (deltaX > 0 ? 1 : -1);
                if (endCol >= 0 && endCol < CONFIG.GRID_SIZE) {
                    endGem = board[startGem.row][endCol];
                }
            } else {
                const endRow = startGem.row + (deltaY > 0 ? 1 : -1);
                 if (endRow >= 0 && endRow < CONFIG.GRID_SIZE) {
                    endGem = board[endRow][startGem.col];
                }
            }

            if (endGem && startGem !== endGem) {
                isDragging = false;
                selectedGem = null; 
                processSwap(startGem, endGem);
            }
        }
    }

    function handlePointerEnd(e) {
        isDragging = false;
        startGem = null;
    }

    // --- Logic Game Ch√≠nh ---
    async function processSwap(gem1, gem2) {
        isAnimating = true;
        selectedGem = null;
        
        const startPos1 = { row: gem1.row, col: gem1.col };
        const startPos2 = { row: gem2.row, col: gem2.col };

        if (gem1.special === SPECIAL_TYPES.HYPERCUBE || gem2.special === SPECIAL_TYPES.HYPERCUBE) {
            moves++;
            updateMoves();
            const hypercube = gem1.special === SPECIAL_TYPES.HYPERCUBE ? gem1 : gem2;
            const otherGem = hypercube === gem1 ? gem2 : gem1;
            await triggerHypercube(hypercube, otherGem);
        } else {
            await swapGems(gem1, gem2);
            const matchInfo = findMatchesAndSpecial(startPos1, startPos2);
            if (matchInfo.allMatches.length > 0) {
                moves++;
                updateMoves();
                await cascadeMatches(matchInfo.allMatches, matchInfo.specialToCreate);
            } else {
                await sleep(100);
                await swapGems(gem1, gem2);
            }
        }
        
        if (gameOverModal.classList.contains('hidden') && winModal.classList.contains('hidden') && finalWinModal.classList.contains('hidden')) {
            await moveCigarette();
            if (checkGameOver()) {
                isAnimating = false;
                return;
            }
            spawnHeartIfNeeded();
            checkWinCondition();
            if (!hasPossibleMoves(board)) {
                await reshuffleBoard();
            }
        }
        
        isAnimating = false;
        resetHintTimer();
    }

    function resetHintTimer() {
        if (hintTimeout) clearTimeout(hintTimeout);
        hintGems = [];
        hintTimeout = setTimeout(() => {
            if (!isAnimating && !isPaused) {
                const move = findFirstPossibleMove();
                if (move) {
                    hintGems = [move.gem1, move.gem2];
                }
            }
        }, CONFIG.HINT_TIMEOUT);
    }

    function findFirstPossibleMove() {
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if (c < CONFIG.GRID_SIZE - 1) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    [tempBoard[r][c], tempBoard[r][c+1]] = [tempBoard[r][c+1], tempBoard[r][c]];
                    if (findMatches(tempBoard).length > 0) {
                        return { gem1: board[r][c], gem2: board[r][c+1] };
                    }
                }
                if (r < CONFIG.GRID_SIZE - 1) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    [tempBoard[r][c], tempBoard[r+1][c]] = [tempBoard[r+1][c], tempBoard[r][c]];
                    if (findMatches(tempBoard).length > 0) {
                        return { gem1: board[r][c], gem2: board[r+1][c] };
                    }
                }
            }
        }
        return null;
    }

    function hasPossibleMoves(currentBoard) {
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE - 1; c++) {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                const tempGem1 = tempBoard[r][c];
                const tempGem2 = tempBoard[r][c+1];
                [tempBoard[r][c], tempBoard[r][c+1]] = [tempGem2, tempGem1];

                if (findMatches(tempBoard).length > 0) {
                    return true;
                }
            }
        }

        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            for (let r = 0; r < CONFIG.GRID_SIZE - 1; r++) {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                const tempGem1 = tempBoard[r][c];
                const tempGem2 = tempBoard[r+1][c];
                [tempBoard[r][c], tempBoard[r+1][c]] = [tempGem2, tempGem1];

                if (findMatches(tempBoard).length > 0) {
                    return true;
                }
            }
        }
        return false;
    }

    async function reshuffleBoard() {
        isAnimating = true;
        
        const promises = [];
        board.flat().forEach(gem => {
            if (gem) {
                promises.push(animate(gem, { alpha: 0, scale: 0 }, 300));
            }
        });
        await Promise.all(promises);
        
        do {
            createBoard();
        } while(!hasPossibleMoves(board));

        const refillPromises = [];
        board.flat().forEach(gem => {
            if (gem) {
                gem.alpha = 0; gem.scale = 0;
                refillPromises.push(animate(gem, { alpha: 1, scale: 1 }, 300));
            }
        });
        await Promise.all(refillPromises);

        isAnimating = false;
        resetHintTimer();
    }
    
    async function cascadeMatches(initialMatches, specialToCreate = null) {
        let gemsToClear = new Set(initialMatches);
        let processedSpecials = new Set();
        
        while(true) {
            let newGemsFromExplosion = new Set();
            let foundNewExplosion = false;
            for(const gem of gemsToClear) {
                if(gem.special !== SPECIAL_TYPES.NONE && !processedSpecials.has(gem)) {
                    foundNewExplosion = true;
                    processedSpecials.add(gem);
                    
                    switch(gem.special) {
                        case SPECIAL_TYPES.H_BEAM:
                        case SPECIAL_TYPES.V_BEAM:
                            AudioManager.play('beamSound');
                            break;
                        case SPECIAL_TYPES.BOMB:
                            AudioManager.play('bombSound');
                            break;
                    }

                    getSpecialEffectGems(gem).forEach(g => newGemsFromExplosion.add(g));
                }
            }
            if(!foundNewExplosion) break;
            newGemsFromExplosion.forEach(g => gemsToClear.add(g));
        }

        const savedAHeart = await handleMatches(Array.from(gemsToClear), specialToCreate);
        if (savedAHeart) {
            await showFact();
        }

        await sleep(150);
        await shiftAndRefill();
        
        const nextMatches = findMatches(board);
        if (nextMatches.length > 0) {
            await cascadeMatches(nextMatches);
        } else {
             await moveHearts();
        }
    }
    
    async function triggerHypercube(hypercube, otherGem) {
        let gemsToClear = new Set([hypercube]);
        AudioManager.play('hypercubeSound');
        
        if (otherGem.special === SPECIAL_TYPES.NONE) {
            const targetColorIndex = otherGem.colorIndex;
            board.flat().filter(g => g && g.colorIndex === targetColorIndex).forEach(g => gemsToClear.add(g));
        }
        else if (otherGem.special !== SPECIAL_TYPES.HYPERCUBE) {
             const targetColorIndex = otherGem.colorIndex;
             board.flat().filter(g => g && g.colorIndex === targetColorIndex).forEach(g => {
                g.special = otherGem.special;
                gemsToClear.add(g);
             });
        }
        else {
            board.flat().forEach(g => { if(g) gemsToClear.add(g) });
        }
        await cascadeMatches(Array.from(gemsToClear));
    }

    function getSpecialEffectGems(gem) {
        let affected = new Set();
        if (gem.special === SPECIAL_TYPES.H_BEAM) {
            for(let c=0; c<CONFIG.GRID_SIZE; c++) { if(board[gem.row][c]) affected.add(board[gem.row][c]); }
        } else if (gem.special === SPECIAL_TYPES.V_BEAM) {
            for(let r=0; r<CONFIG.GRID_SIZE; r++) { if(board[r][gem.col]) affected.add(board[r][gem.col]); }
        } else if (gem.special === SPECIAL_TYPES.BOMB) {
            for(let r = gem.row - 1; r <= gem.row + 1; r++) {
                for(let c = gem.col - 1; c <= gem.col + 1; c++) {
                    if(r >= 0 && r < CONFIG.GRID_SIZE && c >= 0 && c < CONFIG.GRID_SIZE && board[r][c]) {
                        affected.add(board[r][c]);
                    }
                }
            }
        }
        return affected;
    }

    function swapGems(gem1, gem2) {
        const r1 = gem1.row, c1 = gem1.col;
        const r2 = gem2.row, c2 = gem2.col;
        board[r1][c1] = gem2;
        board[r2][c2] = gem1;
        gem1.row = r2; gem1.col = c2;
        gem2.row = r1; gem2.col = c1;
        const p1 = animate(gem1, { x: c2 * gemSize, y: r2 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad);
        const p2 = animate(gem2, { x: c1 * gemSize, y: r1 * gemSize }, CONFIG.ANIM_SWAP_SPEED, easing.easeInOutQuad);
        return Promise.all([p1, p2]);
    }
    
    function findMatches(currentBoard) {
        const matches = new Set();
        for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE - 2; c++) {
                const gem1 = currentBoard[r][c];
                if (!gem1) continue;
                const gem2 = currentBoard[r][c+1];
                const gem3 = currentBoard[r][c+2];
                if (gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                    matches.add(gem1); matches.add(gem2); matches.add(gem3);
                }
            }
        }
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            for (let r = 0; r < CONFIG.GRID_SIZE - 2; r++) {
                 const gem1 = currentBoard[r][c];
                 if (!gem1) continue;
                const gem2 = currentBoard[r+1][c];
                const gem3 = currentBoard[r+2][c];
                if (gem2 && gem3 && gem1.colorIndex === gem2.colorIndex && gem2.colorIndex === gem3.colorIndex) {
                    matches.add(gem1); matches.add(gem2); matches.add(gem3);
                }
            }
        }
        return Array.from(matches);
    }

    function findMatchesAndSpecial(startPos1, startPos2) {
      const allMatches = new Set();

      const checkLine = (line) => {
        const res = [];
        for (let i = 0; i < line.length - 2; i++) {
          const g = line[i];
          if (!g) continue;
          let len = 1;
          while (i + len < line.length && line[i + len] && line[i + len].colorIndex === g.colorIndex) len++;
          if (len >= 3) {
            res.push(line.slice(i, i + len));
            i += len - 1;
          }
        }
        return res;
      };

      const h1 = checkLine(board[startPos1.row] || []);
      const v1 = checkLine(board.map(r => r[startPos1.col]) || []);
      const h2 = checkLine(board[startPos2.row] || []);
      const v2 = checkLine(board.map(r => r[startPos2.col]) || []);

      const allFoundMatches = [...h1, ...v1, ...h2, ...v2];
      allFoundMatches.flat().forEach(g => allMatches.add(g));

      const gem1 = board[startPos1.row][startPos1.col];
      const gem2 = board[startPos2.row][startPos2.col];
      let movedGem = Array.from(allMatches).includes(gem1) ? gem1 : (Array.from(allMatches).includes(gem2) ? gem2 : null);

      let specialToCreate = null;
      if (movedGem) {
        let best = { len: 0, match: null, type: null };
        for (const m of allFoundMatches) {
          if (!m.includes(movedGem)) continue;
          const len = m.length;
          if (len >= 5) { best = { len, match: m, type: 'line5' }; break; }
          const isHorizontal = (m[0].row === m[1].row);
          const crossMatches = isHorizontal ? [...v1, ...v2] : [...h1, ...h2];
          const hasCross = crossMatches.some(cm => cm.includes(movedGem));
          if (hasCross) { best = { len: 5, match: m, type: 'cross' }; break; }
          if (len === 4 && best.len < 4) { best = { len: 4, match: m, type: isHorizontal ? 'h' : 'v' }; }
        }

        if (best.len > 0) {
          let special = SPECIAL_TYPES.NONE;
          if (best.type === 'line5') special = SPECIAL_TYPES.HYPERCUBE;
          else if (best.type === 'cross') special = SPECIAL_TYPES.BOMB;
          else if (best.type === 'h') special = SPECIAL_TYPES.H_BEAM;
          else if (best.type === 'v') special = SPECIAL_TYPES.V_BEAM;
          if (special !== SPECIAL_TYPES.NONE) {
            specialToCreate = { special, colorIndex: movedGem.colorIndex, row: movedGem.row, col: movedGem.col };
          }
        }
      }
      return { allMatches: Array.from(allMatches), specialToCreate };
    }
    
    async function handleMatches(matches, specialToCreate) {
        if (matches.length > 0) {
            AudioManager.play('matchSound', { intensity: matches.length });
        }

        const promises = [];
        let heartSaved = false;
        let collectedForQuest = {};

        matches.forEach(gem => {
            if(specialToCreate && gem.row === specialToCreate.row && gem.col === specialToCreate.col) return;
            
            if (gem.isHeart) { 
                score++; 
                quest.heartsSaved++;
                updateScore(); 
                heartSaved = true; 
            }
            
            const colorIdx = gem.colorIndex;
            if(quest.targets[colorIdx] !== undefined) {
                collectedForQuest[colorIdx] = (collectedForQuest[colorIdx] || 0) + 1;
            }

            createParticleBurst(gem.x + gemSize / 2, gem.y + gemSize / 2, CONFIG.GEM_COLORS[gem.colorIndex]);
            
            promises.push(new Promise(async (resolve) => {
                await animate(gem, { scale: 0, alpha: 0 }, CONFIG.ANIM_CLEAR_SPEED, easing.easeInQuad);
                if (board[gem.row]) {
                    board[gem.row][gem.col] = null;
                }
                resolve();
            }));
        });
        await Promise.all(promises);
        
        updateQuestProgress(collectedForQuest);
        updateQuestUI();

        if (specialToCreate) {
            const gem = board[specialToCreate.row][specialToCreate.col];
            if (gem) {
                gem.special = specialToCreate.special;
                if (specialToCreate.special !== SPECIAL_TYPES.HYPERCUBE) gem.colorIndex = specialToCreate.colorIndex;
                gem.isHeart = false;
                await animate(gem, {scale: 1.5}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad)
                    .then(() => animate(gem, {scale: 1}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad));
            }
        }
        return heartSaved;
    }

    async function shiftAndRefill() {
        const shiftPromises = [];
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            let emptySlots = 0;
            for (let r = CONFIG.GRID_SIZE - 1; r >= 0; r--) {
                if (board[r][c] === null) {
                    emptySlots++;
                } else if (emptySlots > 0) {
                    const gem = board[r][c];
                    board[r + emptySlots][c] = gem;
                    board[r][c] = null;
                    gem.row += emptySlots;
                    shiftPromises.push(animate(gem, { y: gem.row * gemSize }, 300, easing.easeOutQuad));
                }
            }
        }
        await Promise.all(shiftPromises);

        const refillPromises = [];
        for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
            for (let r = 0; r < CONFIG.GRID_SIZE; r++) {
                if (board[r][c] === null) {
                    const newGem = {
                        colorIndex: Math.floor(Math.random() * CONFIG.GEM_COLORS.length),
                        isHeart: false, special: SPECIAL_TYPES.NONE,
                        row: r, col: c,
                        x: c * gemSize, y: (r - CONFIG.GRID_SIZE) * gemSize,
                        scale: 1, alpha: 1,
                    };
                    board[r][c] = newGem;
                    refillPromises.push(animate(newGem, { y: r * gemSize }, CONFIG.ANIM_FALL_SPEED, easing.easeOutQuad));
                }
            }
        }
        await Promise.all(refillPromises);
    }

    function spawnHeartIfNeeded(isFirst = false) {
         if (isFirst || (moves > 0 && moves % CONFIG.MOVES_PER_HEART_SPAWN === 0)) {
            let availableCols = [];
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                if (board[CONFIG.GRID_SIZE - 1][c] && !board[CONFIG.GRID_SIZE - 1][c].isHeart && board[CONFIG.GRID_SIZE - 1][c].special === SPECIAL_TYPES.NONE) {
                    availableCols.push(c);
                }
            }
            if (availableCols.length > 0) {
                const col = availableCols[Math.floor(Math.random() * availableCols.length)];
                const gem = board[CONFIG.GRID_SIZE - 1][col];
                gem.isHeart = true;
                gem.special = SPECIAL_TYPES.NONE;
                animate(gem, {scale: 1.5}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeOutQuad)
                    .then(() => animate(gem, {scale: 1}, CONFIG.ANIM_SPECIAL_PULSE_SPEED, easing.easeInQuad));
            }
        }
    }

    async function moveHearts() {
        const movePromises = [];
        let movedGems = new Set();

        for (let r = 1; r < CONFIG.GRID_SIZE; r++) {
            for (let c = 0; c < CONFIG.GRID_SIZE; c++) {
                const gem = board[r][c];
                if (gem && gem.isHeart && !movedGems.has(gem)) {
                    const gemAbove = board[r - 1][c];
                    if (gemAbove && !gemAbove.isHeart) {
                        board[r - 1][c] = gem;
                        board[r][c] = gemAbove;
                        
                        gem.row = r - 1;
                        gemAbove.row = r;
                        
                        movePromises.push(animate(gem, { y: gem.row * gemSize }, 200, easing.easeInOutQuad));
                        movePromises.push(animate(gemAbove, { y: gemAbove.row * gemSize }, 200, easing.easeInOutQuad));
                        
                        movedGems.add(gem);
                        movedGems.add(gemAbove);
                    }
                }
            }
        }
        await Promise.all(movePromises);
    }

    async function moveCigarette() {
        let highestHeart = null;
        let minRow = CONFIG.GRID_SIZE;

        board.flat().filter(g => g && g.isHeart).forEach(g => {
            if (g.row < minRow) {
                minRow = g.row;
                highestHeart = g;
            }
        });

        if (highestHeart) {
            if (Math.random() < CONFIG.CIGARETTE_LUNGE_CHANCE) {
                const originalCol = cigarette.col;
                const targetCol = highestHeart.col;
                
                updateCigarettePosition(targetCol, true);
                await sleep(150);
                updateCigarettePosition(originalCol);
                await sleep(400);
            }

            if (cigarette.col < highestHeart.col) cigarette.col++;
            else if (cigarette.col > highestHeart.col) cigarette.col--;
        }
        updateCigarettePosition();
    }

    function updateCigarettePosition(col = cigarette.col, isLunging = false) {
        const columnCenter = (col * gemSize) + (gemSize / 2);
        const svgScaledWidth = 200 * 0.7;
        const translateX = columnCenter - (svgScaledWidth / 2);

        let scale = 0.7;
        let rotate = 0;
        let translateY = 0;
        
        if (isLunging) {
            scale = 0.8;
            translateY = 10;
        } else if (characterContainerEl.classList.contains('attacking')) {
            scale = 0.8;
            rotate = -5;
        }

        characterContainerEl.style.transform = `translateX(${translateX}px) translateY(${translateY}px) scale(${scale}) rotate(${rotate}deg)`;
    }
    
    function checkGameOver() {
        if(board[0][cigarette.col] && board[0][cigarette.col].isHeart) {
            showGameOver();
            return true;
        }
        return false;
    }

    // --- Giao di·ªán ng∆∞·ªùi d√πng v√† Ti·ªán √≠ch ---
    function updateQuestUI() {
        questList.innerHTML = '';
        for (const colorIdx in quest.targets) {
            const remaining = Math.max(0, quest.targets[colorIdx] - quest.collected[colorIdx]);
            const isCompleted = remaining === 0;
            
            const item = document.createElement('div');
            item.className = `flex items-center justify-between p-2 rounded-lg transition-all ${isCompleted ? 'bg-green-500/30' : 'bg-black/20'}`;
            item.innerHTML = `
                <div class="w-6 h-6 rounded-full border-2 border-white/20" style="background-color: ${CONFIG.GEM_COLORS[colorIdx]}"></div>
                <span class="font-bold text-white">${remaining}</span>
            `;
            questList.appendChild(item);
        }
        const remainingHearts = Math.max(0, quest.heartsToSave - quest.heartsSaved);
        const heartsCompleted = remainingHearts === 0;
        const heartItem = document.createElement('div');
        heartItem.className = `flex items-center justify-between p-2 rounded-lg transition-all ${heartsCompleted ? 'bg-green-500/30' : 'bg-black/20'}`;
        heartItem.innerHTML = `
            <span class="text-2xl">${CONFIG.HEART_EMOJI}</span>
            <span class="font-bold text-white">${remainingHearts}</span>
        `;
        questList.appendChild(heartItem);
    }
    
    function updateHealthBar() {
        const progressPercent = quest.maxDamage > 0 ? Math.min(100, (quest.totalDamage / quest.maxDamage) * 100) : 0;
        healthBar.style.width = `${progressPercent}%`;
    }

    function updateQuestProgress(collected) {
        for (const key in collected) {
            const colorIdx = parseInt(key, 10);
            const amount = collected[key];
            if (!quest.targets.hasOwnProperty(colorIdx)) continue;

            const before = quest.collected[colorIdx] || 0;
            const remaining = Math.max(0, quest.targets[colorIdx] - before);
            const used = Math.min(remaining, amount);

            quest.collected[colorIdx] = before + used;
            quest.totalDamage += used;
        }
        updateHealthBar();
    }

    function updateScore() { scoreEl.textContent = score; }
    function updateMoves() { movesEl.textContent = moves; }

    function showGameOver() {
        AudioManager.setMasterVolume(-12);
        isAnimating = true;
        isPaused = true;
        if (threatInterval) clearInterval(threatInterval);
        finalScoreEl.textContent = score;
        gameOverModal.classList.remove('hidden');
        setTimeout(() => gameOverModal.querySelector('div').classList.add('scale-100'), 10);
    }

    function checkWinCondition() {
        if (quest.totalDamage >= quest.maxDamage && quest.heartsSaved >= quest.heartsToSave) {
            AudioManager.setMasterVolume(-12);
            isAnimating = true;
            isPaused = true;
            if (threatInterval) clearInterval(threatInterval);

            if (!isFreePlayMode && currentLevel >= CONFIG.FINAL_LEVEL) {
                finalWinModal.classList.remove('hidden');
                setTimeout(() => finalWinModal.querySelector('div').classList.add('scale-100'), 10);
            } else {
                winLevelText.textContent = `B·∫°n ƒë√£ ho√†n th√†nh m√†n ${currentLevel}!`;
                winModal.classList.remove('hidden');
                setTimeout(() => winModal.querySelector('div').classList.add('scale-100'), 10);
            }
        }
    }

    async function showFact() {
        isPaused = true;
        let availableFacts = HEALTH_FACTS.filter(obj => !factsShown.includes(obj));
        if (availableFacts.length === 0) factsShown = [];
        const factObject = availableFacts.length > 0 ? availableFacts[Math.floor(Math.random() * availableFacts.length)] : HEALTH_FACTS[0];
        factsShown.push(factObject);
        factText.textContent = factObject.fact;
        adviceText.textContent = factObject.advice;
        factModal.classList.remove('hidden');
        
        return new Promise(resolve => {
            const listener = () => {
                factModal.classList.add('hidden');
                isPaused = false;
                resolve();
            };
            closeFactButton.addEventListener('click', listener, { once: true });
        });
    }

    function goToNextLevel() {
        AudioManager.setMasterVolume(0);
        isAnimating = false;
        isPaused = false;
        setupLevel(currentLevel + 1);
        
        do {
            createBoard();
        } while(!hasPossibleMoves(board));

        spawnHeartIfNeeded(true);
        if (threatInterval) clearInterval(threatInterval);
        threatInterval = setInterval(showThreat, CONFIG.THREAT_INTERVAL);
    }

    restartButton.addEventListener('click', () => {
        window.location.href = 'index.html';
    });

    nextLevelButton.addEventListener('click', () => {
        winModal.classList.add('hidden');
        winModal.querySelector('div').classList.remove('scale-100');
        goToNextLevel();
    });

    restartGameButton.addEventListener('click', () => {
        location.reload();
    });

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    
    // --- H·ªá th·ªëng Animation ---
    const easing = {
        easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
        easeInQuad: t => t * t,
        easeOutQuad: t => t * (2 - t)
    };

    function animate(target, toProperties, duration, easeFunc = easing.easeInOutQuad) {
        return new Promise(resolve => {
            const startProps = {};
            const endProps = {};
            for (const key in toProperties) {
                const cur = typeof target[key] === 'number' && !isNaN(target[key]) ? target[key] : 0;
                startProps[key] = cur;
                endProps[key] = Number(toProperties[key]);
            }
            animations.push({
                target,
                startProperties: startProps,
                endProperties: endProps,
                duration,
                easeFunc,
                startTime: performance.now(),
                onComplete: resolve
            });
        });
    }

    function handleAnimations() {
        const now = performance.now();
        for (let i = animations.length - 1; i >= 0; i--) {
            const anim = animations[i];
            const elapsed = now - anim.startTime;
            const t = Math.min(elapsed / anim.duration, 1);
            const progress = anim.easeFunc(t);

            if (t >= 1) {
                for (const key in anim.endProperties) anim.target[key] = anim.endProperties[key];
                if (anim.onComplete) anim.onComplete();
                animations.splice(i, 1);
            } else {
                for (const key in anim.endProperties) {
                    const start = anim.startProperties[key];
                    const end = anim.endProperties[key];
                    anim.target[key] = start + (end - start) * progress;
                }
            }
        }
    }

    // --- Logic con tr·ªè v√† theo d√µi m·∫Øt ---
    function trackPupil(pupilElement, e) {
        const svgRect = characterContainerEl.getBoundingClientRect();
        const pupilData = {
            cx: parseFloat(pupilElement.getAttribute('cx')),
            cy: parseFloat(pupilElement.getAttribute('cy'))
        };
        
        const pupilX = svgRect.left + (pupilData.cx / 200) * svgRect.width;
        const pupilY = svgRect.top + (pupilData.cy / 100) * svgRect.height;
        
        const angle = Math.atan2(e.clientY - pupilY, e.clientX - pupilX);
        const maxMove = 4;
        const moveX = Math.cos(angle) * maxMove;
        const moveY = Math.sin(angle) * maxMove;
        pupilElement.style.transform = `translate(${moveX}px, ${moveY}px)`;
    }
    
    // --- Logic To√†n m√†n h√¨nh ---
    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    function updateFullscreenIcons() {
        const fullscreenIconOpen = document.getElementById('fullscreen-icon-open');
        const fullscreenIconClose = document.getElementById('fullscreen-icon-close');
        if (document.fullscreenElement) {
            fullscreenIconOpen.classList.add('hidden');
            fullscreenIconClose.classList.remove('hidden');
        } else {
            fullscreenIconOpen.classList.remove('hidden');
            fullscreenIconClose.classList.add('hidden');
        }
    }
    
    // --- KH·ªûI CH·∫†Y GAME ---
    window.addEventListener('DOMContentLoaded', () => {
        let currentTutorialStep = 0;

        const backToIndexButton = document.getElementById('backToIndexButton');
        const continueToNextGameButton = document.getElementById('continueToNextGameButton');
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', toggleFullScreen);
            document.addEventListener('fullscreenchange', updateFullscreenIcons);
        }

        if (backToIndexButton) {
            backToIndexButton.addEventListener('click', () => {
                window.location.href = 'index.html';
            });
        }

        if (continueToNextGameButton) {
            continueToNextGameButton.addEventListener('click', () => {
                window.location.href = 'kimcuongquatraloicauhoi.html';
            });
        }

        function showTutorialStep(index) {
            tutorialSteps.forEach((step, i) => {
                step.classList.toggle('hidden', i !== index);
            });
        }

        function startGame(finalLevel, isFree) {
            CONFIG.FINAL_LEVEL = finalLevel;
            isFreePlayMode = isFree;
            startScreen.style.display = 'none';
            tutorialModal.classList.remove('hidden');
            showTutorialStep(0);
        }

        easyModeBtn.addEventListener('click', () => startGame(1, false));
        hardModeBtn.addEventListener('click', () => startGame(3, false));
        freeModeBtn.addEventListener('click', () => startGame(Infinity, true));

        const isTouch = window.matchMedia('(pointer: coarse)').matches;
        if (isTouch) {
            document.body.style.cursor = 'auto';
            customCursor.style.display = 'none';
            canvas.style.cursor = 'auto';
        } else {
            document.body.style.cursor = 'none';
            customCursor.style.display = 'block';
            canvas.style.cursor = 'none';
            
            let rafScheduled = false;
            let lastMouseEvent = null;
            document.addEventListener('mousemove', (e) => {
                lastMouseEvent = e;
                if (!rafScheduled) {
                    rafScheduled = true;
                    requestAnimationFrame(() => {
                        if (lastMouseEvent) {
                            customCursor.style.left = lastMouseEvent.clientX + 'px';
                            customCursor.style.top = lastMouseEvent.clientY + 'px';
                            if (startScreen.style.display === 'none') {
                                trackPupil(pupil1, lastMouseEvent);
                                trackPupil(pupil2, lastMouseEvent);
                            }
                        }
                        rafScheduled = false;
                    });
                }
            });
        }

        tutorialNextBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                currentTutorialStep++;
                if (currentTutorialStep < tutorialSteps.length) {
                    showTutorialStep(currentTutorialStep);
                }
            });
        });

        playFromTutorialBtn.addEventListener('click', async () => {
            tutorialModal.classList.add('hidden');
            backToMenuBtn.classList.remove('hidden'); 
            
            await AudioManager.start();
            init();

            canvas.addEventListener('pointerdown', handlePointerStart);
            canvas.addEventListener('pointermove', handlePointerMove);
            canvas.addEventListener('pointerup', handlePointerEnd);
            canvas.addEventListener('pointercancel', handlePointerEnd);
            
            canvas.addEventListener('touchstart', handlePointerStart, { passive: false });
            canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
            canvas.addEventListener('touchend', handlePointerEnd);
            canvas.addEventListener('touchcancel', handlePointerEnd);

            window.addEventListener('resize', resizeCanvas);
        });

        backToMenuBtn.addEventListener('click', () => {
            window.location.href = 'index.html';
        });
    });

    window.addEventListener('beforeunload', () => {
        if (threatInterval) clearInterval(threatInterval);
        if (hintTimeout) clearTimeout(hintTimeout);
    });

})(); // K·∫øt th√∫c IIFE
</script>
</body>
</html>
